!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
$argv	tool/omittest.tcl	/^  process_options $argv$/;"	p
$memfile	tool/memleak3.tcl	/^process_input $memfile memmap$/;"	p
ACCEPT	tool/lemon.c	/^    ACCEPT,$/;"	e	enum:action::e_action	file:
ADDR	src/vdbe.h	130;"	d
ALLOWRELEASE	Makefile	/^ALLOWRELEASE = $/;"	m
ALTER	tool/mkkeywordhash.c	53;"	d	file:
ALTER	tool/mkkeywordhash.c	55;"	d	file:
ALWAYS	tool/mkkeywordhash.c	57;"	d	file:
ANALYZE	tool/mkkeywordhash.c	59;"	d	file:
ANALYZE	tool/mkkeywordhash.c	61;"	d	file:
ASSERT_VALID_DOCLIST	ext/fts2/fts2.c	730;"	d	file:
ASSERT_VALID_DOCLIST	ext/fts2/fts2.c	732;"	d	file:
ASSERT_VALID_DOCLIST	ext/fts3/fts3.c	718;"	d	file:
ASSERT_VALID_DOCLIST	ext/fts3/fts3.c	720;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	ext/fts2/fts2.c	4036;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	ext/fts2/fts2.c	4038;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	ext/fts3/fts3.c	4384;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	ext/fts3/fts3.c	4386;"	d	file:
ASSERT_VALID_LEAF_NODE	ext/fts2/fts2.c	4439;"	d	file:
ASSERT_VALID_LEAF_NODE	ext/fts2/fts2.c	4441;"	d	file:
ASSERT_VALID_LEAF_NODE	ext/fts3/fts3.c	4787;"	d	file:
ASSERT_VALID_LEAF_NODE	ext/fts3/fts3.c	4789;"	d	file:
ASYNC_CLOSE	src/test_async.c	294;"	d	file:
ASYNC_DELETE	src/test_async.c	295;"	d	file:
ASYNC_NOOP	src/test_async.c	290;"	d	file:
ASYNC_OPENEXCLUSIVE	src/test_async.c	296;"	d	file:
ASYNC_SYNC	src/test_async.c	292;"	d	file:
ASYNC_TRACE	src/test_async.c	141;"	d	file:
ASYNC_TRUNCATE	src/test_async.c	293;"	d	file:
ASYNC_UNLOCK	src/test_async.c	297;"	d	file:
ASYNC_WRITE	src/test_async.c	291;"	d	file:
ATTACH	tool/mkkeywordhash.c	64;"	d	file:
ATTACH	tool/mkkeywordhash.c	66;"	d	file:
AUTOINCR	tool/mkkeywordhash.c	69;"	d	file:
AUTOINCR	tool/mkkeywordhash.c	71;"	d	file:
AUTOVACUUM	tool/mkkeywordhash.c	135;"	d	file:
AUTOVACUUM	tool/mkkeywordhash.c	137;"	d	file:
Action_add	tool/lemon.c	/^void Action_add(app,type,sp,arg)$/;"	f
Action_new	tool/lemon.c	/^static struct action *Action_new(void){$/;"	f	file:
Action_sort	tool/lemon.c	/^static struct action *Action_sort($/;"	f	file:
AggInfo	src/sqliteInt.h	/^struct AggInfo {$/;"	s
AggInfo	src/sqliteInt.h	/^typedef struct AggInfo AggInfo;$/;"	t	typeref:struct:AggInfo
AggInfo_col	src/sqliteInt.h	/^  struct AggInfo_col {    \/* For each column used in source tables *\/$/;"	s	struct:AggInfo
AggInfo_func	src/sqliteInt.h	/^  struct AggInfo_func {   \/* For each aggregate function *\/$/;"	s	struct:AggInfo
AreFileApisANSI	src/os_win.c	69;"	d	file:
Argv0	src/shell.c	/^static char *Argv0;$/;"	v	file:
ArraySize	src/shell.c	356;"	d	file:
ArraySize	src/sqliteInt.h	333;"	d
AsyncFile	src/test_async.c	/^struct AsyncFile {$/;"	s	file:
AsyncFile	src/test_async.c	/^typedef struct AsyncFile AsyncFile;$/;"	t	typeref:struct:AsyncFile	file:
AsyncFileData	src/test_async.c	/^struct AsyncFileData {$/;"	s	file:
AsyncFileData	src/test_async.c	/^typedef struct AsyncFileData AsyncFileData;$/;"	t	typeref:struct:AsyncFileData	file:
AsyncFileLock	src/test_async.c	/^struct AsyncFileLock {$/;"	s	file:
AsyncFileLock	src/test_async.c	/^typedef struct AsyncFileLock AsyncFileLock;$/;"	t	typeref:struct:AsyncFileLock	file:
AsyncLock	src/test_async.c	/^struct AsyncLock {$/;"	s	file:
AsyncLock	src/test_async.c	/^typedef struct AsyncLock AsyncLock;$/;"	t	typeref:struct:AsyncLock	file:
AsyncWrite	src/test_async.c	/^struct AsyncWrite {$/;"	s	file:
AsyncWrite	src/test_async.c	/^typedef struct AsyncWrite AsyncWrite;$/;"	t	typeref:struct:AsyncWrite	file:
AttachKey	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	s	file:
AuthContext	src/sqliteInt.h	/^struct AuthContext {$/;"	s
AuthContext	src/sqliteInt.h	/^typedef struct AuthContext AuthContext;$/;"	t	typeref:struct:AuthContext
AuxData	src/vdbeInt.h	/^  struct AuxData {$/;"	s	struct:VdbeFunc
BCC	Makefile	/^BCC = gcc -g$/;"	m
BEGIN_TIMER	src/shell.c	100;"	d	file:
BEGIN_TIMER	src/shell.c	104;"	d	file:
BEXE	Makefile	/^BEXE = $/;"	m
BLOBSIZE	src/test_onefile.c	90;"	d	file:
BLOCKSIZE	src/test_onefile.c	89;"	d	file:
BLOCK_DELETE_STMT	ext/fts2/fts2.c	/^  BLOCK_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_DELETE_STMT	ext/fts3/fts3.c	/^  BLOCK_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_INSERT_STMT	ext/fts2/fts2.c	/^  BLOCK_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_INSERT_STMT	ext/fts3/fts3.c	/^  BLOCK_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_SELECT_STMT	ext/fts2/fts2.c	/^  BLOCK_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_SELECT_STMT	ext/fts3/fts3.c	/^  BLOCK_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
BMS	src/where.c	26;"	d	file:
BTREE_AUTOVACUUM_FULL	src/btree.h	35;"	d
BTREE_AUTOVACUUM_INCR	src/btree.h	36;"	d
BTREE_AUTOVACUUM_NONE	src/btree.h	34;"	d
BTREE_CREATE	src/btree.h	77;"	d
BTREE_INTKEY	src/btree.h	120;"	d
BTREE_LEAFDATA	src/btree.h	122;"	d
BTREE_MEMORY	src/btree.h	74;"	d
BTREE_NO_READLOCK	src/btree.h	73;"	d
BTREE_OMIT_JOURNAL	src/btree.h	72;"	d
BTREE_PRIVATE	src/btree.h	82;"	d
BTREE_READONLY	src/btree.h	75;"	d
BTREE_READWRITE	src/btree.h	76;"	d
BTREE_ZERODATA	src/btree.h	121;"	d
BinaryOp	test/fuzz_common.tcl	/^proc BinaryOp {} {$/;"	p
Bitmask	src/sqliteInt.h	/^typedef u64 Bitmask;$/;"	t
Bool	src/vdbeInt.h	/^typedef unsigned char Bool;$/;"	t
Boolean	tool/lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	t	typeref:enum:__anon6	file:
BtCursor	src/btree.h	/^typedef struct BtCursor BtCursor;$/;"	t	typeref:struct:BtCursor
BtCursor	src/btreeInt.h	/^struct BtCursor {$/;"	s
BtLock	src/btreeInt.h	/^struct BtLock {$/;"	s
BtLock	src/btreeInt.h	/^typedef struct BtLock BtLock;$/;"	t	typeref:struct:BtLock
BtShared	src/btree.h	/^typedef struct BtShared BtShared;$/;"	t	typeref:struct:BtShared
BtShared	src/btreeInt.h	/^struct BtShared {$/;"	s
Btree	src/btree.h	/^typedef struct Btree Btree;$/;"	t	typeref:struct:Btree
Btree	src/btreeInt.h	/^struct Btree {$/;"	s
BtreeMutexArray	src/btree.h	/^struct BtreeMutexArray {$/;"	s
BtreeMutexArray	src/btree.h	/^typedef struct BtreeMutexArray BtreeMutexArray;$/;"	t	typeref:struct:BtreeMutexArray
BusyHandler	src/sqliteInt.h	/^struct BusyHandler {$/;"	s
BusyHandler	src/sqliteInt.h	/^typedef struct BusyHandler BusyHandler;$/;"	t	typeref:struct:BusyHandler
ByteRangeLockPB2	src/os_unix.c	/^struct ByteRangeLockPB2$/;"	s	file:
CACHE_STALE	src/vdbeInt.h	107;"	d
CAST	tool/mkkeywordhash.c	74;"	d	file:
CAST	tool/mkkeywordhash.c	76;"	d	file:
CHECK_FOR_INTERRUPT	src/vdbe.c	461;"	d	file:
CHECK_PAGE	src/pager.c	875;"	d	file:
CHECK_PAGE	src/pager.c	885;"	d	file:
CHECK_THREADID	src/os_unix.c	165;"	d	file:
CHECK_THREADID	src/os_unix.c	169;"	d	file:
CHUNK_MAX	ext/fts1/fts1.c	1038;"	d	file:
CLEAR	ext/fts2/fts2.c	397;"	d	file:
CLEAR	ext/fts3/fts3.c	379;"	d	file:
CODEC1	src/pager.c	304;"	d	file:
CODEC1	src/pager.c	307;"	d	file:
CODEC2	src/pager.c	305;"	d	file:
CODEC2	src/pager.c	308;"	d	file:
COLNAME_COLUMN	src/vdbe.h	121;"	d
COLNAME_DATABASE	src/vdbe.h	119;"	d
COLNAME_DECLTYPE	src/vdbe.h	118;"	d
COLNAME_N	src/vdbe.h	122;"	d
COLNAME_NAME	src/vdbe.h	117;"	d
COLNAME_TABLE	src/vdbe.h	120;"	d
COMPLETE	tool/lemon.c	/^    COMPLETE,              \/* The status is used during followset and *\/$/;"	e	enum:config::__anon8	file:
COMPOUND	tool/mkkeywordhash.c	79;"	d	file:
COMPOUND	tool/mkkeywordhash.c	81;"	d	file:
CONFLICT	tool/mkkeywordhash.c	84;"	d	file:
CONFLICT	tool/mkkeywordhash.c	86;"	d	file:
CONTENT_DELETE_STMT	ext/fts1/fts1.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_DELETE_STMT	ext/fts2/fts2.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_DELETE_STMT	ext/fts3/fts3.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	ext/fts1/fts1.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	ext/fts2/fts2.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	ext/fts3/fts3.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	ext/fts1/fts1.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	ext/fts2/fts2.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	ext/fts3/fts3.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_UPDATE_STMT	ext/fts1/fts1.c	/^  CONTENT_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_UPDATE_STMT	ext/fts2/fts2.c	/^  CONTENT_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_UPDATE_STMT	ext/fts3/fts3.c	/^  CONTENT_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
CURSOR_FAULT	src/btreeInt.h	482;"	d
CURSOR_INVALID	src/btreeInt.h	479;"	d
CURSOR_REQUIRESEEK	src/btreeInt.h	481;"	d
CURSOR_VALID	src/btreeInt.h	480;"	d
CellInfo	src/btreeInt.h	/^struct CellInfo {$/;"	s
CellInfo	src/btreeInt.h	/^typedef struct CellInfo CellInfo;$/;"	t	typeref:struct:CellInfo
Check	test/fuzz_common.tcl	/^proc Check {} {$/;"	p
Cleanup	src/vdbeaux.c	/^static void Cleanup(Vdbe *p){$/;"	f	file:
CollSeq	src/sqliteInt.h	/^struct CollSeq {$/;"	s
CollSeq	src/sqliteInt.h	/^typedef struct CollSeq CollSeq;$/;"	t	typeref:struct:CollSeq
Coltype	test/fuzz_common.tcl	/^proc Coltype {} {$/;"	p
Column	src/sqliteInt.h	/^struct Column {$/;"	s
Column	src/sqliteInt.h	/^typedef struct Column Column;$/;"	t	typeref:struct:Column
Column	test/fuzz_common.tcl	/^proc Column {} {$/;"	p
CompressTables	tool/lemon.c	/^void CompressTables(lemp)$/;"	f
ConfigPrint	tool/lemon.c	/^void ConfigPrint(fp,cfp)$/;"	f
Configcmp	tool/lemon.c	/^int Configcmp(a,b)$/;"	f
Configlist_add	tool/lemon.c	/^struct config *Configlist_add(rp,dot)$/;"	f
Configlist_addbasis	tool/lemon.c	/^struct config *Configlist_addbasis(rp,dot)$/;"	f
Configlist_basis	tool/lemon.c	/^struct config *Configlist_basis(){$/;"	f
Configlist_closure	tool/lemon.c	/^void Configlist_closure(lemp)$/;"	f
Configlist_eat	tool/lemon.c	/^void Configlist_eat(cfp)$/;"	f
Configlist_init	tool/lemon.c	/^void Configlist_init(){$/;"	f
Configlist_reset	tool/lemon.c	/^void Configlist_reset(){$/;"	f
Configlist_return	tool/lemon.c	/^struct config *Configlist_return(){$/;"	f
Configlist_sort	tool/lemon.c	/^void Configlist_sort(){$/;"	f
Configlist_sortbasis	tool/lemon.c	/^void Configlist_sortbasis(){$/;"	f
Configtable_clear	tool/lemon.c	/^void Configtable_clear(f)$/;"	f
Configtable_find	tool/lemon.c	/^struct config *Configtable_find(key)$/;"	f
Configtable_init	tool/lemon.c	/^void Configtable_init(){$/;"	f
Configtable_insert	tool/lemon.c	/^int Configtable_insert(data)$/;"	f
Context	src/test_md5.c	/^struct Context {$/;"	s	file:
Context	src/vdbeInt.h	/^struct Context {$/;"	s
Context	src/vdbeInt.h	/^typedef struct Context Context;$/;"	t	typeref:struct:Context
CountCtx	src/func.c	/^struct CountCtx {$/;"	s	file:
CountCtx	src/func.c	/^typedef struct CountCtx CountCtx;$/;"	t	typeref:struct:CountCtx	file:
CrashFile	src/test6.c	/^struct CrashFile {$/;"	s	file:
CrashFile	src/test6.c	/^typedef struct CrashFile CrashFile;$/;"	t	typeref:struct:CrashFile	file:
CrashFileVtab	src/test6.c	/^static const sqlite3_io_methods CrashFileVtab = {$/;"	v	file:
CrashGlobal	src/test6.c	/^struct CrashGlobal {$/;"	s	file:
CrashGlobal	src/test6.c	/^typedef struct CrashGlobal CrashGlobal;$/;"	t	typeref:struct:CrashGlobal	file:
CreateOrDropTableOrView	test/fuzz_common.tcl	/^proc CreateOrDropTableOrView {} {$/;"	p
CreateTable	test/fuzz_common.tcl	/^proc CreateTable {} {$/;"	p
CreateView	test/fuzz_common.tcl	/^proc CreateView {} {$/;"	p
Cursor	src/vdbeInt.h	/^struct Cursor {$/;"	s
Cursor	src/vdbeInt.h	/^typedef struct Cursor Cursor;$/;"	t	typeref:struct:Cursor
D	src/date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
DATABASE_FILE	src/test_onefile.c	125;"	d	file:
DB_Empty	src/sqliteInt.h	444;"	d
DB_FILE	test/threadtest2.c	28;"	d	file:
DB_SchemaLoaded	src/sqliteInt.h	442;"	d
DB_UnresetViews	src/sqliteInt.h	443;"	d
DEBUGONLY	src/sqliteInt.h	1664;"	d
DEBUGONLY	src/sqliteInt.h	1667;"	d
DEVSYM_MAX_PATHNAME	src/test_devsym.c	25;"	d	file:
DEVSYM_VFS_NAME	src/test_devsym.c	30;"	d	file:
DLCollector	ext/fts2/fts2.c	/^typedef struct DLCollector {$/;"	s	file:
DLCollector	ext/fts2/fts2.c	/^} DLCollector;$/;"	t	typeref:struct:DLCollector	file:
DLCollector	ext/fts3/fts3.c	/^typedef struct DLCollector {$/;"	s	file:
DLCollector	ext/fts3/fts3.c	/^} DLCollector;$/;"	t	typeref:struct:DLCollector	file:
DLReader	ext/fts2/fts2.c	/^typedef struct DLReader {$/;"	s	file:
DLReader	ext/fts2/fts2.c	/^} DLReader;$/;"	t	typeref:struct:DLReader	file:
DLReader	ext/fts3/fts3.c	/^typedef struct DLReader {$/;"	s	file:
DLReader	ext/fts3/fts3.c	/^} DLReader;$/;"	t	typeref:struct:DLReader	file:
DLWriter	ext/fts2/fts2.c	/^typedef struct DLWriter {$/;"	s	file:
DLWriter	ext/fts2/fts2.c	/^} DLWriter;$/;"	t	typeref:struct:DLWriter	file:
DLWriter	ext/fts3/fts3.c	/^typedef struct DLWriter {$/;"	s	file:
DLWriter	ext/fts3/fts3.c	/^} DLWriter;$/;"	t	typeref:struct:DLWriter	file:
DL_DEFAULT	ext/fts1/fts1.c	231;"	d	file:
DL_DEFAULT	ext/fts2/fts2.c	373;"	d	file:
DL_DEFAULT	ext/fts3/fts3.c	355;"	d	file:
DL_DOCIDS	ext/fts1/fts1.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_DOCIDS	ext/fts2/fts2.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_DOCIDS	ext/fts3/fts3.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	ext/fts1/fts1.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	ext/fts2/fts2.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	ext/fts3/fts3.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	ext/fts1/fts1.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	ext/fts2/fts2.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	ext/fts3/fts3.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DO_OS_MALLOC_TEST	src/os.c	38;"	d	file:
DO_OS_MALLOC_TEST	src/os.c	44;"	d	file:
DataBuffer	ext/fts2/fts2.c	/^typedef struct DataBuffer {$/;"	s	file:
DataBuffer	ext/fts2/fts2.c	/^} DataBuffer;$/;"	t	typeref:struct:DataBuffer	file:
DataBuffer	ext/fts3/fts3.c	/^typedef struct DataBuffer {$/;"	s	file:
DataBuffer	ext/fts3/fts3.c	/^} DataBuffer;$/;"	t	typeref:struct:DataBuffer	file:
DateTime	src/date.c	/^struct DateTime {$/;"	s	file:
DateTime	src/date.c	/^typedef struct DateTime DateTime;$/;"	t	typeref:struct:DateTime	file:
Db	src/sqliteInt.h	/^struct Db {$/;"	s
Db	src/sqliteInt.h	/^typedef struct Db Db;$/;"	t	typeref:struct:Db
DbBusyHandler	src/tclsqlite.c	/^static int DbBusyHandler(void *cd, int nTries){$/;"	f	file:
DbClearProperty	src/sqliteInt.h	430;"	d
DbCommitHandler	src/tclsqlite.c	/^static int DbCommitHandler(void *cd){$/;"	f	file:
DbDeleteCmd	src/tclsqlite.c	/^static void DbDeleteCmd(void *db){$/;"	f	file:
DbFixer	src/sqliteInt.h	/^struct DbFixer {$/;"	s
DbFixer	src/sqliteInt.h	/^typedef struct DbFixer DbFixer;$/;"	t	typeref:struct:DbFixer
DbHasAnyProperty	src/sqliteInt.h	428;"	d
DbHasProperty	src/sqliteInt.h	427;"	d
DbMain	src/tclsqlite.c	/^static int DbMain(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbObjCmd	src/tclsqlite.c	/^static int DbObjCmd(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbPage	src/pager.h	/^typedef struct PgHdr DbPage;$/;"	t	typeref:struct:PgHdr
DbProfileHandler	src/tclsqlite.c	/^static void DbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm){$/;"	f	file:
DbProgressHandler	src/tclsqlite.c	/^static int DbProgressHandler(void *cd){$/;"	f	file:
DbRollbackHandler	src/tclsqlite.c	/^static void DbRollbackHandler(void *clientData){$/;"	f	file:
DbSetProperty	src/sqliteInt.h	429;"	d
DbTraceHandler	src/tclsqlite.c	/^static void DbTraceHandler(void *cd, const char *zSql){$/;"	f	file:
DbUpdateHandler	src/tclsqlite.c	/^static void DbUpdateHandler($/;"	f	file:
Deephemeralize	src/vdbe.c	154;"	d	file:
Delete	test/fuzz_common.tcl	/^proc Delete {} {$/;"	p
DevsymGlobal	src/test_devsym.c	/^struct DevsymGlobal {$/;"	s	file:
DigestToBase16	src/test_md5.c	/^static void DigestToBase16(unsigned char *digest, char *zBuf){$/;"	f	file:
DocList	ext/fts1/fts1.c	/^typedef struct DocList {$/;"	s	file:
DocList	ext/fts1/fts1.c	/^} DocList;$/;"	t	typeref:struct:DocList	file:
DocListReader	ext/fts1/fts1.c	/^typedef struct DocListReader {$/;"	s	file:
DocListReader	ext/fts1/fts1.c	/^} DocListReader;$/;"	t	typeref:struct:DocListReader	file:
DocListType	ext/fts1/fts1.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	ext/fts1/fts1.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DocListType	ext/fts2/fts2.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	ext/fts2/fts2.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DocListType	ext/fts3/fts3.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	ext/fts3/fts3.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DropTable	test/fuzz_common.tcl	/^proc DropTable {} {$/;"	p
DropView	test/fuzz_common.tcl	/^proc DropView {} {$/;"	p
ENABLE_FILE_LOCKING	src/test_async.c	107;"	d	file:
ENC	src/sqliteInt.h	552;"	d
END_TIMER	src/shell.c	101;"	d	file:
END_TIMER	src/shell.c	105;"	d	file:
EP_Agg	src/sqliteInt.h	1083;"	d
EP_Dequoted	src/sqliteInt.h	1088;"	d
EP_Distinct	src/sqliteInt.h	1086;"	d
EP_Error	src/sqliteInt.h	1085;"	d
EP_ExpCollate	src/sqliteInt.h	1090;"	d
EP_FromJoin	src/sqliteInt.h	1082;"	d
EP_InfixFunc	src/sqliteInt.h	1089;"	d
EP_Resolved	src/sqliteInt.h	1084;"	d
EP_VarSelect	src/sqliteInt.h	1087;"	d
ERRMSGSIZE	tool/lemon.c	1313;"	d	file:
ERROR	tool/lemon.c	/^    ERROR,$/;"	e	enum:action::e_action	file:
EXCLUSIVE_LOCK	src/os.h	152;"	d
EXPLAIN	tool/mkkeywordhash.c	89;"	d	file:
EXPLAIN	tool/mkkeywordhash.c	91;"	d	file:
EXTOBJ	main.mk	/^EXTOBJ = icu.o$/;"	m
EXTRA_SIZE	src/btreeInt.h	304;"	d
EchoModule	src/test8.c	/^struct EchoModule {$/;"	s	file:
EchoModule	src/test8.c	/^typedef struct EchoModule EchoModule;$/;"	t	typeref:struct:EchoModule	file:
ErrorMsg	tool/lemon.c	/^void ErrorMsg(const char *filename, int lineno, const char *format, ...){$/;"	f
EvalEvent	src/test_thread.c	/^struct EvalEvent {$/;"	s	file:
EvalEvent	src/test_thread.c	/^typedef struct EvalEvent EvalEvent;$/;"	t	typeref:struct:EvalEvent	file:
Exit	test/threadtest1.c	/^static void Exit(int rc){$/;"	f	file:
ExpandBlob	src/vdbe.c	162;"	d	file:
Expr	src/sqliteInt.h	/^struct Expr {$/;"	s
Expr	src/sqliteInt.h	/^typedef struct Expr Expr;$/;"	t	typeref:struct:Expr
Expr	test/fuzz_common.tcl	/^proc Expr { {c {}} } {$/;"	p
ExprClearProperty	src/sqliteInt.h	1099;"	d
ExprHasAnyProperty	src/sqliteInt.h	1097;"	d
ExprHasProperty	src/sqliteInt.h	1096;"	d
ExprList	src/sqliteInt.h	/^struct ExprList {$/;"	s
ExprList	src/sqliteInt.h	/^typedef struct ExprList ExprList;$/;"	t	typeref:struct:ExprList
ExprList_item	src/sqliteInt.h	/^  struct ExprList_item {$/;"	s	struct:ExprList
ExprMaskSet	src/where.c	/^struct ExprMaskSet {$/;"	s	file:
ExprMaskSet	src/where.c	/^typedef struct ExprMaskSet ExprMaskSet;$/;"	t	typeref:struct:ExprMaskSet	file:
ExprSetProperty	src/sqliteInt.h	1098;"	d
F1	src/test_md5.c	70;"	d	file:
F2	src/test_md5.c	71;"	d	file:
F3	src/test_md5.c	72;"	d	file:
F4	src/test_md5.c	73;"	d	file:
FILEHANDLEID	src/pager.c	55;"	d	file:
FKEY	tool/mkkeywordhash.c	94;"	d	file:
FKEY	tool/mkkeywordhash.c	96;"	d	file:
FKey	src/sqliteInt.h	/^struct FKey {$/;"	s
FKey	src/sqliteInt.h	/^typedef struct FKey FKey;$/;"	t	typeref:struct:FKey
FLAG_INTERN	src/printf.c	102;"	d	file:
FLAG_SIGNED	src/printf.c	101;"	d	file:
FLAG_STRING	src/printf.c	103;"	d	file:
FORCE_ALIGNMENT	src/pager.c	132;"	d	file:
FOREGUARD	src/mem2.c	84;"	d	file:
FS_VFS_NAME	src/test_onefile.c	95;"	d	file:
FTS1_HASH_BINARY	ext/fts1/fts1_hash.h	71;"	d
FTS1_HASH_STRING	ext/fts1/fts1_hash.h	70;"	d
FTS1_ROTOR_MASK	ext/fts1/fts1.c	2205;"	d	file:
FTS1_ROTOR_SZ	ext/fts1/fts1.c	2204;"	d	file:
FTS2_HASH_BINARY	ext/fts2/fts2_hash.h	71;"	d
FTS2_HASH_STRING	ext/fts2/fts2_hash.h	70;"	d
FTS2_ROTOR_MASK	ext/fts2/fts2.c	2976;"	d	file:
FTS2_ROTOR_SZ	ext/fts2/fts2.c	2975;"	d	file:
FTS3_HASH_BINARY	ext/fts3/fts3_hash.h	69;"	d
FTS3_HASH_STRING	ext/fts3/fts3_hash.h	68;"	d
FTS3_ROTOR_MASK	ext/fts3/fts3.c	3147;"	d	file:
FTS3_ROTOR_SZ	ext/fts3/fts3.c	3146;"	d	file:
FTSTRACE	ext/fts3/fts3.c	312;"	d	file:
FaultInjector	src/fault.c	/^static struct FaultInjector {$/;"	s	file:
Fifo	src/vdbeInt.h	/^struct Fifo {$/;"	s
Fifo	src/vdbeInt.h	/^typedef struct Fifo Fifo;$/;"	t	typeref:struct:Fifo
FifoPage	src/vdbeInt.h	/^struct FifoPage {$/;"	s
FifoPage	src/vdbeInt.h	/^typedef struct FifoPage FifoPage;$/;"	t	typeref:struct:FifoPage
FindActions	tool/lemon.c	/^void FindActions(lemp)$/;"	f
FindFirstSets	tool/lemon.c	/^void FindFirstSets(lemp)$/;"	f
FindFollowSets	tool/lemon.c	/^void FindFollowSets(lemp)$/;"	f
FindLinks	tool/lemon.c	/^void FindLinks(lemp)$/;"	f
FindRulePrecedences	tool/lemon.c	/^void FindRulePrecedences(xp)$/;"	f
FindStates	tool/lemon.c	/^void FindStates(lemp)$/;"	f
FtsToken	ext/fts3/fts3.c	/^typedef struct FtsToken {$/;"	s	file:
FtsToken	ext/fts3/fts3.c	/^} FtsToken;$/;"	t	typeref:struct:FtsToken	file:
FuncDef	src/sqliteInt.h	/^struct FuncDef {$/;"	s
FuncDef	src/sqliteInt.h	/^typedef struct FuncDef FuncDef;$/;"	t	typeref:struct:FuncDef
GetTempPathA	src/os_win.c	311;"	d	file:
GetVarint	src/vdbe.c	141;"	d	file:
GetVarint	src/vdbeaux.c	2105;"	d	file:
GlogUpperToLower	src/func.c	416;"	d	file:
GlogUpperToLower	src/func.c	418;"	d	file:
HANDLE_TO_WINFILE	src/os_win.c	317;"	d	file:
HAS_TIMER	src/shell.c	102;"	d	file:
HAS_TIMER	src/shell.c	106;"	d	file:
HAVE_FULLFSYNC	src/os_unix.c	907;"	d	file:
HAVE_FULLFSYNC	src/os_unix.c	909;"	d	file:
HAVE_TCL	Makefile	/^HAVE_TCL = $/;"	m
HDR	Makefile	/^HDR = \\$/;"	m
HDR	main.mk	/^HDR = \\$/;"	m
Hash	src/hash.h	/^struct Hash {$/;"	s
Hash	src/hash.h	/^typedef struct Hash Hash;$/;"	t	typeref:struct:Hash
HashElem	src/hash.h	/^struct HashElem {$/;"	s
HashElem	src/hash.h	/^typedef struct HashElem HashElem;$/;"	t	typeref:struct:HashElem
INCL_DOSDATETIME	src/os.h	79;"	d
INCL_DOSERRORS	src/os.h	81;"	d
INCL_DOSFILEMGR	src/os.h	80;"	d
INCL_DOSMISC	src/os.h	82;"	d
INCL_DOSMODULEMGR	src/os.h	84;"	d
INCL_DOSPROCESS	src/os.h	83;"	d
INCL_DOSSEMAPHORES	src/os.h	85;"	d
INCOMPLETE	tool/lemon.c	/^    INCOMPLETE             \/*    shift computations *\/$/;"	e	enum:config::__anon8	file:
INITIALIZE	tool/lemon.c	/^    INITIALIZE,$/;"	e	enum:pstate::e_state	file:
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INT16_TYPE	src/sqliteInt.h	257;"	d
INT8_TYPE	src/sqliteInt.h	263;"	d
INTERFACE	lempar.c	22;"	d	file:
INTERFACE	parse.c	59;"	d	file:
INTERFACE	tool/lempar.c	22;"	d	file:
INTERIOR_MAX	ext/fts2/fts2.c	3926;"	d	file:
INTERIOR_MAX	ext/fts3/fts3.c	4272;"	d	file:
INTERIOR_MIN_TERMS	ext/fts2/fts2.c	3933;"	d	file:
INTERIOR_MIN_TERMS	ext/fts3/fts3.c	4279;"	d	file:
INVALID_SET_FILE_POINTER	src/os_win.c	623;"	d	file:
IN_DECLARE_VTAB	src/sqliteInt.h	1452;"	d
IN_DECLARE_VTAB	src/sqliteInt.h	1454;"	d
IN_INDEX_EPH	src/sqliteInt.h	2044;"	d
IN_INDEX_INDEX	src/sqliteInt.h	2045;"	d
IN_INDEX_ROWID	src/sqliteInt.h	2043;"	d
IN_RHS	tool/lemon.c	/^    IN_RHS,$/;"	e	enum:pstate::e_state	file:
IOTRACE	src/sqliteInt.h	2080;"	d
IOTRACE	src/sqliteInt.h	2083;"	d
ISAUTOVACUUM	src/btreeInt.h	607;"	d
ISAUTOVACUUM	src/btreeInt.h	609;"	d
ISOPT	tool/lemon.c	1647;"	d	file:
IcuCursor	ext/fts2/fts2_icu.c	/^struct IcuCursor {$/;"	s	file:
IcuCursor	ext/fts2/fts2_icu.c	/^typedef struct IcuCursor IcuCursor;$/;"	t	typeref:struct:IcuCursor	file:
IcuCursor	ext/fts3/fts3_icu.c	/^struct IcuCursor {$/;"	s	file:
IcuCursor	ext/fts3/fts3_icu.c	/^typedef struct IcuCursor IcuCursor;$/;"	t	typeref:struct:IcuCursor	file:
IcuTokenizer	ext/fts2/fts2_icu.c	/^struct IcuTokenizer {$/;"	s	file:
IcuTokenizer	ext/fts2/fts2_icu.c	/^typedef struct IcuTokenizer IcuTokenizer;$/;"	t	typeref:struct:IcuTokenizer	file:
IcuTokenizer	ext/fts3/fts3_icu.c	/^struct IcuTokenizer {$/;"	s	file:
IcuTokenizer	ext/fts3/fts3_icu.c	/^typedef struct IcuTokenizer IcuTokenizer;$/;"	t	typeref:struct:IcuTokenizer	file:
IdChar	ext/fts1/fts1.c	1559;"	d	file:
IdChar	ext/fts2/fts2.c	2336;"	d	file:
IdChar	src/complete.c	30;"	d	file:
IdChar	src/complete.c	34;"	d	file:
IdChar	src/tokenize.c	115;"	d	file:
IdChar	src/tokenize.c	97;"	d	file:
IdList	src/sqliteInt.h	/^struct IdList {$/;"	s
IdList	src/sqliteInt.h	/^typedef struct IdList IdList;$/;"	t	typeref:struct:IdList
IdList_item	src/sqliteInt.h	/^  struct IdList_item {$/;"	s	struct:IdList
Identifier	test/fuzz_common.tcl	/^proc Identifier {} {$/;"	p
IgnorableOrderby	src/sqliteInt.h	1356;"	d
InLoop	src/sqliteInt.h	/^  struct InLoop {$/;"	s	struct:WhereLevel
Incrblob	src/vdbeblob.c	/^struct Incrblob {$/;"	s	file:
Incrblob	src/vdbeblob.c	/^typedef struct Incrblob Incrblob;$/;"	t	typeref:struct:Incrblob	file:
IncrblobChannel	src/tclsqlite.c	/^struct IncrblobChannel {$/;"	s	file:
IncrblobChannel	src/tclsqlite.c	/^typedef struct IncrblobChannel IncrblobChannel;$/;"	t	typeref:struct:IncrblobChannel	file:
IncrblobChannelType	src/tclsqlite.c	/^static Tcl_ChannelType IncrblobChannelType = {$/;"	v	file:
Index	src/sqliteInt.h	/^struct Index {$/;"	s
Index	src/sqliteInt.h	/^typedef struct Index Index;$/;"	t	typeref:struct:Index
InitData	src/sqliteInt.h	/^} InitData;$/;"	t	typeref:struct:__anon14
Insert	test/fuzz_common.tcl	/^proc Insert {} {$/;"	p
IntegrityCk	src/btreeInt.h	/^struct IntegrityCk {$/;"	s
IntegrityCk	src/btreeInt.h	/^typedef struct IntegrityCk IntegrityCk;$/;"	t	typeref:struct:IntegrityCk
InteriorBlock	ext/fts2/fts2.c	/^typedef struct InteriorBlock {$/;"	s	file:
InteriorBlock	ext/fts2/fts2.c	/^} InteriorBlock;$/;"	t	typeref:struct:InteriorBlock	file:
InteriorBlock	ext/fts3/fts3.c	/^typedef struct InteriorBlock {$/;"	s	file:
InteriorBlock	ext/fts3/fts3.c	/^} InteriorBlock;$/;"	t	typeref:struct:InteriorBlock	file:
InteriorReader	ext/fts2/fts2.c	/^typedef struct InteriorReader {$/;"	s	file:
InteriorReader	ext/fts2/fts2.c	/^} InteriorReader;$/;"	t	typeref:struct:InteriorReader	file:
InteriorReader	ext/fts3/fts3.c	/^typedef struct InteriorReader {$/;"	s	file:
InteriorReader	ext/fts3/fts3.c	/^} InteriorReader;$/;"	t	typeref:struct:InteriorReader	file:
InteriorWriter	ext/fts2/fts2.c	/^typedef struct InteriorWriter {$/;"	s	file:
InteriorWriter	ext/fts2/fts2.c	/^} InteriorWriter;$/;"	t	typeref:struct:InteriorWriter	file:
InteriorWriter	ext/fts3/fts3.c	/^typedef struct InteriorWriter {$/;"	s	file:
InteriorWriter	ext/fts3/fts3.c	/^} InteriorWriter;$/;"	t	typeref:struct:InteriorWriter	file:
IsHiddenColumn	src/sqliteInt.h	803;"	d
IsHiddenColumn	src/sqliteInt.h	806;"	d
IsVirtual	src/sqliteInt.h	802;"	d
IsVirtual	src/sqliteInt.h	805;"	d
JOURNAL_FILE	src/test_onefile.c	126;"	d	file:
JOURNAL_HDR_SZ	src/pager.c	474;"	d	file:
JOURNAL_PG_SZ	src/pager.c	467;"	d	file:
JT_CROSS	src/sqliteInt.h	1193;"	d
JT_ERROR	src/sqliteInt.h	1198;"	d
JT_INNER	src/sqliteInt.h	1192;"	d
JT_LEFT	src/sqliteInt.h	1195;"	d
JT_NATURAL	src/sqliteInt.h	1194;"	d
JT_OUTER	src/sqliteInt.h	1197;"	d
JT_RIGHT	src/sqliteInt.h	1196;"	d
JournalFile	src/journal.c	/^struct JournalFile {$/;"	s	file:
JournalFile	src/journal.c	/^typedef struct JournalFile JournalFile;$/;"	t	typeref:struct:JournalFile	file:
JournalFileMethods	src/journal.c	/^static struct sqlite3_io_methods JournalFileMethods = {$/;"	v	typeref:struct:sqlite3_io_methods	file:
KeyClass	src/sqliteInt.h	/^typedef struct KeyClass KeyClass;$/;"	t	typeref:struct:KeyClass
KeyInfo	src/sqliteInt.h	/^struct KeyInfo {$/;"	s
KeyInfo	src/sqliteInt.h	/^typedef struct KeyInfo KeyInfo;$/;"	t	typeref:struct:KeyInfo
Keyword	tool/mkkeywordhash.c	/^struct Keyword {$/;"	s	file:
Keyword	tool/mkkeywordhash.c	/^typedef struct Keyword Keyword;$/;"	t	typeref:struct:Keyword	file:
LEAF_MAX	ext/fts2/fts2.c	4345;"	d	file:
LEAF_MAX	ext/fts3/fts3.c	4693;"	d	file:
LEAF_SELECT	ext/fts2/fts2.c	1841;"	d	file:
LEAF_SELECT	ext/fts3/fts3.c	1979;"	d	file:
LEFT	tool/lemon.c	/^    LEFT,$/;"	e	enum:symbol::e_assoc	file:
LEMON_FALSE	tool/lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	e	enum:__anon6	file:
LEMON_TRUE	tool/lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	e	enum:__anon6	file:
LHS_ALIAS_1	tool/lemon.c	/^    LHS_ALIAS_1,$/;"	e	enum:pstate::e_state	file:
LHS_ALIAS_2	tool/lemon.c	/^    LHS_ALIAS_2,$/;"	e	enum:pstate::e_state	file:
LHS_ALIAS_3	tool/lemon.c	/^    LHS_ALIAS_3,$/;"	e	enum:pstate::e_state	file:
LIBOBJ	Makefile	/^LIBOBJ = alter.lo analyze.lo attach.lo auth.lo btmutex.lo btree.lo build.lo \\$/;"	m
LIBPTHREAD	Makefile	/^LIBPTHREAD=-lpthread $/;"	m
LIBREADLINE	Makefile	/^LIBREADLINE = $/;"	m
LIBTCL	Makefile	/^LIBTCL =  $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = .\/libtool$/;"	m
LINESIZE	tool/lemon.c	2984;"	d	file:
LINEWIDTH	tool/lemon.c	1314;"	d	file:
LINKVAR	src/test_config.c	422;"	d	file:
LISTSIZE	tool/lemon.c	1616;"	d	file:
LOCKFILE_FAIL_IMMEDIATELY	src/os_win.c	756;"	d	file:
LONGDOUBLE_TYPE	src/sqliteInt.h	169;"	d
LONGDOUBLE_TYPE	src/sqliteInt.h	266;"	d
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) --mode=compile --tag=CC $(TCC)$/;"	m
LTINSTALL	Makefile	/^LTINSTALL = $(LIBTOOL) --mode=install $(INSTALL)$/;"	m
LTLINK	Makefile	/^LTLINK = $(LIBTOOL) --mode=link $(TCC) $/;"	m
LeafReader	ext/fts2/fts2.c	/^typedef struct LeafReader {$/;"	s	file:
LeafReader	ext/fts2/fts2.c	/^} LeafReader;$/;"	t	typeref:struct:LeafReader	file:
LeafReader	ext/fts3/fts3.c	/^typedef struct LeafReader {$/;"	s	file:
LeafReader	ext/fts3/fts3.c	/^} LeafReader;$/;"	t	typeref:struct:LeafReader	file:
LeafWriter	ext/fts2/fts2.c	/^typedef struct LeafWriter {$/;"	s	file:
LeafWriter	ext/fts2/fts2.c	/^} LeafWriter;$/;"	t	typeref:struct:LeafWriter	file:
LeafWriter	ext/fts3/fts3.c	/^typedef struct LeafWriter {$/;"	s	file:
LeafWriter	ext/fts3/fts3.c	/^} LeafWriter;$/;"	t	typeref:struct:LeafWriter	file:
LeavesReader	ext/fts2/fts2.c	/^typedef struct LeavesReader {$/;"	s	file:
LeavesReader	ext/fts2/fts2.c	/^} LeavesReader;$/;"	t	typeref:struct:LeavesReader	file:
LeavesReader	ext/fts3/fts3.c	/^typedef struct LeavesReader {$/;"	s	file:
LeavesReader	ext/fts3/fts3.c	/^} LeavesReader;$/;"	t	typeref:struct:LeavesReader	file:
LikeOp	parse.c	/^struct LikeOp {$/;"	s	file:
LimitVal	parse.c	/^struct LimitVal {$/;"	s	file:
Literal	test/fuzz_common.tcl	/^proc Literal {} {$/;"	p
LockFile	src/os_win.c	313;"	d	file:
LockFileEx	src/os_win.c	315;"	d	file:
M	src/date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
MASTER_NAME	src/sqliteInt.h	316;"	d
MASTER_ROOT	src/sqliteInt.h	322;"	d
MAX	src/test_async.c	130;"	d	file:
MAX	src/test_onefile.c	244;"	d	file:
MAXRHS	tool/lemon.c	32;"	d	file:
MAXRHS	tool/lemon.c	34;"	d	file:
MAX_6BYTE	src/vdbeaux.c	1839;"	d	file:
MAX_PATHNAME	src/os_unix.c	76;"	d	file:
MAX_PREPARED_STMTS	src/tclsqlite.c	42;"	d	file:
MAX_ROWID	src/vdbe.c	3095;"	d	file:
MAX_STMT	ext/fts1/fts1.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MAX_STMT	ext/fts2/fts2.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MAX_STMT	ext/fts3/fts3.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MD5Context	src/test_md5.c	/^typedef struct Context MD5Context;$/;"	t	typeref:struct:Context	file:
MD5Final	src/test_md5.c	/^static void MD5Final(unsigned char digest[16], MD5Context *pCtx){$/;"	f	file:
MD5Init	src/test_md5.c	/^static void MD5Init(MD5Context *ctx){$/;"	f	file:
MD5STEP	src/test_md5.c	76;"	d	file:
MD5Transform	src/test_md5.c	/^static void MD5Transform(uint32 buf[4], const uint32 in[16]){$/;"	f	file:
MD5Update	src/test_md5.c	/^void MD5Update(MD5Context *pCtx, const unsigned char *buf, unsigned int len){$/;"	f	file:
MEMDB	src/pager.c	483;"	d	file:
MEMDB	src/pager.c	485;"	d	file:
MEM_Agg	src/vdbeInt.h	167;"	d
MEM_Blob	src/vdbeInt.h	155;"	d
MEM_Dyn	src/vdbeInt.h	163;"	d
MEM_Ephem	src/vdbeInt.h	165;"	d
MEM_Int	src/vdbeInt.h	153;"	d
MEM_Null	src/vdbeInt.h	151;"	d
MEM_Real	src/vdbeInt.h	154;"	d
MEM_Short	src/vdbeInt.h	166;"	d
MEM_Static	src/vdbeInt.h	164;"	d
MEM_Str	src/vdbeInt.h	152;"	d
MEM_Term	src/vdbeInt.h	162;"	d
MEM_Zero	src/vdbeInt.h	168;"	d
MEM_Zero	src/vdbeInt.h	171;"	d
MEM_Zero	src/vdbeInt.h	172;"	d
MERGE_COUNT	ext/fts2/fts2.c	385;"	d	file:
MERGE_COUNT	ext/fts3/fts3.c	367;"	d	file:
MIN	src/test_async.c	129;"	d	file:
MIN	src/test_onefile.c	243;"	d	file:
MODE_Column	src/shell.c	332;"	d	file:
MODE_Csv	src/shell.c	338;"	d	file:
MODE_Explain	src/shell.c	340;"	d	file:
MODE_Html	src/shell.c	335;"	d	file:
MODE_Insert	src/shell.c	336;"	d	file:
MODE_Line	src/shell.c	331;"	d	file:
MODE_List	src/shell.c	333;"	d	file:
MODE_NUM_OF	src/shell.c	339;"	d	file:
MODE_Semi	src/shell.c	334;"	d	file:
MODE_Tcl	src/shell.c	337;"	d	file:
MSG_Close	src/test_server.c	244;"	d	file:
MSG_Done	src/test_server.c	245;"	d	file:
MSG_Finalize	src/test_server.c	243;"	d	file:
MSG_Open	src/test_server.c	239;"	d	file:
MSG_Prepare	src/test_server.c	240;"	d	file:
MSG_Reset	src/test_server.c	242;"	d	file:
MSG_Step	src/test_server.c	241;"	d	file:
MULTITERMINAL	tool/lemon.c	/^    MULTITERMINAL$/;"	e	enum:symbol::__anon7	file:
MX_CELL	src/btreeInt.h	227;"	d
MX_CELL_SIZE	src/btreeInt.h	221;"	d
MX_CLOSE_ATTEMPT	src/os_win.c	600;"	d	file:
MX_DELETION_ATTEMPTS	src/os_win.c	1196;"	d	file:
MX_SMALL	src/mem3.c	40;"	d	file:
Md5_Init	src/test_md5.c	/^int Md5_Init(Tcl_Interp *interp){$/;"	f
Md5_Register	src/test_md5.c	/^int Md5_Register(sqlite3 *db){$/;"	f
Mem	src/vdbe.h	/^typedef struct Mem Mem;$/;"	t	typeref:struct:Mem
Mem	src/vdbeInt.h	/^struct Mem {$/;"	s
Mem3Block	src/mem3.c	/^struct Mem3Block {$/;"	s	file:
Mem3Block	src/mem3.c	/^typedef struct Mem3Block Mem3Block;$/;"	t	typeref:struct:Mem3Block	file:
MemBlockHdr	src/mem2.c	/^struct MemBlockHdr {$/;"	s	file:
MemPage	src/btreeInt.h	/^struct MemPage {$/;"	s
MemPage	src/btreeInt.h	/^typedef struct MemPage MemPage;$/;"	t	typeref:struct:MemPage
MemoryCheck	tool/lemon.c	278;"	d	file:
Module	src/sqliteInt.h	/^struct Module {$/;"	s
Module	src/sqliteInt.h	/^typedef struct Module Module;$/;"	t	typeref:struct:Module
NAWK	Makefile	/^NAWK = gawk$/;"	m
NB	src/btree.c	4646;"	d	file:
NBFS	src/vdbeInt.h	102;"	d
NCSIZE	src/mem2.c	90;"	d	file:
NDEBUG	src/sqliteInt.h	149;"	d
NDELAY	src/main.c	322;"	d	file:
NEXT	tool/lemon.c	1548;"	d	file:
NN	src/btree.c	4645;"	d	file:
NONE	tool/lemon.c	/^    NONE,$/;"	e	enum:symbol::e_assoc	file:
NONTERMINAL	tool/lemon.c	/^    NONTERMINAL,$/;"	e	enum:symbol::__anon7	file:
NOT_USED	tool/lemon.c	/^    NOT_USED                 \/* Deleted by compression *\/$/;"	e	enum:action::e_action	file:
NO_LOCK	src/os.h	148;"	d
NO_OFFSET	tool/lemon.c	221;"	d	file:
NULL_DISTINCT_FOR_UNIQUE	src/sqliteInt.h	204;"	d
NUM_PREPARED_STMTS	src/tclsqlite.c	41;"	d	file:
N_HASH	src/mem3.c	46;"	d	file:
N_SORT_BUCKET	src/pager.c	2895;"	d	file:
N_SORT_BUCKET	src/pager.c	2898;"	d	file:
N_SORT_BUCKET	src/pager.c	2899;"	d	file:
N_SORT_BUCKET_ALLOC	src/pager.c	2894;"	d	file:
N_THREAD	src/test4.c	56;"	d	file:
N_THREAD	src/test7.c	79;"	d	file:
NameContext	src/sqliteInt.h	/^struct NameContext {$/;"	s
NameContext	src/sqliteInt.h	/^typedef struct NameContext NameContext;$/;"	t	typeref:struct:NameContext
OE_Abort	src/sqliteInt.h	877;"	d
OE_Cascade	src/sqliteInt.h	885;"	d
OE_Default	src/sqliteInt.h	887;"	d
OE_Fail	src/sqliteInt.h	878;"	d
OE_Ignore	src/sqliteInt.h	879;"	d
OE_None	src/sqliteInt.h	875;"	d
OE_Replace	src/sqliteInt.h	880;"	d
OE_Restrict	src/sqliteInt.h	882;"	d
OE_Rollback	src/sqliteInt.h	876;"	d
OE_SetDflt	src/sqliteInt.h	884;"	d
OE_SetNull	src/sqliteInt.h	883;"	d
OMIT_TEMPDB	src/sqliteInt.h	187;"	d
OMIT_TEMPDB	src/sqliteInt.h	189;"	d
OPFLAG_APPEND	src/sqliteInt.h	1472;"	d
OPFLAG_ISUPDATE	src/sqliteInt.h	1471;"	d
OPFLAG_LASTROWID	src/sqliteInt.h	1470;"	d
OPFLAG_NCHANGE	src/sqliteInt.h	1469;"	d
OPFLG_IN1	opcodes.h	155;"	d
OPFLG_IN2	opcodes.h	156;"	d
OPFLG_IN3	opcodes.h	157;"	d
OPFLG_INITIALIZER	opcodes.h	159;"	d
OPFLG_JUMP	opcodes.h	153;"	d
OPFLG_OUT2_PRERELEASE	opcodes.h	154;"	d
OPFLG_OUT3	opcodes.h	158;"	d
OPT_DBL	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::__anon5	file:
OPT_FDBL	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::__anon5	file:
OPT_FFLAG	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::__anon5	file:
OPT_FINT	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::__anon5	file:
OPT_FLAG	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::__anon5	file:
OPT_FSTR	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::__anon5	file:
OPT_INT	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::__anon5	file:
OPT_STR	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::__anon5	file:
OP_Add	opcodes.h	121;"	d
OP_AddImm	opcodes.h	52;"	d
OP_AggFinal	opcodes.h	87;"	d
OP_AggStep	opcodes.h	96;"	d
OP_And	opcodes.h	30;"	d
OP_AutoCommit	opcodes.h	22;"	d
OP_BitAnd	opcodes.h	64;"	d
OP_BitNot	opcodes.h	127;"	d
OP_BitOr	opcodes.h	106;"	d
OP_Blob	opcodes.h	120;"	d
OP_Clear	opcodes.h	92;"	d
OP_Close	opcodes.h	43;"	d
OP_CollSeq	opcodes.h	19;"	d
OP_Column	opcodes.h	4;"	d
OP_Concat	opcodes.h	63;"	d
OP_ContextPop	opcodes.h	105;"	d
OP_ContextPush	opcodes.h	74;"	d
OP_Copy	opcodes.h	26;"	d
OP_CreateIndex	opcodes.h	44;"	d
OP_CreateTable	opcodes.h	66;"	d
OP_Delete	opcodes.h	86;"	d
OP_Destroy	opcodes.h	111;"	d
OP_Divide	opcodes.h	59;"	d
OP_DropIndex	opcodes.h	76;"	d
OP_DropTable	opcodes.h	82;"	d
OP_DropTrigger	opcodes.h	75;"	d
OP_Eq	opcodes.h	12;"	d
OP_Expire	opcodes.h	21;"	d
OP_Explain	opcodes.h	115;"	d
OP_FifoRead	opcodes.h	91;"	d
OP_FifoWrite	opcodes.h	73;"	d
OP_ForceInt	opcodes.h	113;"	d
OP_Found	opcodes.h	129;"	d
OP_Function	opcodes.h	28;"	d
OP_Ge	opcodes.h	9;"	d
OP_Gosub	opcodes.h	58;"	d
OP_Goto	opcodes.h	89;"	d
OP_Gt	opcodes.h	23;"	d
OP_Halt	opcodes.h	49;"	d
OP_IdxDelete	opcodes.h	78;"	d
OP_IdxGE	opcodes.h	77;"	d
OP_IdxInsert	opcodes.h	108;"	d
OP_IdxLT	opcodes.h	51;"	d
OP_IdxRowid	opcodes.h	70;"	d
OP_If	opcodes.h	15;"	d
OP_IfNeg	opcodes.h	29;"	d
OP_IfNot	opcodes.h	81;"	d
OP_IfPos	opcodes.h	130;"	d
OP_IfZero	opcodes.h	126;"	d
OP_IncrVacuum	opcodes.h	69;"	d
OP_Insert	opcodes.h	110;"	d
OP_Int64	opcodes.h	47;"	d
OP_Integer	opcodes.h	60;"	d
OP_IntegrityCk	opcodes.h	24;"	d
OP_IsNull	opcodes.h	68;"	d
OP_IsUnique	opcodes.h	45;"	d
OP_Last	opcodes.h	67;"	d
OP_Le	opcodes.h	94;"	d
OP_LoadAnalysis	opcodes.h	114;"	d
OP_Lt	opcodes.h	109;"	d
OP_MakeRecord	opcodes.h	83;"	d
OP_MemMax	opcodes.h	55;"	d
OP_Move	opcodes.h	119;"	d
OP_MoveGe	opcodes.h	123;"	d
OP_MoveGt	opcodes.h	8;"	d
OP_MoveLe	opcodes.h	80;"	d
OP_MoveLt	opcodes.h	93;"	d
OP_Multiply	opcodes.h	36;"	d
OP_MustBeInt	opcodes.h	48;"	d
OP_Ne	opcodes.h	103;"	d
OP_NewRowid	opcodes.h	35;"	d
OP_Next	opcodes.h	107;"	d
OP_Noop	opcodes.h	32;"	d
OP_Not	opcodes.h	98;"	d
OP_NotExists	opcodes.h	57;"	d
OP_NotFound	opcodes.h	46;"	d
OP_NotNull	opcodes.h	14;"	d
OP_NotUsed_124	opcodes.h	134;"	d
OP_NotUsed_126	opcodes.h	135;"	d
OP_NotUsed_127	opcodes.h	136;"	d
OP_NotUsed_128	opcodes.h	137;"	d
OP_NotUsed_129	opcodes.h	138;"	d
OP_NotUsed_130	opcodes.h	139;"	d
OP_NotUsed_131	opcodes.h	140;"	d
OP_NotUsed_132	opcodes.h	141;"	d
OP_NotUsed_133	opcodes.h	142;"	d
OP_NotUsed_134	opcodes.h	143;"	d
OP_NotUsed_135	opcodes.h	144;"	d
OP_NotUsed_136	opcodes.h	145;"	d
OP_NotUsed_137	opcodes.h	146;"	d
OP_Null	opcodes.h	118;"	d
OP_NullRow	opcodes.h	131;"	d
OP_OpenEphemeral	opcodes.h	117;"	d
OP_OpenPseudo	opcodes.h	116;"	d
OP_OpenRead	opcodes.h	20;"	d
OP_OpenWrite	opcodes.h	13;"	d
OP_Or	opcodes.h	56;"	d
OP_ParseSchema	opcodes.h	41;"	d
OP_Prev	opcodes.h	62;"	d
OP_ReadCookie	opcodes.h	112;"	d
OP_Real	opcodes.h	6;"	d
OP_RealAffinity	opcodes.h	39;"	d
OP_Remainder	opcodes.h	34;"	d
OP_ResetCount	opcodes.h	72;"	d
OP_ResultRow	opcodes.h	85;"	d
OP_Return	opcodes.h	33;"	d
OP_Rewind	opcodes.h	122;"	d
OP_RowData	opcodes.h	54;"	d
OP_RowKey	opcodes.h	10;"	d
OP_Rowid	opcodes.h	50;"	d
OP_SCopy	opcodes.h	11;"	d
OP_Sequence	opcodes.h	7;"	d
OP_SetCookie	opcodes.h	5;"	d
OP_SetNumColumns	opcodes.h	100;"	d
OP_ShiftLeft	opcodes.h	88;"	d
OP_ShiftRight	opcodes.h	71;"	d
OP_Sort	opcodes.h	25;"	d
OP_Statement	opcodes.h	53;"	d
OP_String	opcodes.h	38;"	d
OP_String8	opcodes.h	17;"	d
OP_Subtract	opcodes.h	31;"	d
OP_TableLock	opcodes.h	90;"	d
OP_ToBlob	opcodes.h	84;"	d
OP_ToInt	opcodes.h	16;"	d
OP_ToNumeric	opcodes.h	61;"	d
OP_ToReal	opcodes.h	99;"	d
OP_ToText	opcodes.h	97;"	d
OP_Trace	opcodes.h	27;"	d
OP_Transaction	opcodes.h	101;"	d
OP_VBegin	opcodes.h	124;"	d
OP_VColumn	opcodes.h	65;"	d
OP_VCreate	opcodes.h	128;"	d
OP_VDestroy	opcodes.h	104;"	d
OP_VFilter	opcodes.h	102;"	d
OP_VNext	opcodes.h	3;"	d
OP_VOpen	opcodes.h	42;"	d
OP_VRename	opcodes.h	40;"	d
OP_VRowid	opcodes.h	18;"	d
OP_VUpdate	opcodes.h	125;"	d
OP_Vacuum	opcodes.h	79;"	d
OP_Variable	opcodes.h	37;"	d
OP_VerifyCookie	opcodes.h	95;"	d
ORDERBY_MAX	src/sqliteInt.h	1249;"	d
ORDERBY_MIN	src/sqliteInt.h	1248;"	d
ORDERBY_NORMAL	src/sqliteInt.h	1247;"	d
OSTRACE1	src/os_common.h	41;"	d
OSTRACE1	src/os_common.h	51;"	d
OSTRACE2	src/os_common.h	42;"	d
OSTRACE2	src/os_common.h	52;"	d
OSTRACE3	src/os_common.h	43;"	d
OSTRACE3	src/os_common.h	53;"	d
OSTRACE4	src/os_common.h	44;"	d
OSTRACE4	src/os_common.h	54;"	d
OSTRACE5	src/os_common.h	45;"	d
OSTRACE5	src/os_common.h	55;"	d
OSTRACE6	src/os_common.h	46;"	d
OSTRACE6	src/os_common.h	56;"	d
OSTRACE7	src/os_common.h	48;"	d
OSTRACE7	src/os_common.h	57;"	d
OS_OS2	src/os.h	35;"	d
OS_OS2	src/os.h	36;"	d
OS_OS2	src/os.h	47;"	d
OS_OS2	src/os.h	51;"	d
OS_OS2	src/os.h	55;"	d
OS_OS2	src/os.h	59;"	d
OS_OTHER	src/os.h	38;"	d
OS_OTHER	src/os.h	42;"	d
OS_UNIX	src/os.h	31;"	d
OS_UNIX	src/os.h	32;"	d
OS_UNIX	src/os.h	46;"	d
OS_UNIX	src/os.h	50;"	d
OS_UNIX	src/os.h	54;"	d
OS_UNIX	src/os.h	58;"	d
OS_WIN	src/os.h	33;"	d
OS_WIN	src/os.h	34;"	d
OS_WIN	src/os.h	45;"	d
OS_WIN	src/os.h	49;"	d
OS_WIN	src/os.h	53;"	d
OS_WIN	src/os.h	63;"	d
OS_WINCE	src/os_win.c	68;"	d	file:
OS_WINCE	src/os_win.c	71;"	d	file:
O_BINARY	src/os_unix.c	124;"	d	file:
O_LARGEFILE	src/os_unix.c	114;"	d	file:
O_LARGEFILE	src/os_unix.c	117;"	d	file:
O_LARGEFILE	src/os_unix.c	118;"	d	file:
O_NOFOLLOW	src/os_unix.c	121;"	d	file:
Op	src/vdbeInt.h	/^typedef struct VdbeOp Op;$/;"	t	typeref:struct:VdbeOp
OpenCounter	src/os_common.h	124;"	d
OpenCounter	src/os_common.h	126;"	d
OptArg	tool/lemon.c	/^char *OptArg(n)$/;"	f
OptErr	tool/lemon.c	/^void OptErr(n)$/;"	f
OptInit	tool/lemon.c	/^int OptInit(a,o,err)$/;"	f
OptNArgs	tool/lemon.c	/^int OptNArgs(){$/;"	f
OptPrint	tool/lemon.c	/^void OptPrint(){$/;"	f
OrderedDLReader	ext/fts2/fts2.c	/^typedef struct OrderedDLReader {$/;"	s	file:
OrderedDLReader	ext/fts2/fts2.c	/^} OrderedDLReader;$/;"	t	typeref:struct:OrderedDLReader	file:
OrderedDLReader	ext/fts3/fts3.c	/^typedef struct OrderedDLReader {$/;"	s	file:
OrderedDLReader	ext/fts3/fts3.c	/^} OrderedDLReader;$/;"	t	typeref:struct:OrderedDLReader	file:
P4_COLLSEQ	src/vdbe.h	92;"	d
P4_DYNAMIC	src/vdbe.h	90;"	d
P4_FUNCDEF	src/vdbe.h	93;"	d
P4_INT32	src/vdbe.h	102;"	d
P4_INT64	src/vdbe.h	101;"	d
P4_KEYINFO	src/vdbe.h	94;"	d
P4_KEYINFO_HANDOFF	src/vdbe.h	111;"	d
P4_MEM	src/vdbe.h	96;"	d
P4_MPRINTF	src/vdbe.h	99;"	d
P4_NOTUSED	src/vdbe.h	89;"	d
P4_REAL	src/vdbe.h	100;"	d
P4_STATIC	src/vdbe.h	91;"	d
P4_TRANSIENT	src/vdbe.h	97;"	d
P4_VDBEFUNC	src/vdbe.h	95;"	d
P4_VTAB	src/vdbe.h	98;"	d
PACKAGE_VERSION	src/tclsqlite.c	2436;"	d	file:
PAGERID	src/pager.c	54;"	d	file:
PAGERTRACE1	src/pager.c	39;"	d	file:
PAGERTRACE2	src/pager.c	40;"	d	file:
PAGERTRACE3	src/pager.c	41;"	d	file:
PAGERTRACE4	src/pager.c	42;"	d	file:
PAGERTRACE5	src/pager.c	43;"	d	file:
PAGER_EXCLUSIVE	src/pager.c	108;"	d	file:
PAGER_INCR	src/pager.c	419;"	d	file:
PAGER_INCR	src/pager.c	421;"	d	file:
PAGER_LOCKINGMODE_EXCLUSIVE	src/pager.h	51;"	d
PAGER_LOCKINGMODE_NORMAL	src/pager.h	50;"	d
PAGER_LOCKINGMODE_QUERY	src/pager.h	49;"	d
PAGER_MAX_PGNO	src/pager.c	501;"	d	file:
PAGER_MJ_PGNO	src/pager.c	496;"	d	file:
PAGER_NO_READLOCK	src/pager.h	44;"	d
PAGER_OMIT_JOURNAL	src/pager.h	43;"	d
PAGER_RESERVED	src/pager.c	107;"	d	file:
PAGER_SHARED	src/pager.c	106;"	d	file:
PAGER_SYNCED	src/pager.c	109;"	d	file:
PAGER_UNLOCK	src/pager.c	105;"	d	file:
PAGESIZE	tool/diffdb.c	13;"	d	file:
PENDING_BYTE	src/os.h	212;"	d
PENDING_BYTE	src/os.h	215;"	d
PENDING_BYTE_PAGE	src/btreeInt.h	512;"	d
PENDING_BYTE_PAGE	src/btreeInt.h	514;"	d
PENDING_LOCK	src/os.h	151;"	d
PGHDR_TO_DATA	src/pager.c	315;"	d	file:
PGHDR_TO_EXTRA	src/pager.c	316;"	d	file:
PGHDR_TO_HIST	src/pager.c	317;"	d	file:
PLReader	ext/fts2/fts2.c	/^typedef struct PLReader {$/;"	s	file:
PLReader	ext/fts2/fts2.c	/^} PLReader;$/;"	t	typeref:struct:PLReader	file:
PLReader	ext/fts3/fts3.c	/^typedef struct PLReader {$/;"	s	file:
PLReader	ext/fts3/fts3.c	/^} PLReader;$/;"	t	typeref:struct:PLReader	file:
PLWriter	ext/fts2/fts2.c	/^typedef struct PLWriter {$/;"	s	file:
PLWriter	ext/fts2/fts2.c	/^} PLWriter;$/;"	t	typeref:struct:PLWriter	file:
PLWriter	ext/fts3/fts3.c	/^typedef struct PLWriter {$/;"	s	file:
PLWriter	ext/fts3/fts3.c	/^} PLWriter;$/;"	t	typeref:struct:PLWriter	file:
POS_BASE	ext/fts1/fts1.c	/^  POS_BASE$/;"	e	enum:__anon3	file:
POS_BASE	ext/fts2/fts2.c	/^  POS_BASE$/;"	e	enum:__anon2	file:
POS_BASE	ext/fts3/fts3.c	/^  POS_BASE$/;"	e	enum:__anon1	file:
POS_COLUMN	ext/fts1/fts1.c	/^  POS_COLUMN,         \/* followed by new column number *\/$/;"	e	enum:__anon3	file:
POS_COLUMN	ext/fts2/fts2.c	/^  POS_COLUMN,         \/* followed by new column number *\/$/;"	e	enum:__anon2	file:
POS_COLUMN	ext/fts3/fts3.c	/^  POS_COLUMN,         \/* followed by new column number *\/$/;"	e	enum:__anon1	file:
POS_END	ext/fts1/fts1.c	/^  POS_END = 0,        \/* end of this position list *\/$/;"	e	enum:__anon3	file:
POS_END	ext/fts2/fts2.c	/^  POS_END = 0,        \/* end of this position list *\/$/;"	e	enum:__anon2	file:
POS_END	ext/fts3/fts3.c	/^  POS_END = 0,        \/* end of this position list *\/$/;"	e	enum:__anon1	file:
PRAGMA	tool/mkkeywordhash.c	101;"	d	file:
PRAGMA	tool/mkkeywordhash.c	99;"	d	file:
PRECEDENCE_MARK_1	tool/lemon.c	/^    PRECEDENCE_MARK_1,$/;"	e	enum:pstate::e_state	file:
PRECEDENCE_MARK_2	tool/lemon.c	/^    PRECEDENCE_MARK_2,$/;"	e	enum:pstate::e_state	file:
PREFIXLIMIT	tool/lemon.c	1315;"	d	file:
PRIVATE	tool/lemon.c	29;"	d	file:
PTF_INTKEY	src/btreeInt.h	253;"	d
PTF_LEAF	src/btreeInt.h	256;"	d
PTF_LEAFDATA	src/btreeInt.h	255;"	d
PTF_ZERODATA	src/btreeInt.h	254;"	d
PTRMAP_BTREE	src/btreeInt.h	589;"	d
PTRMAP_FREEPAGE	src/btreeInt.h	586;"	d
PTRMAP_ISPAGE	src/btreeInt.h	552;"	d
PTRMAP_OVERFLOW1	src/btreeInt.h	587;"	d
PTRMAP_OVERFLOW2	src/btreeInt.h	588;"	d
PTRMAP_PAGENO	src/btreeInt.h	550;"	d
PTRMAP_PTROFFSET	src/btreeInt.h	551;"	d
PTRMAP_ROOTPAGE	src/btreeInt.h	585;"	d
Pager	src/pager.c	/^struct Pager {$/;"	s	file:
Pager	src/pager.h	/^typedef struct Pager Pager;$/;"	t	typeref:struct:Pager
PagerLruLink	src/pager.c	/^struct PagerLruLink {$/;"	s	file:
PagerLruLink	src/pager.c	/^typedef struct PagerLruLink PagerLruLink;$/;"	t	typeref:struct:PagerLruLink	file:
PagerLruList	src/pager.c	/^struct PagerLruList {$/;"	s	file:
PagerLruList	src/pager.c	/^typedef struct PagerLruList PagerLruList;$/;"	t	typeref:struct:PagerLruList	file:
Parse	lempar.c	/^void Parse($/;"	f
Parse	src/sqliteInt.h	/^struct Parse {$/;"	s
Parse	src/sqliteInt.h	/^typedef struct Parse Parse;$/;"	t	typeref:struct:Parse
Parse	tool/lemon.c	/^void Parse(gp)$/;"	f
Parse	tool/lempar.c	/^void Parse($/;"	f
ParseAlloc	lempar.c	/^void *ParseAlloc(void *(*mallocProc)(size_t)){$/;"	f
ParseAlloc	tool/lempar.c	/^void *ParseAlloc(void *(*mallocProc)(size_t)){$/;"	f
ParseFree	lempar.c	/^void ParseFree($/;"	f
ParseFree	tool/lempar.c	/^void ParseFree($/;"	f
ParseTrace	lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
ParseTrace	tool/lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
PgHdr	src/pager.c	/^struct PgHdr {$/;"	s	file:
PgHdr	src/pager.c	/^typedef struct PgHdr PgHdr;$/;"	t	typeref:struct:PgHdr	file:
PgHistory	src/pager.c	/^struct PgHistory {$/;"	s	file:
PgHistory	src/pager.c	/^typedef struct PgHistory PgHistory;$/;"	t	typeref:struct:PgHistory	file:
Pgno	src/pager.h	/^typedef unsigned int Pgno;$/;"	t
Plink_add	tool/lemon.c	/^void Plink_add(plpp,cfp)$/;"	f
Plink_copy	tool/lemon.c	/^void Plink_copy(to,from)$/;"	f
Plink_delete	tool/lemon.c	/^void Plink_delete(plp)$/;"	f
Plink_new	tool/lemon.c	/^struct plink *Plink_new(){$/;"	f
PrintAction	tool/lemon.c	/^int PrintAction(struct action *ap, FILE *fp, int indent){$/;"	f
QUERY_DOCID	ext/fts3/fts3.c	/^  QUERY_DOCID,     \/* lookup by docid *\/$/;"	e	enum:QueryType	file:
QUERY_FULLTEXT	ext/fts1/fts1.c	/^  QUERY_FULLTEXT   \/* QUERY_FULLTEXT + [i] is a full-text search for column i*\/$/;"	e	enum:QueryType	file:
QUERY_FULLTEXT	ext/fts2/fts2.c	/^  QUERY_FULLTEXT   \/* QUERY_FULLTEXT + [i] is a full-text search for column i*\/$/;"	e	enum:QueryType	file:
QUERY_FULLTEXT	ext/fts3/fts3.c	/^  QUERY_FULLTEXT   \/* QUERY_FULLTEXT + [i] is a full-text search for column i*\/$/;"	e	enum:QueryType	file:
QUERY_GENERIC	ext/fts1/fts1.c	/^  QUERY_GENERIC,   \/* table scan *\/$/;"	e	enum:QueryType	file:
QUERY_GENERIC	ext/fts2/fts2.c	/^  QUERY_GENERIC,   \/* table scan *\/$/;"	e	enum:QueryType	file:
QUERY_GENERIC	ext/fts3/fts3.c	/^  QUERY_GENERIC,   \/* table scan *\/$/;"	e	enum:QueryType	file:
QUERY_ROWID	ext/fts1/fts1.c	/^  QUERY_ROWID,     \/* lookup by rowid *\/$/;"	e	enum:QueryType	file:
QUERY_ROWID	ext/fts2/fts2.c	/^  QUERY_ROWID,     \/* lookup by rowid *\/$/;"	e	enum:QueryType	file:
Query	ext/fts1/fts1.c	/^typedef struct Query {$/;"	s	file:
Query	ext/fts1/fts1.c	/^} Query;$/;"	t	typeref:struct:Query	file:
Query	ext/fts2/fts2.c	/^typedef struct Query {$/;"	s	file:
Query	ext/fts2/fts2.c	/^} Query;$/;"	t	typeref:struct:Query	file:
Query	ext/fts3/fts3.c	/^typedef struct Query {$/;"	s	file:
Query	ext/fts3/fts3.c	/^} Query;$/;"	t	typeref:struct:Query	file:
QueryCoder	src/expr.c	/^struct QueryCoder {$/;"	s	file:
QueryCoder	src/expr.c	/^typedef struct QueryCoder QueryCoder;$/;"	t	typeref:struct:QueryCoder	file:
QueryResult	test/threadtest1.c	/^struct QueryResult {$/;"	s	file:
QueryTerm	ext/fts1/fts1.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	ext/fts1/fts1.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryTerm	ext/fts2/fts2.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	ext/fts2/fts2.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryTerm	ext/fts3/fts3.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	ext/fts3/fts3.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryType	ext/fts1/fts1.c	/^typedef enum QueryType {$/;"	g	file:
QueryType	ext/fts1/fts1.c	/^} QueryType;$/;"	t	typeref:enum:QueryType	file:
QueryType	ext/fts2/fts2.c	/^typedef enum QueryType {$/;"	g	file:
QueryType	ext/fts2/fts2.c	/^} QueryType;$/;"	t	typeref:enum:QueryType	file:
QueryType	ext/fts3/fts3.c	/^typedef enum QueryType {$/;"	g	file:
QueryType	ext/fts3/fts3.c	/^} QueryType;$/;"	t	typeref:enum:QueryType	file:
RD_RESOLVED	tool/lemon.c	/^    RD_RESOLVED,             \/* Was reduce.  Precedence resolved conflict *\/$/;"	e	enum:action::e_action	file:
READLINE_FLAGS	Makefile	/^READLINE_FLAGS = -DHAVE_READLINE=0 $/;"	m
READ_LOCK	src/btreeInt.h	532;"	d
READ_UTF16BE	src/utf.c	119;"	d	file:
READ_UTF16LE	src/utf.c	108;"	d	file:
REAL_LIBOBJ	Makefile	/^REAL_LIBOBJ = $(LIBOBJ:%.lo=.libs\/%.o)$/;"	m
REARGUARD	src/mem2.c	85;"	d	file:
REDUCE	tool/lemon.c	/^    REDUCE,$/;"	e	enum:action::e_action	file:
REFINFO	src/pager.c	549;"	d	file:
REFINFO	src/pager.c	551;"	d	file:
REGISTER_TRACE	src/vdbe.c	429;"	d	file:
REGISTER_TRACE	src/vdbe.c	431;"	d	file:
REINDEX	tool/mkkeywordhash.c	104;"	d	file:
REINDEX	tool/mkkeywordhash.c	106;"	d	file:
RELEASE	Makefile	/^RELEASE = 3.5.5$/;"	m
RESERVED_BYTE	src/os.h	218;"	d
RESERVED_LOCK	src/os.h	150;"	d
RESYNC_AFTER_DECL_ERROR	tool/lemon.c	/^    RESYNC_AFTER_DECL_ERROR,$/;"	e	enum:pstate::e_state	file:
RESYNC_AFTER_RULE_ERROR	tool/lemon.c	/^    RESYNC_AFTER_RULE_ERROR,$/;"	e	enum:pstate::e_state	file:
RHS_ALIAS_1	tool/lemon.c	/^    RHS_ALIAS_1,$/;"	e	enum:pstate::e_state	file:
RHS_ALIAS_2	tool/lemon.c	/^    RHS_ALIAS_2,$/;"	e	enum:pstate::e_state	file:
RIGHT	tool/lemon.c	/^    RIGHT,$/;"	e	enum:symbol::e_assoc	file:
ROOT_MAX	ext/fts2/fts2.c	3946;"	d	file:
ROOT_MAX	ext/fts3/fts3.c	4292;"	d	file:
ROUND8	src/btreeInt.h	215;"	d
RRCONFLICT	tool/lemon.c	/^    RRCONFLICT,              \/* Was a reduce, but part of a conflict *\/$/;"	e	enum:action::e_action	file:
Release	src/vdbe.c	116;"	d	file:
ReportHeader	tool/lemon.c	/^void ReportHeader(lemp)$/;"	f
ReportOutput	tool/lemon.c	/^void ReportOutput(lemp)$/;"	f
ReportTable	tool/lemon.c	/^void ReportTable(lemp, mhflag)$/;"	f
Reprint	tool/lemon.c	/^void Reprint(lemp)$/;"	f
ResortStates	tool/lemon.c	/^void ResortStates(lemp)$/;"	f
ResultSet	test/fuzz_common.tcl	/^proc ResultSet {{nRes 0} {c ""}} {$/;"	p
SAVE_SZ	src/build.c	238;"	d	file:
SCHEMA	src/test_schema.c	23;"	d	file:
SCHEMA_TABLE	src/sqliteInt.h	327;"	d
SCRAMBLE	ext/fts2/fts2.c	400;"	d	file:
SCRAMBLE	ext/fts2/fts2.c	402;"	d	file:
SCRAMBLE	ext/fts3/fts3.c	382;"	d	file:
SCRAMBLE	ext/fts3/fts3.c	384;"	d	file:
SEGDIR_DELETE_STMT	ext/fts2/fts2.c	/^  SEGDIR_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_DELETE_STMT	ext/fts3/fts3.c	/^  SEGDIR_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_MAX_INDEX_STMT	ext/fts2/fts2.c	/^  SEGDIR_MAX_INDEX_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_MAX_INDEX_STMT	ext/fts3/fts3.c	/^  SEGDIR_MAX_INDEX_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_ALL_STMT	ext/fts2/fts2.c	/^  SEGDIR_SELECT_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_ALL_STMT	ext/fts3/fts3.c	/^  SEGDIR_SELECT_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_STMT	ext/fts2/fts2.c	/^  SEGDIR_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_STMT	ext/fts3/fts3.c	/^  SEGDIR_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SET_STMT	ext/fts2/fts2.c	/^  SEGDIR_SET_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SET_STMT	ext/fts3/fts3.c	/^  SEGDIR_SET_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SPAN_STMT	ext/fts2/fts2.c	/^  SEGDIR_SPAN_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SPAN_STMT	ext/fts3/fts3.c	/^  SEGDIR_SPAN_STMT,$/;"	e	enum:fulltext_statement	file:
SET_FULLSYNC	src/os.h	96;"	d
SET_THREADID	src/os_unix.c	164;"	d	file:
SET_THREADID	src/os_unix.c	168;"	d	file:
SHARED_FIRST	src/os.h	219;"	d
SHARED_LOCK	src/os.h	149;"	d
SHARED_SIZE	src/os.h	220;"	d
SHIFT	tool/lemon.c	/^    SHIFT,$/;"	e	enum:action::e_action	file:
SHLIB_SUFFIX	Makefile	/^SHLIB_SUFFIX = @TCL_SHLIB_SUFFIX@$/;"	m
SH_RESOLVED	tool/lemon.c	/^    SH_RESOLVED,             \/* Was a shift.  Precedence resolved conflict *\/$/;"	e	enum:action::e_action	file:
SNIPPET_DESIRED	ext/fts1/fts1.c	2404;"	d	file:
SNIPPET_DESIRED	ext/fts2/fts2.c	3158;"	d	file:
SNIPPET_DESIRED	ext/fts3/fts3.c	3436;"	d	file:
SNIPPET_IGNORE	ext/fts1/fts1.c	2403;"	d	file:
SNIPPET_IGNORE	ext/fts2/fts2.c	3157;"	d	file:
SNIPPET_IGNORE	ext/fts3/fts3.c	3435;"	d	file:
SQLITE3_TEXT	sqlite3.h	2967;"	d
SQLITE_ABORT	sqlite3.h	376;"	d
SQLITE_ACCESS_EXISTS	sqlite3.h	824;"	d
SQLITE_ACCESS_READ	sqlite3.h	826;"	d
SQLITE_ACCESS_READWRITE	sqlite3.h	825;"	d
SQLITE_AFF_INTEGER	src/sqliteInt.h	713;"	d
SQLITE_AFF_MASK	src/sqliteInt.h	722;"	d
SQLITE_AFF_NONE	src/sqliteInt.h	711;"	d
SQLITE_AFF_NUMERIC	src/sqliteInt.h	712;"	d
SQLITE_AFF_REAL	src/sqliteInt.h	714;"	d
SQLITE_AFF_TEXT	src/sqliteInt.h	710;"	d
SQLITE_ALTER_TABLE	sqlite3.h	1788;"	d
SQLITE_ANALYZE	sqlite3.h	1790;"	d
SQLITE_ANY	sqlite3.h	3340;"	d
SQLITE_ASCII	src/sqliteInt.h	240;"	d
SQLITE_ASYNC_TWO_FILEHANDLES	src/test_async.c	258;"	d	file:
SQLITE_ATTACH	sqlite3.h	1786;"	d
SQLITE_AUTH	sqlite3.h	395;"	d
SQLITE_BIGENDIAN	src/sqliteInt.h	286;"	d
SQLITE_BIGENDIAN	src/sqliteInt.h	290;"	d
SQLITE_BIG_DBL	src/sqliteInt.h	171;"	d
SQLITE_BIG_DBL	src/sqliteInt.h	178;"	d
SQLITE_BLOB	sqlite3.h	2960;"	d
SQLITE_BUSY	sqlite3.h	377;"	d
SQLITE_BUSY_RESERVED_LOCK	src/pager.c	125;"	d	file:
SQLITE_CANTOPEN	sqlite3.h	386;"	d
SQLITE_COLL_BINARY	src/sqliteInt.h	685;"	d
SQLITE_COLL_NOCASE	src/sqliteInt.h	686;"	d
SQLITE_COLL_REVERSE	src/sqliteInt.h	687;"	d
SQLITE_COLL_USER	src/sqliteInt.h	688;"	d
SQLITE_CONSTRAINT	sqlite3.h	391;"	d
SQLITE_COPY	sqlite3.h	1794;"	d
SQLITE_CORE	ext/fts1/fts1.c	40;"	d	file:
SQLITE_CORE	ext/fts2/fts2.c	302;"	d	file:
SQLITE_CORE	ext/fts3/fts3.c	278;"	d	file:
SQLITE_CORE	src/loadext.c	18;"	d	file:
SQLITE_CORRUPT	sqlite3.h	383;"	d
SQLITE_CORRUPT_BKPT	src/sqliteInt.h	1663;"	d
SQLITE_CORRUPT_BKPT	src/sqliteInt.h	1666;"	d
SQLITE_CREATE_INDEX	sqlite3.h	1763;"	d
SQLITE_CREATE_TABLE	sqlite3.h	1764;"	d
SQLITE_CREATE_TEMP_INDEX	sqlite3.h	1765;"	d
SQLITE_CREATE_TEMP_TABLE	sqlite3.h	1766;"	d
SQLITE_CREATE_TEMP_TRIGGER	sqlite3.h	1767;"	d
SQLITE_CREATE_TEMP_VIEW	sqlite3.h	1768;"	d
SQLITE_CREATE_TRIGGER	sqlite3.h	1769;"	d
SQLITE_CREATE_VIEW	sqlite3.h	1770;"	d
SQLITE_CREATE_VTABLE	sqlite3.h	1791;"	d
SQLITE_CountRows	src/sqliteInt.h	566;"	d
SQLITE_DEFAULT_AUTOVACUUM	src/btree.h	31;"	d
SQLITE_DEFAULT_CACHE_SIZE	src/sqliteLimit.h	101;"	d
SQLITE_DEFAULT_FILE_FORMAT	src/sqliteInt.h	214;"	d
SQLITE_DEFAULT_FILE_PERMISSIONS	src/os_unix.c	70;"	d	file:
SQLITE_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	139;"	d
SQLITE_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	142;"	d
SQLITE_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	143;"	d
SQLITE_DEFAULT_SECTOR_SIZE	src/os.h	103;"	d
SQLITE_DEFAULT_TEMP_CACHE_SIZE	src/sqliteLimit.h	104;"	d
SQLITE_DELETE	sqlite3.h	1771;"	d
SQLITE_DENY	sqlite3.h	1718;"	d
SQLITE_DETACH	sqlite3.h	1787;"	d
SQLITE_DONE	sqlite3.h	400;"	d
SQLITE_DROP_INDEX	sqlite3.h	1772;"	d
SQLITE_DROP_TABLE	sqlite3.h	1773;"	d
SQLITE_DROP_TEMP_INDEX	sqlite3.h	1774;"	d
SQLITE_DROP_TEMP_TABLE	sqlite3.h	1775;"	d
SQLITE_DROP_TEMP_TRIGGER	sqlite3.h	1776;"	d
SQLITE_DROP_TEMP_VIEW	sqlite3.h	1777;"	d
SQLITE_DROP_TRIGGER	sqlite3.h	1778;"	d
SQLITE_DROP_VIEW	sqlite3.h	1779;"	d
SQLITE_DROP_VTABLE	sqlite3.h	1792;"	d
SQLITE_EBCDIC	src/sqliteInt.h	238;"	d
SQLITE_EMPTY	sqlite3.h	388;"	d
SQLITE_ERROR	sqlite3.h	373;"	d
SQLITE_EXTENSION_INIT1	src/sqlite3ext.h	347;"	d
SQLITE_EXTENSION_INIT2	src/sqlite3ext.h	348;"	d
SQLITE_EXTERN	sqlite3.h	51;"	d
SQLITE_FAULTINJECTOR_COUNT	src/sqliteInt.h	2018;"	d
SQLITE_FAULTINJECTOR_MALLOC	src/sqliteInt.h	2017;"	d
SQLITE_FCNTL_LOCKSTATE	sqlite3.h	660;"	d
SQLITE_FILE_HEADER	src/btreeInt.h	246;"	d
SQLITE_FLOAT	sqlite3.h	2959;"	d
SQLITE_FORMAT	sqlite3.h	396;"	d
SQLITE_FTS3_DEFAULT_NEAR_PARAM	ext/fts3/fts3.c	318;"	d	file:
SQLITE_FULL	sqlite3.h	385;"	d
SQLITE_FUNCTION	sqlite3.h	1793;"	d
SQLITE_FUNC_CASE	src/sqliteInt.h	632;"	d
SQLITE_FUNC_EPHEM	src/sqliteInt.h	633;"	d
SQLITE_FUNC_LIKE	src/sqliteInt.h	631;"	d
SQLITE_FullColNames	src/sqliteInt.h	564;"	d
SQLITE_FullFSync	src/sqliteInt.h	579;"	d
SQLITE_HASH_BINARY	src/hash.h	76;"	d
SQLITE_HASH_STRING	src/hash.h	75;"	d
SQLITE_IGNORE	sqlite3.h	1719;"	d
SQLITE_INDEX_CONSTRAINT_EQ	sqlite3.h	4306;"	d
SQLITE_INDEX_CONSTRAINT_GE	sqlite3.h	4310;"	d
SQLITE_INDEX_CONSTRAINT_GT	sqlite3.h	4307;"	d
SQLITE_INDEX_CONSTRAINT_LE	sqlite3.h	4308;"	d
SQLITE_INDEX_CONSTRAINT_LT	sqlite3.h	4309;"	d
SQLITE_INDEX_CONSTRAINT_MATCH	sqlite3.h	4311;"	d
SQLITE_INSERT	sqlite3.h	1780;"	d
SQLITE_INTEGER	sqlite3.h	2958;"	d
SQLITE_INTEGRITY_CHECK_ERROR_MAX	src/pragma.c	823;"	d	file:
SQLITE_INTERNAL	sqlite3.h	374;"	d
SQLITE_INTERRUPT	sqlite3.h	381;"	d
SQLITE_IOCAP_ATOMIC	sqlite3.h	493;"	d
SQLITE_IOCAP_ATOMIC16K	sqlite3.h	499;"	d
SQLITE_IOCAP_ATOMIC1K	sqlite3.h	495;"	d
SQLITE_IOCAP_ATOMIC2K	sqlite3.h	496;"	d
SQLITE_IOCAP_ATOMIC32K	sqlite3.h	500;"	d
SQLITE_IOCAP_ATOMIC4K	sqlite3.h	497;"	d
SQLITE_IOCAP_ATOMIC512	sqlite3.h	494;"	d
SQLITE_IOCAP_ATOMIC64K	sqlite3.h	501;"	d
SQLITE_IOCAP_ATOMIC8K	sqlite3.h	498;"	d
SQLITE_IOCAP_SAFE_APPEND	sqlite3.h	502;"	d
SQLITE_IOCAP_SEQUENTIAL	sqlite3.h	503;"	d
SQLITE_IOERR	sqlite3.h	382;"	d
SQLITE_IOERR_BLOCKED	sqlite3.h	449;"	d
SQLITE_IOERR_DELETE	sqlite3.h	448;"	d
SQLITE_IOERR_DIR_FSYNC	sqlite3.h	443;"	d
SQLITE_IOERR_FSTAT	sqlite3.h	445;"	d
SQLITE_IOERR_FSYNC	sqlite3.h	442;"	d
SQLITE_IOERR_NOMEM	sqlite3.h	450;"	d
SQLITE_IOERR_RDLOCK	sqlite3.h	447;"	d
SQLITE_IOERR_READ	sqlite3.h	439;"	d
SQLITE_IOERR_SHORT_READ	sqlite3.h	440;"	d
SQLITE_IOERR_TRUNCATE	sqlite3.h	444;"	d
SQLITE_IOERR_UNLOCK	sqlite3.h	446;"	d
SQLITE_IOERR_WRITE	sqlite3.h	441;"	d
SQLITE_IgnoreChecks	src/sqliteInt.h	576;"	d
SQLITE_InTrans	src/sqliteInt.h	562;"	d
SQLITE_InternChanges	src/sqliteInt.h	563;"	d
SQLITE_JUMPIFNULL	src/sqliteInt.h	728;"	d
SQLITE_LITTLEENDIAN	src/sqliteInt.h	287;"	d
SQLITE_LITTLEENDIAN	src/sqliteInt.h	291;"	d
SQLITE_LOCKED	sqlite3.h	378;"	d
SQLITE_LOCK_EXCLUSIVE	sqlite3.h	516;"	d
SQLITE_LOCK_NONE	sqlite3.h	512;"	d
SQLITE_LOCK_PENDING	sqlite3.h	515;"	d
SQLITE_LOCK_RESERVED	sqlite3.h	514;"	d
SQLITE_LOCK_SHARED	sqlite3.h	513;"	d
SQLITE_LegacyFileFmt	src/sqliteInt.h	578;"	d
SQLITE_LoadExtension	src/sqliteInt.h	580;"	d
SQLITE_MAGIC_BUSY	src/sqliteInt.h	594;"	d
SQLITE_MAGIC_CLOSED	src/sqliteInt.h	592;"	d
SQLITE_MAGIC_ERROR	src/sqliteInt.h	595;"	d
SQLITE_MAGIC_OPEN	src/sqliteInt.h	591;"	d
SQLITE_MAGIC_SICK	src/sqliteInt.h	593;"	d
SQLITE_MAX_ATTACHED	src/sqliteLimit.h	115;"	d
SQLITE_MAX_COLUMN	src/sqliteInt.h	70;"	d
SQLITE_MAX_COLUMN	src/sqliteInt.h	82;"	d
SQLITE_MAX_COLUMN	src/sqliteLimit.h	47;"	d
SQLITE_MAX_COMPOUND_SELECT	src/sqliteInt.h	73;"	d
SQLITE_MAX_COMPOUND_SELECT	src/sqliteInt.h	85;"	d
SQLITE_MAX_COMPOUND_SELECT	src/sqliteLimit.h	78;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	154;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	157;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	src/sqliteLimit.h	158;"	d
SQLITE_MAX_EXPR_DEPTH	src/sqliteInt.h	72;"	d
SQLITE_MAX_EXPR_DEPTH	src/sqliteInt.h	84;"	d
SQLITE_MAX_EXPR_DEPTH	src/sqliteLimit.h	66;"	d
SQLITE_MAX_FILE_FORMAT	src/sqliteInt.h	212;"	d
SQLITE_MAX_FUNCTION_ARG	src/sqliteInt.h	75;"	d
SQLITE_MAX_FUNCTION_ARG	src/sqliteInt.h	87;"	d
SQLITE_MAX_FUNCTION_ARG	src/sqliteLimit.h	93;"	d
SQLITE_MAX_LENGTH	src/sqliteInt.h	69;"	d
SQLITE_MAX_LENGTH	src/sqliteInt.h	81;"	d
SQLITE_MAX_LENGTH	src/sqliteLimit.h	26;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	ext/icu/icu.c	53;"	d	file:
SQLITE_MAX_LIKE_PATTERN_LENGTH	src/sqliteInt.h	79;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	src/sqliteInt.h	91;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	src/sqliteLimit.h	178;"	d
SQLITE_MAX_PAGE_COUNT	src/sqliteInt.h	78;"	d
SQLITE_MAX_PAGE_COUNT	src/sqliteInt.h	90;"	d
SQLITE_MAX_PAGE_COUNT	src/sqliteLimit.h	170;"	d
SQLITE_MAX_PAGE_SIZE	src/sqliteInt.h	77;"	d
SQLITE_MAX_PAGE_SIZE	src/sqliteInt.h	89;"	d
SQLITE_MAX_PAGE_SIZE	src/sqliteLimit.h	131;"	d
SQLITE_MAX_SQL_LENGTH	src/sqliteInt.h	71;"	d
SQLITE_MAX_SQL_LENGTH	src/sqliteInt.h	83;"	d
SQLITE_MAX_SQL_LENGTH	src/sqliteLimit.h	55;"	d
SQLITE_MAX_VARIABLE_NUMBER	src/sqliteInt.h	76;"	d
SQLITE_MAX_VARIABLE_NUMBER	src/sqliteInt.h	88;"	d
SQLITE_MAX_VARIABLE_NUMBER	src/sqliteLimit.h	123;"	d
SQLITE_MAX_VDBE_OP	src/sqliteInt.h	74;"	d
SQLITE_MAX_VDBE_OP	src/sqliteInt.h	86;"	d
SQLITE_MAX_VDBE_OP	src/sqliteLimit.h	86;"	d
SQLITE_MISMATCH	sqlite3.h	392;"	d
SQLITE_MISUSE	sqlite3.h	393;"	d
SQLITE_MIXED_ENDIAN_64BIT_FLOAT	src/sqliteInt.h	175;"	d
SQLITE_MUTEX_FAST	sqlite3.h	4717;"	d
SQLITE_MUTEX_NOOP	src/mutex.h	51;"	d
SQLITE_MUTEX_NOOP	src/mutex.h	53;"	d
SQLITE_MUTEX_NOOP	src/mutex.h	57;"	d
SQLITE_MUTEX_NOOP	src/mutex.h	61;"	d
SQLITE_MUTEX_NOOP	src/mutex.h	65;"	d
SQLITE_MUTEX_NOOP_DEBUG	src/mutex.h	54;"	d
SQLITE_MUTEX_OS2	src/mutex.h	66;"	d
SQLITE_MUTEX_PTHREADS	src/mutex.h	58;"	d
SQLITE_MUTEX_RECURSIVE	sqlite3.h	4718;"	d
SQLITE_MUTEX_STATIC_LRU	sqlite3.h	4723;"	d
SQLITE_MUTEX_STATIC_MASTER	sqlite3.h	4719;"	d
SQLITE_MUTEX_STATIC_MEM	sqlite3.h	4720;"	d
SQLITE_MUTEX_STATIC_MEM2	sqlite3.h	4721;"	d
SQLITE_MUTEX_STATIC_PRNG	sqlite3.h	4722;"	d
SQLITE_MUTEX_W32	src/mutex.h	62;"	d
SQLITE_NOLFS	sqlite3.h	394;"	d
SQLITE_NOMEM	sqlite3.h	379;"	d
SQLITE_NOTADB	sqlite3.h	398;"	d
SQLITE_NOTFOUND	sqlite3.h	384;"	d
SQLITE_NULL	sqlite3.h	2961;"	d
SQLITE_NULLEQUAL	src/sqliteInt.h	729;"	d
SQLITE_N_BTREE_META	src/btree.h	24;"	d
SQLITE_NoReadlock	src/sqliteInt.h	574;"	d
SQLITE_NullCallback	src/sqliteInt.h	569;"	d
SQLITE_OK	sqlite3.h	371;"	d
SQLITE_OMIT_DATETIME_FUNCS	src/sqliteInt.h	173;"	d
SQLITE_OMIT_TRACE	src/sqliteInt.h	174;"	d
SQLITE_OPEN_CREATE	sqlite3.h	462;"	d
SQLITE_OPEN_DELETEONCLOSE	sqlite3.h	463;"	d
SQLITE_OPEN_EXCLUSIVE	sqlite3.h	464;"	d
SQLITE_OPEN_MAIN_DB	sqlite3.h	465;"	d
SQLITE_OPEN_MAIN_JOURNAL	sqlite3.h	468;"	d
SQLITE_OPEN_MASTER_JOURNAL	sqlite3.h	471;"	d
SQLITE_OPEN_READONLY	sqlite3.h	460;"	d
SQLITE_OPEN_READWRITE	sqlite3.h	461;"	d
SQLITE_OPEN_SUBJOURNAL	sqlite3.h	470;"	d
SQLITE_OPEN_TEMP_DB	sqlite3.h	466;"	d
SQLITE_OPEN_TEMP_JOURNAL	sqlite3.h	469;"	d
SQLITE_OPEN_TRANSIENT_DB	sqlite3.h	467;"	d
SQLITE_OS2_THREADS	src/os_os2.c	50;"	d	file:
SQLITE_PERM	sqlite3.h	375;"	d
SQLITE_PRAGMA	sqlite3.h	1781;"	d
SQLITE_PRINT_BUF_SIZE	src/printf.c	191;"	d	file:
SQLITE_PROTOCOL	sqlite3.h	387;"	d
SQLITE_RANGE	sqlite3.h	397;"	d
SQLITE_READ	sqlite3.h	1782;"	d
SQLITE_READONLY	sqlite3.h	380;"	d
SQLITE_REINDEX	sqlite3.h	1789;"	d
SQLITE_ROW	sqlite3.h	399;"	d
SQLITE_ReadUncommitted	src/sqliteInt.h	577;"	d
SQLITE_RecoveryMode	src/sqliteInt.h	582;"	d
SQLITE_SCHEMA	sqlite3.h	389;"	d
SQLITE_SELECT	sqlite3.h	1783;"	d
SQLITE_SKIP_UTF8	src/sqliteInt.h	1649;"	d
SQLITE_SO_ASC	src/sqliteInt.h	693;"	d
SQLITE_SO_DESC	src/sqliteInt.h	694;"	d
SQLITE_STATIC	sqlite3.h	3517;"	d
SQLITE_STOREP2	src/sqliteInt.h	730;"	d
SQLITE_SYNC_DATAONLY	sqlite3.h	533;"	d
SQLITE_SYNC_FULL	sqlite3.h	532;"	d
SQLITE_SYNC_NORMAL	sqlite3.h	531;"	d
SQLITE_SharedCache	src/sqliteInt.h	583;"	d
SQLITE_ShortColNames	src/sqliteInt.h	565;"	d
SQLITE_SqlTrace	src/sqliteInt.h	571;"	d
SQLITE_TEMPNAME_SIZE	src/os.h	74;"	d
SQLITE_TEMPNAME_SIZE	src/os.h	87;"	d
SQLITE_TEMPNAME_SIZE	src/os.h	89;"	d
SQLITE_TEMP_FILE_PREFIX	src/os.h	128;"	d
SQLITE_TESTCTRL_FAULT_BENIGN_FAILURES	sqlite3.h	4783;"	d
SQLITE_TESTCTRL_FAULT_CONFIG	sqlite3.h	4781;"	d
SQLITE_TESTCTRL_FAULT_FAILURES	sqlite3.h	4782;"	d
SQLITE_TESTCTRL_FAULT_PENDING	sqlite3.h	4784;"	d
SQLITE_TEXT	sqlite3.h	2963;"	d
SQLITE_TEXT	sqlite3.h	2965;"	d
SQLITE_THREADSAFE	src/sqliteInt.h	114;"	d
SQLITE_THREADSAFE	src/sqliteInt.h	116;"	d
SQLITE_THREAD_OVERRIDE_LOCK	src/os_unix.c	394;"	d	file:
SQLITE_TOOBIG	sqlite3.h	390;"	d
SQLITE_TRANSACTION	sqlite3.h	1784;"	d
SQLITE_TRANSIENT	sqlite3.h	3518;"	d
SQLITE_UNIX_THREADS	src/os_unix.c	63;"	d	file:
SQLITE_UPDATE	sqlite3.h	1785;"	d
SQLITE_UTF16	sqlite3.h	3339;"	d
SQLITE_UTF16BE	sqlite3.h	3338;"	d
SQLITE_UTF16LE	sqlite3.h	3337;"	d
SQLITE_UTF16NATIVE	src/sqliteInt.h	288;"	d
SQLITE_UTF16NATIVE	src/sqliteInt.h	292;"	d
SQLITE_UTF16_ALIGNED	sqlite3.h	3341;"	d
SQLITE_UTF8	sqlite3.h	3336;"	d
SQLITE_VERSION	sqlite3.h	59;"	d
SQLITE_VERSION	sqlite3.h	96;"	d
SQLITE_VERSION_NUMBER	sqlite3.h	62;"	d
SQLITE_VERSION_NUMBER	sqlite3.h	97;"	d
SQLITE_VdbeListing	src/sqliteInt.h	572;"	d
SQLITE_VdbeTrace	src/sqliteInt.h	561;"	d
SQLITE_Vtab	src/sqliteInt.h	584;"	d
SQLITE_W32_THREADS	src/os_win.c	55;"	d	file:
SQLITE_WriteSchema	src/sqliteInt.h	573;"	d
SRC	Makefile	/^SRC = \\$/;"	m
SRC	main.mk	/^SRC = \\$/;"	m
SRCONFLICT	tool/lemon.c	/^    SRCONFLICT,              \/* Was a reduce, but part of a conflict *\/$/;"	e	enum:action::e_action	file:
SRT_Callback	src/sqliteInt.h	1358;"	d
SRT_Discard	src/sqliteInt.h	1353;"	d
SRT_EphemTab	src/sqliteInt.h	1362;"	d
SRT_Except	src/sqliteInt.h	1351;"	d
SRT_Exists	src/sqliteInt.h	1352;"	d
SRT_Mem	src/sqliteInt.h	1359;"	d
SRT_Set	src/sqliteInt.h	1360;"	d
SRT_Subroutine	src/sqliteInt.h	1363;"	d
SRT_Table	src/sqliteInt.h	1361;"	d
SRT_Union	src/sqliteInt.h	1350;"	d
SSCONFLICT	tool/lemon.c	/^    SSCONFLICT,              \/* A shift\/shift conflict *\/$/;"	e	enum:action::e_action	file:
STANDALONE_MIN	ext/fts2/fts2.c	4342;"	d	file:
STANDALONE_MIN	ext/fts3/fts3.c	4690;"	d	file:
STRICMP	src/build.c	918;"	d	file:
SUBQUERY	tool/mkkeywordhash.c	109;"	d	file:
SUBQUERY	tool/mkkeywordhash.c	111;"	d	file:
SWAP	src/where.c	382;"	d	file:
Schema	src/sqliteInt.h	/^struct Schema {$/;"	s
Schema	src/sqliteInt.h	/^typedef struct Schema Schema;$/;"	t	typeref:struct:Schema
Select	src/sqliteInt.h	/^struct Select {$/;"	s
Select	src/sqliteInt.h	/^typedef struct Select Select;$/;"	t	typeref:struct:Select
Select	test/fuzz_common.tcl	/^proc Select {{nMulti 0}} {$/;"	p
SelectDest	src/sqliteInt.h	/^struct SelectDest {$/;"	s
SelectDest	src/sqliteInt.h	/^typedef struct SelectDest SelectDest;$/;"	t	typeref:struct:SelectDest
SelectKw	test/fuzz_common.tcl	/^proc SelectKw {} {$/;"	p
ServerState	src/test_server.c	/^static struct ServerState {$/;"	s	file:
Set	src/vdbeInt.h	/^struct Set {$/;"	s
Set	src/vdbeInt.h	/^typedef struct Set Set;$/;"	t	typeref:struct:Set
SetAdd	tool/lemon.c	/^int SetAdd(s,e)$/;"	f
SetFind	tool/lemon.c	104;"	d	file:
SetFree	tool/lemon.c	/^void SetFree(s)$/;"	f
SetNew	tool/lemon.c	/^char *SetNew(){$/;"	f
SetSize	tool/lemon.c	/^void SetSize(n)$/;"	f
SetUnion	tool/lemon.c	/^int SetUnion(s1,s2)$/;"	f
SimpleSelect	test/fuzz_common.tcl	/^proc SimpleSelect {{nRes 0}} {$/;"	p
SimulateDiskfullError	src/os_common.h	103;"	d
SimulateDiskfullError	src/os_common.h	116;"	d
SimulateIOError	src/os_common.h	115;"	d
SimulateIOError	src/os_common.h	94;"	d
Snippet	ext/fts1/fts1.c	/^typedef struct Snippet {$/;"	s	file:
Snippet	ext/fts1/fts1.c	/^} Snippet;$/;"	t	typeref:struct:Snippet	file:
Snippet	ext/fts2/fts2.c	/^typedef struct Snippet {$/;"	s	file:
Snippet	ext/fts2/fts2.c	/^} Snippet;$/;"	t	typeref:struct:Snippet	file:
Snippet	ext/fts3/fts3.c	/^typedef struct Snippet {$/;"	s	file:
Snippet	ext/fts3/fts3.c	/^} Snippet;$/;"	t	typeref:struct:Snippet	file:
SqlCollate	src/tclsqlite.c	/^struct SqlCollate {$/;"	s	file:
SqlCollate	src/tclsqlite.c	/^typedef struct SqlCollate SqlCollate;$/;"	t	typeref:struct:SqlCollate	file:
SqlFunc	src/tclsqlite.c	/^struct SqlFunc {$/;"	s	file:
SqlFunc	src/tclsqlite.c	/^typedef struct SqlFunc SqlFunc;$/;"	t	typeref:struct:SqlFunc	file:
SqlMessage	src/test_server.c	/^struct SqlMessage {$/;"	s	file:
SqlMessage	src/test_server.c	/^typedef struct SqlMessage SqlMessage;$/;"	t	typeref:struct:SqlMessage	file:
SqlPreparedStmt	src/tclsqlite.c	/^struct SqlPreparedStmt {$/;"	s	file:
SqlPreparedStmt	src/tclsqlite.c	/^typedef struct SqlPreparedStmt SqlPreparedStmt;$/;"	t	typeref:struct:SqlPreparedStmt	file:
SqlThread	src/test_thread.c	/^struct SqlThread {$/;"	s	file:
SqlThread	src/test_thread.c	/^typedef struct SqlThread SqlThread;$/;"	t	typeref:struct:SqlThread	file:
Sqlite3_Init	src/tclsqlite.c	/^EXTERN int Sqlite3_Init(Tcl_Interp *interp){$/;"	f
Sqlite3_SafeInit	src/tclsqlite.c	/^EXTERN int Sqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
SqliteDb	src/tclsqlite.c	/^struct SqliteDb {$/;"	s	file:
SqliteDb	src/tclsqlite.c	/^typedef struct SqliteDb SqliteDb;$/;"	t	typeref:struct:SqliteDb	file:
SqliteDb	src/test1.c	/^struct SqliteDb {$/;"	s	file:
Sqlite_Init	src/tclsqlite.c	/^EXTERN int Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Sqlite_SafeInit	src/tclsqlite.c	/^EXTERN int Sqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqliteconfig_Init	src/test_config.c	/^int Sqliteconfig_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest1_Init	src/test1.c	/^int Sqlitetest1_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest2_Init	src/test2.c	/^int Sqlitetest2_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest3_Init	src/test3.c	/^int Sqlitetest3_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest4_Init	src/test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest4_Init	src/test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest5_Init	src/test5.c	/^int Sqlitetest5_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest6_Init	src/test6.c	/^int Sqlitetest6_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest7_Init	src/test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest7_Init	src/test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest8_Init	src/test8.c	/^int Sqlitetest8_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest9_Init	src/test9.c	/^int Sqlitetest9_Init(Tcl_Interp *interp){$/;"	f
SqlitetestOnefile_Init	src/test_onefile.c	/^  int SqlitetestOnefile_Init() {return fs_register();}$/;"	f
SqlitetestThread_Init	src/test_thread.c	/^int SqlitetestThread_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_autoext_Init	src/test_autoext.c	/^int Sqlitetest_autoext_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_hexio_Init	src/test_hexio.c	/^int Sqlitetest_hexio_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_malloc_Init	src/test_malloc.c	/^int Sqlitetest_malloc_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestasync_Init	src/test_async.c	/^int Sqlitetestasync_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestschema_Init	src/test_schema.c	/^int Sqlitetestschema_Init(Tcl_Interp *interp){$/;"	f
Sqlitetesttclvar_Init	src/test_tclvar.c	/^int Sqlitetesttclvar_Init(Tcl_Interp *interp){$/;"	f
SrcList	src/sqliteInt.h	/^struct SrcList {$/;"	s
SrcList	src/sqliteInt.h	/^typedef struct SrcList SrcList;$/;"	t	typeref:struct:SrcList
SrcList_item	src/sqliteInt.h	/^  struct SrcList_item {$/;"	s	struct:SrcList
State_arrayof	tool/lemon.c	/^struct state **State_arrayof()$/;"	f
State_find	tool/lemon.c	/^struct state *State_find(key)$/;"	f
State_init	tool/lemon.c	/^void State_init(){$/;"	f
State_insert	tool/lemon.c	/^int State_insert(data,key)$/;"	f
State_new	tool/lemon.c	/^struct state *State_new()$/;"	f
Statement	test/fuzz_common.tcl	/^proc Statement {} {$/;"	p
StmtToDb	src/test1.c	158;"	d	file:
StrAccum	src/sqliteInt.h	/^struct StrAccum {$/;"	s
StrAccum	src/sqliteInt.h	/^typedef struct StrAccum StrAccum;$/;"	t	typeref:struct:StrAccum
StringBuffer	ext/fts1/fts1.c	/^typedef struct StringBuffer {$/;"	s	file:
StringBuffer	ext/fts1/fts1.c	/^} StringBuffer;$/;"	t	typeref:struct:StringBuffer	file:
StringBuffer	ext/fts2/fts2.c	/^typedef struct StringBuffer {$/;"	s	file:
StringBuffer	ext/fts2/fts2.c	/^} StringBuffer;$/;"	t	typeref:struct:StringBuffer	file:
StringBuffer	ext/fts3/fts3.c	/^typedef struct StringBuffer {$/;"	s	file:
StringBuffer	ext/fts3/fts3.c	/^} StringBuffer;$/;"	t	typeref:struct:StringBuffer	file:
Stringify	src/vdbe.c	122;"	d	file:
Strsafe	tool/lemon.c	/^char *Strsafe(y)$/;"	f
Strsafe_find	tool/lemon.c	/^char *Strsafe_find(key)$/;"	f
Strsafe_init	tool/lemon.c	/^void Strsafe_init(){$/;"	f
Strsafe_insert	tool/lemon.c	/^int Strsafe_insert(data)$/;"	f
SumCtx	src/func.c	/^struct SumCtx {$/;"	s	file:
SumCtx	src/func.c	/^typedef struct SumCtx SumCtx;$/;"	t	typeref:struct:SumCtx	file:
Symbol_Nth	tool/lemon.c	/^struct symbol *Symbol_Nth(n)$/;"	f
Symbol_arrayof	tool/lemon.c	/^struct symbol **Symbol_arrayof()$/;"	f
Symbol_count	tool/lemon.c	/^int Symbol_count()$/;"	f
Symbol_find	tool/lemon.c	/^struct symbol *Symbol_find(key)$/;"	f
Symbol_init	tool/lemon.c	/^void Symbol_init(){$/;"	f
Symbol_insert	tool/lemon.c	/^int Symbol_insert(data,key)$/;"	f
Symbol_new	tool/lemon.c	/^struct symbol *Symbol_new(x)$/;"	f
Symbolcmpp	tool/lemon.c	/^int Symbolcmpp(struct symbol **a, struct symbol **b){$/;"	f
TCC	Makefile	/^TCC = arm-linux-gcc -g -O2 -I. -I${TOP}\/src$/;"	m
TCCX	main.mk	/^TCCX = $(TCC) $(OPTS) -I. -I$(TOP)\/src$/;"	m
TCLSH_MAIN	src/tclsqlite.c	/^int TCLSH_MAIN(int argc, char **argv){$/;"	f
TCLSH_MAIN	src/tclsqlite.c	2514;"	d	file:
TCL_STORAGE_CLASS	src/tclsqlite.c	37;"	d	file:
TCL_STORAGE_CLASS	src/tclsqlite.c	38;"	d	file:
TEMP_MASTER_NAME	src/sqliteInt.h	317;"	d
TEMP_STORE	Makefile	/^TEMP_STORE = -DTEMP_STORE=1$/;"	m
TEMP_STORE	src/sqliteInt.h	222;"	d
TERMINAL	tool/lemon.c	/^    TERMINAL,$/;"	e	enum:symbol::__anon7	file:
TERM_CODED	src/where.c	95;"	d	file:
TERM_COPIED	src/where.c	96;"	d	file:
TERM_DELETE_STMT	ext/fts1/fts1.c	/^  TERM_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_DYNAMIC	src/where.c	93;"	d	file:
TERM_INSERT_STMT	ext/fts1/fts1.c	/^  TERM_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_OR_OK	src/where.c	97;"	d	file:
TERM_SELECT_ALL_STMT	ext/fts1/fts1.c	/^  TERM_SELECT_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_SELECT_STMT	ext/fts1/fts1.c	/^  TERM_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_UPDATE_STMT	ext/fts1/fts1.c	/^  TERM_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_VIRTUAL	src/where.c	94;"	d	file:
TESTFIXTURE_FLAGS	main.mk	/^TESTFIXTURE_FLAGS  = -DTCLSH=1 -DSQLITE_TEST=1 -DSQLITE_CRASH_TEST=1$/;"	m
TESTSRC	Makefile	/^TESTSRC = \\$/;"	m
TESTSRC	main.mk	/^TESTSRC = \\$/;"	m
TESTSRC2	main.mk	/^TESTSRC2 = \\$/;"	m
TEST_EXTENSION	main.mk	/^TEST_EXTENSION = $(SHPREFIX)testloadext.$(SO)$/;"	m
TEXE	Makefile	/^TEXE = $/;"	m
TIMER_ELAPSED	src/os_common.h	76;"	d
TIMER_ELAPSED	src/os_common.h	80;"	d
TIMER_END	src/os_common.h	75;"	d
TIMER_END	src/os_common.h	79;"	d
TIMER_START	src/os_common.h	74;"	d
TIMER_START	src/os_common.h	78;"	d
TK_ABORT	parse.h	24;"	d
TK_ADD	parse.h	136;"	d
TK_AFTER	parse.h	25;"	d
TK_AGG_COLUMN	parse.h	151;"	d
TK_AGG_FUNCTION	parse.h	150;"	d
TK_ALL	parse.h	107;"	d
TK_ALTER	parse.h	134;"	d
TK_ANALYZE	parse.h	26;"	d
TK_AND	parse.h	61;"	d
TK_ANY	parse.h	59;"	d
TK_AS	parse.h	21;"	d
TK_ASC	parse.h	27;"	d
TK_ATTACH	parse.h	28;"	d
TK_AUTOINCR	parse.h	97;"	d
TK_BEFORE	parse.h	29;"	d
TK_BEGIN	parse.h	5;"	d
TK_BETWEEN	parse.h	63;"	d
TK_BITAND	parse.h	74;"	d
TK_BITNOT	parse.h	87;"	d
TK_BITOR	parse.h	75;"	d
TK_BLOB	parse.h	126;"	d
TK_BY	parse.h	117;"	d
TK_CASCADE	parse.h	30;"	d
TK_CASE	parse.h	129;"	d
TK_CAST	parse.h	31;"	d
TK_CHECK	parse.h	95;"	d
TK_COLLATE	parse.h	84;"	d
TK_COLUMN	parse.h	149;"	d
TK_COLUMNKW	parse.h	137;"	d
TK_COMMA	parse.h	22;"	d
TK_COMMENT	parse.h	147;"	d
TK_COMMIT	parse.h	10;"	d
TK_CONCAT	parse.h	83;"	d
TK_CONFLICT	parse.h	32;"	d
TK_CONSTRAINT	parse.h	90;"	d
TK_CONST_FUNC	parse.h	152;"	d
TK_CREATE	parse.h	13;"	d
TK_CTIME_KW	parse.h	58;"	d
TK_DATABASE	parse.h	33;"	d
TK_DEFAULT	parse.h	91;"	d
TK_DEFERRABLE	parse.h	103;"	d
TK_DEFERRED	parse.h	7;"	d
TK_DELETE	parse.h	99;"	d
TK_DESC	parse.h	34;"	d
TK_DETACH	parse.h	35;"	d
TK_DISTINCT	parse.h	111;"	d
TK_DOT	parse.h	112;"	d
TK_DROP	parse.h	105;"	d
TK_EACH	parse.h	36;"	d
TK_ELSE	parse.h	132;"	d
TK_END	parse.h	11;"	d
TK_END_OF_FILE	parse.h	143;"	d
TK_EQ	parse.h	68;"	d
TK_ESCAPE	parse.h	73;"	d
TK_EXCEPT	parse.h	108;"	d
TK_EXCLUSIVE	parse.h	9;"	d
TK_EXISTS	parse.h	17;"	d
TK_EXPLAIN	parse.h	2;"	d
TK_FAIL	parse.h	37;"	d
TK_FLOAT	parse.h	125;"	d
TK_FOR	parse.h	38;"	d
TK_FOREIGN	parse.h	104;"	d
TK_FROM	parse.h	113;"	d
TK_FUNCTION	parse.h	148;"	d
TK_GE	parse.h	72;"	d
TK_GROUP	parse.h	118;"	d
TK_GT	parse.h	69;"	d
TK_HAVING	parse.h	119;"	d
TK_ID	parse.h	23;"	d
TK_IF	parse.h	15;"	d
TK_IGNORE	parse.h	39;"	d
TK_ILLEGAL	parse.h	144;"	d
TK_IMMEDIATE	parse.h	8;"	d
TK_IN	parse.h	64;"	d
TK_INDEX	parse.h	133;"	d
TK_INITIALLY	parse.h	40;"	d
TK_INSERT	parse.h	101;"	d
TK_INSTEAD	parse.h	41;"	d
TK_INTEGER	parse.h	124;"	d
TK_INTERSECT	parse.h	109;"	d
TK_INTO	parse.h	122;"	d
TK_IS	parse.h	62;"	d
TK_ISNULL	parse.h	65;"	d
TK_JOIN	parse.h	114;"	d
TK_JOIN_KW	parse.h	89;"	d
TK_KEY	parse.h	44;"	d
TK_LE	parse.h	70;"	d
TK_LIKE_KW	parse.h	42;"	d
TK_LIMIT	parse.h	120;"	d
TK_LP	parse.h	19;"	d
TK_LSHIFT	parse.h	76;"	d
TK_LT	parse.h	71;"	d
TK_MATCH	parse.h	43;"	d
TK_MINUS	parse.h	79;"	d
TK_NE	parse.h	67;"	d
TK_NOT	parse.h	16;"	d
TK_NOTNULL	parse.h	66;"	d
TK_NULL	parse.h	92;"	d
TK_OF	parse.h	45;"	d
TK_OFFSET	parse.h	46;"	d
TK_ON	parse.h	98;"	d
TK_OR	parse.h	60;"	d
TK_ORDER	parse.h	116;"	d
TK_PLAN	parse.h	4;"	d
TK_PLUS	parse.h	78;"	d
TK_PRAGMA	parse.h	47;"	d
TK_PRIMARY	parse.h	93;"	d
TK_QUERY	parse.h	3;"	d
TK_RAISE	parse.h	48;"	d
TK_REFERENCES	parse.h	96;"	d
TK_REGISTER	parse.h	127;"	d
TK_REINDEX	parse.h	56;"	d
TK_REM	parse.h	82;"	d
TK_RENAME	parse.h	57;"	d
TK_REPLACE	parse.h	49;"	d
TK_RESTRICT	parse.h	50;"	d
TK_ROLLBACK	parse.h	12;"	d
TK_ROW	parse.h	51;"	d
TK_RP	parse.h	20;"	d
TK_RSHIFT	parse.h	77;"	d
TK_SELECT	parse.h	110;"	d
TK_SEMI	parse.h	1;"	d
TK_SET	parse.h	102;"	d
TK_SLASH	parse.h	81;"	d
TK_SPACE	parse.h	145;"	d
TK_STAR	parse.h	80;"	d
TK_STRING	parse.h	88;"	d
TK_TABLE	parse.h	14;"	d
TK_TEMP	parse.h	18;"	d
TK_THEN	parse.h	131;"	d
TK_TO	parse.h	135;"	d
TK_TO_BLOB	parse.h	139;"	d
TK_TO_INT	parse.h	141;"	d
TK_TO_NUMERIC	parse.h	140;"	d
TK_TO_REAL	parse.h	142;"	d
TK_TO_TEXT	parse.h	138;"	d
TK_TRANSACTION	parse.h	6;"	d
TK_TRIGGER	parse.h	52;"	d
TK_UMINUS	parse.h	85;"	d
TK_UNCLOSED_STRING	parse.h	146;"	d
TK_UNION	parse.h	106;"	d
TK_UNIQUE	parse.h	94;"	d
TK_UPDATE	parse.h	100;"	d
TK_UPLUS	parse.h	86;"	d
TK_USING	parse.h	115;"	d
TK_VACUUM	parse.h	53;"	d
TK_VALUES	parse.h	123;"	d
TK_VARIABLE	parse.h	128;"	d
TK_VIEW	parse.h	54;"	d
TK_VIRTUAL	parse.h	55;"	d
TK_WHEN	parse.h	130;"	d
TK_WHERE	parse.h	121;"	d
TLIBS	Makefile	/^TLIBS = $/;"	m
TOKEN	lempar.c	590;"	d	file:
TOKEN	parse.c	3297;"	d	file:
TOKEN	tool/lempar.c	590;"	d	file:
TOKEN_EOF	ext/fts1/fts1.c	1531;"	d	file:
TOKEN_EOF	ext/fts2/fts2.c	2308;"	d	file:
TOKEN_EOF	ext/fts3/fts3.c	2464;"	d	file:
TOKEN_ID	ext/fts1/fts1.c	1533;"	d	file:
TOKEN_ID	ext/fts2/fts2.c	2310;"	d	file:
TOKEN_ID	ext/fts3/fts3.c	2466;"	d	file:
TOKEN_PUNCT	ext/fts1/fts1.c	1535;"	d	file:
TOKEN_PUNCT	ext/fts2/fts2.c	2312;"	d	file:
TOKEN_PUNCT	ext/fts3/fts3.c	2468;"	d	file:
TOKEN_SPACE	ext/fts1/fts1.c	1532;"	d	file:
TOKEN_SPACE	ext/fts2/fts2.c	2309;"	d	file:
TOKEN_SPACE	ext/fts3/fts3.c	2465;"	d	file:
TOKEN_STRING	ext/fts1/fts1.c	1534;"	d	file:
TOKEN_STRING	ext/fts2/fts2.c	2311;"	d	file:
TOKEN_STRING	ext/fts3/fts3.c	2467;"	d	file:
TOP	Makefile	/^TOP = .$/;"	m
TRACE	ext/fts1/fts1.c	60;"	d	file:
TRACE	ext/fts2/fts2.c	335;"	d	file:
TRACE	src/btreeInt.h	490;"	d
TRACE	src/btreeInt.h	492;"	d
TRACE_IDX_INPUTS	src/where.c	/^static void TRACE_IDX_INPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_INPUTS	src/where.c	1194;"	d	file:
TRACE_IDX_OUTPUTS	src/where.c	/^static void TRACE_IDX_OUTPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_OUTPUTS	src/where.c	1195;"	d	file:
TRANS_NONE	src/btreeInt.h	345;"	d
TRANS_READ	src/btreeInt.h	346;"	d
TRANS_WRITE	src/btreeInt.h	347;"	d
TRIGGER	tool/mkkeywordhash.c	114;"	d	file:
TRIGGER	tool/mkkeywordhash.c	116;"	d	file:
TRIGGER_AFTER	src/sqliteInt.h	1512;"	d
TRIGGER_BEFORE	src/sqliteInt.h	1511;"	d
TabResult	src/table.c	/^typedef struct TabResult {$/;"	s	file:
TabResult	src/table.c	/^} TabResult;$/;"	t	typeref:struct:TabResult	file:
Table	src/sqliteInt.h	/^struct Table {$/;"	s
Table	src/sqliteInt.h	/^typedef struct Table Table;$/;"	t	typeref:struct:Table
Table	test/fuzz_common.tcl	/^proc Table {} {$/;"	p
TableLock	src/build.c	/^struct TableLock {$/;"	s	file:
TableLock	src/sqliteInt.h	/^typedef struct TableLock TableLock;$/;"	t	typeref:struct:TableLock
TableSpec	ext/fts1/fts1.c	/^typedef struct TableSpec {$/;"	s	file:
TableSpec	ext/fts1/fts1.c	/^} TableSpec;$/;"	t	typeref:struct:TableSpec	file:
TableSpec	ext/fts2/fts2.c	/^typedef struct TableSpec {$/;"	s	file:
TableSpec	ext/fts2/fts2.c	/^} TableSpec;$/;"	t	typeref:struct:TableSpec	file:
TableSpec	ext/fts3/fts3.c	/^typedef struct TableSpec {$/;"	s	file:
TableSpec	ext/fts3/fts3.c	/^} TableSpec;$/;"	t	typeref:struct:TableSpec	file:
Tcl_InitStubs	src/tclsqlite.c	2426;"	d	file:
Tcl_InitStubs	src/tclsqlite.c	2427;"	d	file:
Tclsqlite3_Init	src/tclsqlite.c	/^EXTERN int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite3_SafeInit	src/tclsqlite.c	/^EXTERN int Tclsqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Tclsqlite_Init	src/tclsqlite.c	/^EXTERN int Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite_SafeInit	src/tclsqlite.c	/^EXTERN int Tclsqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
TermData	ext/fts2/fts2.c	/^typedef struct TermData {$/;"	s	file:
TermData	ext/fts2/fts2.c	/^} TermData;$/;"	t	typeref:struct:TermData	file:
TermData	ext/fts3/fts3.c	/^typedef struct TermData {$/;"	s	file:
TermData	ext/fts3/fts3.c	/^} TermData;$/;"	t	typeref:struct:TermData	file:
TestAsyncDebugData	src/test_async.c	/^static struct TestAsyncDebugData {$/;"	s	file:
TestAsyncStaticData	src/test_async.c	/^static struct TestAsyncStaticData {$/;"	s	file:
TestCollationX	src/test1.c	/^struct TestCollationX {$/;"	s	file:
TestCollationX	src/test1.c	/^typedef struct TestCollationX TestCollationX;$/;"	t	typeref:struct:TestCollationX	file:
Thread	src/test4.c	/^struct Thread {$/;"	s	file:
Thread	src/test4.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Thread	src/test7.c	/^struct Thread {$/;"	s	file:
Thread	src/test7.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Token	ext/fts1/fts1.c	/^typedef struct Token {$/;"	s	file:
Token	ext/fts1/fts1.c	/^} Token;$/;"	t	typeref:struct:Token	file:
Token	ext/fts2/fts2.c	/^typedef struct Token {$/;"	s	file:
Token	ext/fts2/fts2.c	/^} Token;$/;"	t	typeref:struct:Token	file:
Token	src/sqliteInt.h	/^struct Token {$/;"	s
Token	src/sqliteInt.h	/^typedef struct Token Token;$/;"	t	typeref:struct:Token
TrigEvent	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	s	file:
Trigger	src/sqliteInt.h	/^struct Trigger {$/;"	s
Trigger	src/sqliteInt.h	/^typedef struct Trigger Trigger;$/;"	t	typeref:struct:Trigger
TriggerStack	src/sqliteInt.h	/^struct TriggerStack {$/;"	s
TriggerStack	src/sqliteInt.h	/^typedef struct TriggerStack TriggerStack;$/;"	t	typeref:struct:TriggerStack
TriggerStep	src/sqliteInt.h	/^struct TriggerStep {$/;"	s
TriggerStep	src/sqliteInt.h	/^typedef struct TriggerStep TriggerStep;$/;"	t	typeref:struct:TriggerStep
UINT16_TYPE	src/sqliteInt.h	254;"	d
UINT32_TYPE	src/sqliteInt.h	251;"	d
UINT8_TYPE	src/sqliteInt.h	260;"	d
UNK	tool/lemon.c	/^    UNK$/;"	e	enum:symbol::e_assoc	file:
UPDATE_MAX_BLOBSIZE	src/vdbe.c	107;"	d	file:
UPDATE_MAX_BLOBSIZE	src/vdbe.c	109;"	d	file:
UTF_TRANSLATION_NEEDED	src/tclsqlite.c	51;"	d	file:
UnaryOp	test/fuzz_common.tcl	/^proc UnaryOp {} {$/;"	p
UnlockFile	src/os_win.c	314;"	d	file:
Update	test/fuzz_common.tcl	/^proc Update {} {$/;"	p
UpperToLower	src/util.c	176;"	d	file:
UpperToLower	tool/mkkeywordhash.c	285;"	d	file:
VACUUM	tool/mkkeywordhash.c	120;"	d	file:
VACUUM	tool/mkkeywordhash.c	122;"	d	file:
VARINT_MAX	ext/fts1/fts1.c	109;"	d	file:
VARINT_MAX	ext/fts2/fts2.c	406;"	d	file:
VARINT_MAX	ext/fts3/fts3.c	388;"	d	file:
VDBEHDR	Makefile	/^VDBEHDR = \\$/;"	m
VDBE_MAGIC_DEAD	src/vdbeInt.h	350;"	d
VDBE_MAGIC_HALT	src/vdbeInt.h	349;"	d
VDBE_MAGIC_INIT	src/vdbeInt.h	347;"	d
VDBE_MAGIC_RUN	src/vdbeInt.h	348;"	d
VERSION	Makefile	/^VERSION = 3.5$/;"	m
VERSION_NUMBER	Makefile	/^VERSION_NUMBER = 3005005$/;"	m
VIEW	tool/mkkeywordhash.c	125;"	d	file:
VIEW	tool/mkkeywordhash.c	127;"	d	file:
VTAB	tool/mkkeywordhash.c	130;"	d	file:
VTAB	tool/mkkeywordhash.c	132;"	d	file:
Vdbe	src/vdbe.h	/^typedef struct Vdbe Vdbe;$/;"	t	typeref:struct:Vdbe
Vdbe	src/vdbeInt.h	/^struct Vdbe {$/;"	s
VdbeComment	src/vdbe.h	178;"	d
VdbeComment	src/vdbe.h	180;"	d
VdbeFunc	src/vdbe.h	/^typedef struct VdbeFunc VdbeFunc;$/;"	t	typeref:struct:VdbeFunc
VdbeFunc	src/vdbeInt.h	/^struct VdbeFunc {$/;"	s
VdbeOp	src/vdbe.h	/^struct VdbeOp {$/;"	s
VdbeOp	src/vdbe.h	/^typedef struct VdbeOp VdbeOp;$/;"	t	typeref:struct:VdbeOp
VdbeOpList	src/vdbe.h	/^struct VdbeOpList {$/;"	s
VdbeOpList	src/vdbe.h	/^typedef struct VdbeOpList VdbeOpList;$/;"	t	typeref:struct:VdbeOpList
WAITING_FOR_ARROW	tool/lemon.c	/^    WAITING_FOR_ARROW,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DATATYPE_SYMBOL	tool/lemon.c	/^    WAITING_FOR_DATATYPE_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_ARG	tool/lemon.c	/^    WAITING_FOR_DECL_ARG,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_KEYWORD	tool/lemon.c	/^    WAITING_FOR_DECL_KEYWORD,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_OR_RULE	tool/lemon.c	/^    WAITING_FOR_DECL_OR_RULE,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DESTRUCTOR_SYMBOL	tool/lemon.c	/^    WAITING_FOR_DESTRUCTOR_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_FALLBACK_ID	tool/lemon.c	/^    WAITING_FOR_FALLBACK_ID,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_PRECEDENCE_SYMBOL	tool/lemon.c	/^    WAITING_FOR_PRECEDENCE_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_WILDCARD_ID	tool/lemon.c	/^    WAITING_FOR_WILDCARD_ID$/;"	e	enum:pstate::e_state	file:
WHERETRACE	src/where.c	33;"	d	file:
WHERETRACE	src/where.c	35;"	d	file:
WHERE_BTM_LIMIT	src/where.c	175;"	d	file:
WHERE_COLUMN_EQ	src/where.c	171;"	d	file:
WHERE_COLUMN_IN	src/where.c	173;"	d	file:
WHERE_COLUMN_RANGE	src/where.c	172;"	d	file:
WHERE_IDX_ONLY	src/where.c	176;"	d	file:
WHERE_ORDERBY	src/where.c	177;"	d	file:
WHERE_REVERSE	src/where.c	178;"	d	file:
WHERE_ROWID_EQ	src/where.c	169;"	d	file:
WHERE_ROWID_RANGE	src/where.c	170;"	d	file:
WHERE_TOP_LIMIT	src/where.c	174;"	d	file:
WHERE_UNIQUE	src/where.c	179;"	d	file:
WHERE_VIRTUALTABLE	src/where.c	180;"	d	file:
WO_EQ	src/where.c	150;"	d	file:
WO_GE	src/where.c	154;"	d	file:
WO_GT	src/where.c	153;"	d	file:
WO_IN	src/where.c	149;"	d	file:
WO_ISNULL	src/where.c	156;"	d	file:
WO_LE	src/where.c	152;"	d	file:
WO_LT	src/where.c	151;"	d	file:
WO_MATCH	src/where.c	155;"	d	file:
WRITE_LOCK	src/btreeInt.h	533;"	d
WRITE_UTF16BE	src/utf.c	96;"	d	file:
WRITE_UTF16LE	src/utf.c	84;"	d	file:
WRITE_UTF8	src/utf.c	64;"	d	file:
WhereClause	src/where.c	/^struct WhereClause {$/;"	s	file:
WhereClause	src/where.c	/^typedef struct WhereClause WhereClause;$/;"	t	typeref:struct:WhereClause	file:
WhereInfo	src/sqliteInt.h	/^struct WhereInfo {$/;"	s
WhereInfo	src/sqliteInt.h	/^typedef struct WhereInfo WhereInfo;$/;"	t	typeref:struct:WhereInfo
WhereLevel	src/sqliteInt.h	/^struct WhereLevel {$/;"	s
WhereLevel	src/sqliteInt.h	/^typedef struct WhereLevel WhereLevel;$/;"	t	typeref:struct:WhereLevel
WhereTerm	src/where.c	/^struct WhereTerm {$/;"	s	file:
WhereTerm	src/where.c	/^typedef struct WhereTerm WhereTerm;$/;"	t	typeref:struct:WhereTerm	file:
WriteBuffer	src/test6.c	/^struct WriteBuffer {$/;"	s	file:
WriteBuffer	src/test6.c	/^typedef struct WriteBuffer WriteBuffer;$/;"	t	typeref:struct:WriteBuffer	file:
Y	src/date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
YYACTIONTYPE	parse.c	97;"	d	file:
YYCODETYPE	parse.c	95;"	d	file:
YYFALLBACK	parse.c	124;"	d	file:
YYMINORTYPE	parse.c	/^} YYMINORTYPE;$/;"	t	typeref:union:__anon25	file:
YYNOCODE	parse.c	96;"	d	file:
YYNRULE	parse.c	123;"	d	file:
YYNSTATE	parse.c	122;"	d	file:
YYSTACKDEPTH	parse.c	116;"	d	file:
YYWILDCARD	parse.c	98;"	d	file:
YY_ACCEPT_ACTION	lempar.c	60;"	d	file:
YY_ACCEPT_ACTION	parse.c	126;"	d	file:
YY_ACCEPT_ACTION	tool/lempar.c	60;"	d	file:
YY_ERROR_ACTION	lempar.c	61;"	d	file:
YY_ERROR_ACTION	parse.c	127;"	d	file:
YY_ERROR_ACTION	tool/lempar.c	61;"	d	file:
YY_NO_ACTION	lempar.c	59;"	d	file:
YY_NO_ACTION	parse.c	125;"	d	file:
YY_NO_ACTION	tool/lempar.c	59;"	d	file:
YY_REDUCE_MAX	parse.c	494;"	d	file:
YY_REDUCE_USE_DFLT	parse.c	493;"	d	file:
YY_SHIFT_MAX	parse.c	451;"	d	file:
YY_SHIFT_USE_DFLT	parse.c	450;"	d	file:
YY_SZ_ACTTAB	lempar.c	111;"	d	file:
YY_SZ_ACTTAB	parse.c	588;"	d	file:
YY_SZ_ACTTAB	tool/lempar.c	111;"	d	file:
_AFPFSSetLock	src/os_unix.c	/^static int _AFPFSSetLock($/;"	f	file:
_BTREE_H_	src/btree.h	19;"	d
_FILE_OFFSET_BITS	src/os_unix.c	36;"	d	file:
_FILE_OFFSET_BITS	src/sqliteInt.h	56;"	d
_FTS1_HASH_H_	ext/fts1/fts1_hash.h	18;"	d
_FTS1_TOKENIZER_H_	ext/fts1/fts1_tokenizer.h	21;"	d
_FTS2_HASH_H_	ext/fts2/fts2_hash.h	18;"	d
_FTS2_TOKENIZER_H_	ext/fts2/fts2_tokenizer.h	21;"	d
_FTS3_HASH_H_	ext/fts3/fts3_hash.h	18;"	d
_FTS3_TOKENIZER_H_	ext/fts3/fts3_tokenizer.h	21;"	d
_LARGEFILE_SOURCE	src/os_unix.c	38;"	d	file:
_LARGEFILE_SOURCE	src/sqliteInt.h	58;"	d
_LARGE_FILE	src/os_unix.c	34;"	d	file:
_LARGE_FILE	src/sqliteInt.h	54;"	d
_OvflCell	src/btreeInt.h	/^  struct _OvflCell {   \/* Cells that will not fit on aData[] *\/$/;"	s	struct:MemPage
_PAGER_H_	src/pager.h	20;"	d
_SQLITE3EXT_H_	src/sqlite3ext.h	21;"	d
_SQLITE3_H_	sqlite3.h	36;"	d
_SQLITEINT_H_	src/sqliteInt.h	17;"	d
_SQLITE_HASH_H_	src/hash.h	18;"	d
_SQLITE_OS_C_	src/os.c	16;"	d	file:
_SQLITE_OS_C_	src/os.c	18;"	d	file:
_SQLITE_OS_H_	src/os.h	21;"	d
_SQLITE_VDBE_H_	src/vdbe.h	21;"	d
_VDBEINT_H_	src/vdbeInt.h	19;"	d
_XOPEN_SOURCE	src/sqliteInt.h	134;"	d
__WIN32__	tool/lemon.c	18;"	d	file:
_all_whitespace	src/shell.c	/^static int _all_whitespace(const char *z){$/;"	f	file:
_contains_semicolon	src/shell.c	/^static int _contains_semicolon(const char *z, int N){$/;"	f	file:
_fts1ht	ext/fts1/fts1_hash.h	/^  struct _fts1ht {        \/* the hash table *\/$/;"	s	struct:fts1Hash
_fts2ht	ext/fts2/fts2_hash.h	/^  struct _fts2ht {        \/* the hash table *\/$/;"	s	struct:fts2Hash
_fts3ht	ext/fts3/fts3_hash.h	/^  struct _fts3ht {        \/* the hash table *\/$/;"	s	struct:fts3Hash
_ht	src/hash.h	/^  struct _ht {            \/* the hash table *\/$/;"	s	struct:Hash
_is_command_terminator	src/shell.c	/^static int _is_command_terminator(const char *zLine){$/;"	f	file:
_page_ref	src/pager.c	/^static void _page_ref(PgHdr *pPg){$/;"	f	file:
_storeTypeInfo	src/vdbe.c	/^static void _storeTypeInfo(Mem *pMem){$/;"	f	file:
a	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	m	struct:TrigEvent	file:
a	src/sqliteInt.h	/^  WhereLevel a[1];     \/* Information about each nest loop in the WHERE *\/$/;"	m	struct:WhereInfo
a	src/sqliteInt.h	/^  } *a;                  \/* One entry for each expression *\/$/;"	m	struct:ExprList	typeref:struct:ExprList::ExprList_item
a	src/sqliteInt.h	/^  } *a;$/;"	m	struct:IdList	typeref:struct:IdList::IdList_item
a	src/sqliteInt.h	/^  } a[1];             \/* One entry for each identifier on the list *\/$/;"	m	struct:SrcList	typeref:struct:SrcList::SrcList_item
a	src/where.c	/^  WhereTerm *a;            \/* Each a[] describes a term of the WHERE cluase *\/$/;"	m	struct:WhereClause	file:
aAction	tool/lemon.c	/^  } *aAction,                  \/* The yy_action[] table under construction *\/$/;"	m	struct:acttab	typeref:struct:acttab::__anon10	file:
aBtree	src/btree.h	/^  Btree *aBtree[SQLITE_MAX_ATTACHED+1];$/;"	m	struct:BtreeMutexArray
aChar	ext/fts2/fts2_icu.c	/^  UChar *aChar;               \/* Copy of input using utf-16 encoding *\/$/;"	m	struct:IcuCursor	file:
aChar	ext/fts3/fts3_icu.c	/^  UChar *aChar;               \/* Copy of input using utf-16 encoding *\/$/;"	m	struct:IcuCursor	file:
aCol	src/sqliteInt.h	/^  Column *aCol;    \/* Information about each column *\/$/;"	m	struct:Table
aCol	src/sqliteInt.h	/^  } *aCol;          \/* One entry for each of nCol column s *\/$/;"	m	struct:FKey	typeref:struct:FKey::sColMap
aCol	src/sqliteInt.h	/^  } *aCol;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_col
aCol	src/test8.c	/^  char **aCol;            \/* Array of size nCol. Column names *\/$/;"	m	struct:echo_vtab	file:
aColName	src/vdbeInt.h	/^  Mem *aColName;      \/* Column names to return *\/$/;"	m	struct:Vdbe
aColl	src/sqliteInt.h	/^  CollSeq *aColl[1];  \/* Collating sequence for each term of the key *\/$/;"	m	struct:KeyInfo
aCollSeq	src/sqliteInt.h	/^  Hash aCollSeq;                \/* All collating sequences *\/$/;"	m	struct:sqlite3
aConstraint	sqlite3.h	/^  } *aConstraint;            \/* Table of WHERE clause constraints *\/$/;"	m	struct:sqlite3_index_info	typeref:struct:sqlite3_index_info::sqlite3_index_constraint
aConstraintUsage	sqlite3.h	/^  } *aConstraintUsage;$/;"	m	struct:sqlite3_index_info	typeref:struct:sqlite3_index_info::sqlite3_index_constraint_usage
aData	src/btreeInt.h	/^  u8 *aData;           \/* Pointer to disk image of the page data *\/$/;"	m	struct:MemPage
aDb	src/sqliteInt.h	/^  Db *aDb;                      \/* All backends *\/$/;"	m	struct:sqlite3
aDbStatic	src/sqliteInt.h	/^  Db aDbStatic[2];              \/* Static space for the 2 default backends *\/$/;"	m	struct:sqlite3
aDigits	src/printf.c	/^static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";$/;"	v	file:
aExt	src/loadext.c	/^  void **aExt;     \/* Pointers to the extension init functions *\/$/;"	m	struct:__anon24	file:
aExtension	src/sqliteInt.h	/^  void **aExtension;            \/* Array of shared libraray handles *\/$/;"	m	struct:sqlite3
aFKey	src/sqliteInt.h	/^  Hash aFKey;          \/* Foreign keys indexed by to-table *\/$/;"	m	struct:Schema
aFault	src/fault.c	/^} aFault[SQLITE_FAULTINJECTOR_COUNT];$/;"	v	typeref:struct:FaultInjector	file:
aFunc	src/sqliteInt.h	/^  Hash aFunc;                   \/* All functions that can be in SQL exprs *\/$/;"	m	struct:sqlite3
aFunc	src/sqliteInt.h	/^  } *aFunc;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_func
aHash	src/pager.c	/^  PgHdr **aHash;              \/* Hash table to map page number to PgHdr *\/$/;"	m	struct:Pager	file:
aInJournal	src/pager.c	/^  u8 *aInJournal;             \/* One bit for each page in the database file *\/$/;"	m	struct:Pager	file:
aInLoop	src/sqliteInt.h	/^  } *aInLoop;           \/* Information about each nested IN operator *\/$/;"	m	struct:WhereLevel	typeref:struct:WhereLevel::InLoop
aInStmt	src/pager.c	/^  u8 *aInStmt;                \/* One bit for each page in the database *\/$/;"	m	struct:Pager	file:
aIndex	src/test8.c	/^  int *aIndex;            \/* Array of size nCol. True if column has an index *\/$/;"	m	struct:echo_vtab	file:
aJournalMagic	src/pager.c	/^static const unsigned char aJournalMagic[] = {$/;"	v	file:
aKeywordTable	tool/mkkeywordhash.c	/^static Keyword aKeywordTable[] = {$/;"	v	file:
aLabel	src/vdbeInt.h	/^  int *aLabel;        \/* Space to hold the labels *\/$/;"	m	struct:Vdbe
aLock	src/test_async.c	/^  Hash aLock;                  \/* Files locked *\/$/;"	m	struct:TestAsyncStaticData	file:
aLookahead	tool/lemon.c	/^    *aLookahead;               \/* A single new transaction set *\/$/;"	m	struct:acttab	typeref:struct:acttab::__anon10	file:
aMatch	ext/fts1/fts1.c	/^  } *aMatch;      \/* Points to space obtained from malloc *\/$/;"	m	struct:Snippet	typeref:struct:Snippet::snippetMatch	file:
aMatch	ext/fts2/fts2.c	/^  } *aMatch;      \/* Points to space obtained from malloc *\/$/;"	m	struct:Snippet	typeref:struct:Snippet::snippetMatch	file:
aMatch	ext/fts3/fts3.c	/^  } *aMatch;      \/* Points to space obtained from malloc *\/$/;"	m	struct:Snippet	typeref:struct:Snippet::snippetMatch	file:
aMem	src/vdbeInt.h	/^  Mem *aMem;              \/* The memory locations *\/$/;"	m	struct:Vdbe
aModule	src/sqliteInt.h	/^  Hash aModule;                 \/* populated by sqlite3_create_module() *\/$/;"	m	struct:sqlite3
aMutex	src/vdbeInt.h	/^  BtreeMutexArray aMutex; \/* An array of Btree used here and needing locks *\/$/;"	m	struct:Vdbe
aOffset	ext/fts2/fts2_icu.c	/^  int *aOffset;               \/* Offsets of each character in utf-8 input *\/$/;"	m	struct:IcuCursor	file:
aOffset	ext/fts3/fts3_icu.c	/^  int *aOffset;               \/* Offsets of each character in utf-8 input *\/$/;"	m	struct:IcuCursor	file:
aOffset	src/vdbeInt.h	/^  u32 *aOffset;         \/* Cached offsets to the start of each columns data *\/$/;"	m	struct:Cursor
aOp	src/vdbeInt.h	/^  Op *aOp;            \/* Space to hold the virtual machine's program *\/$/;"	m	struct:Vdbe
aOrderBy	sqlite3.h	/^  } *aOrderBy;               \/* The ORDER BY clause *\/$/;"	m	struct:sqlite3_index_info	typeref:struct:sqlite3_index_info::sqlite3_index_orderby
aOverflow	src/btreeInt.h	/^  Pgno *aOverflow;          \/* Cache of overflow page locations *\/$/;"	m	struct:BtCursor
aOvfl	src/btreeInt.h	/^  } aOvfl[5];$/;"	m	struct:MemPage	typeref:struct:MemPage::_OvflCell
aPadding	src/os_unix.c	/^  char aPadding[32];$/;"	m	struct:unixFile	file:
aPending	src/os_unix.c	/^  int *aPending;        \/* Malloced space holding fd's awaiting a close() *\/$/;"	m	struct:openCnt	file:
aPool	src/mem3.c	/^  Mem3Block aPool[SQLITE_MEMORY_SIZE\/sizeof(Mem3Block)+2];$/;"	m	struct:__anon22	file:
aPrefix	src/printf.c	/^static const char aPrefix[] = "-x0\\000X0";$/;"	v	file:
aRow	src/vdbeInt.h	/^  u8 *aRow;             \/* Data for the current row, if all on one page *\/$/;"	m	struct:Cursor
aSlot	src/vdbeInt.h	/^  i64 aSlot[1];      \/* One or more slots for rowid values *\/$/;"	m	struct:FifoPage
aSortOrder	src/sqliteInt.h	/^  u8 *aSortOrder;     \/* If defined an aSortOrder[i] is true, sort DESC *\/$/;"	m	struct:KeyInfo
aSortOrder	src/sqliteInt.h	/^  u8 *aSortOrder;  \/* Array of size Index.nColumn. True==DESC, False==ASC *\/$/;"	m	struct:Index
aStatic	src/where.c	/^  WhereTerm aStatic[10];   \/* Initial static space for a[] *\/$/;"	m	struct:WhereClause	file:
aTableLock	src/sqliteInt.h	/^  TableLock *aTableLock; \/* Required table locks for shared-cache mode *\/$/;"	m	struct:Parse
aTempReg	src/sqliteInt.h	/^  int aTempReg[8];     \/* Holding area for temporary registers *\/$/;"	m	struct:Parse
aType	src/vdbeInt.h	/^  u32 *aType;           \/* Type values for all entries in the record *\/$/;"	m	struct:Cursor
aVTrans	src/sqliteInt.h	/^  sqlite3_vtab **aVTrans;       \/* Virtual tables with open transactions *\/$/;"	m	struct:sqlite3
aVar	src/vdbeInt.h	/^  Mem *aVar;          \/* Values for the OP_Variable opcode. *\/$/;"	m	struct:Vdbe
aborted	src/vdbeInt.h	/^  u8 aborted;             \/* True if ROLLBACK in another VM causes an abort *\/$/;"	m	struct:Vdbe
absFunc	src/func.c	/^static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
accept	tool/lemon.c	/^  char *accept;            \/* Code to execute when the parser excepts *\/$/;"	m	struct:lemon	file:
acceptln	tool/lemon.c	/^  int  acceptln;           \/* Line number for the start of accept code *\/$/;"	m	struct:lemon	file:
accessPayload	src/btree.c	/^static int accessPayload($/;"	f	file:
action	tool/lemon.c	/^    int action;                \/* Action to take on the given lookahead *\/$/;"	m	struct:acttab::__anon10	file:
action	tool/lemon.c	/^struct action {$/;"	s	file:
actioncmp	tool/lemon.c	/^static int actioncmp($/;"	f	file:
activeVdbeCnt	src/sqliteInt.h	/^  int activeVdbeCnt;            \/* Number of vdbes currently executing *\/$/;"	m	struct:sqlite3
acttab	tool/lemon.c	/^struct acttab {$/;"	s	file:
acttab	tool/lemon.c	/^typedef struct acttab acttab;$/;"	t	typeref:struct:acttab	file:
acttab_action	tool/lemon.c	/^void acttab_action(acttab *p, int lookahead, int action){$/;"	f
acttab_alloc	tool/lemon.c	/^acttab *acttab_alloc(void){$/;"	f
acttab_free	tool/lemon.c	/^void acttab_free(acttab *p){$/;"	f
acttab_insert	tool/lemon.c	/^int acttab_insert(acttab *p){$/;"	f
acttab_size	tool/lemon.c	428;"	d	file:
acttab_yyaction	tool/lemon.c	431;"	d	file:
acttab_yylookahead	tool/lemon.c	434;"	d	file:
actualWidth	src/shell.c	/^  int actualWidth[100];  \/* Actual width of each column *\/$/;"	m	struct:callback_data	file:
addAggInfoColumn	src/expr.c	/^static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addAggInfoFunc	src/expr.c	/^static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addArgumentToVtab	src/vtab.c	/^static void addArgumentToVtab(Parse *pParse){$/;"	f	file:
addAsyncWrite	src/test_async.c	/^static void addAsyncWrite(AsyncWrite *pWrite){$/;"	f	file:
addColOffset	src/sqliteInt.h	/^  int addColOffset;  \/* Offset in CREATE TABLE statement to add a new column *\/$/;"	m	struct:Table
addModuleArgument	src/vtab.c	/^static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){$/;"	f	file:
addNewAsyncWrite	src/test_async.c	/^static int addNewAsyncWrite($/;"	f	file:
addPos	ext/fts1/fts1.c	/^static void addPos(DocList *d, int iColumn, int iPos){$/;"	f	file:
addToVTrans	src/vtab.c	/^static int addToVTrans(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f	file:
addWhereTerm	src/select.c	/^static void addWhereTerm($/;"	f	file:
add_alignment_test_collations	src/test1.c	/^static int add_alignment_test_collations($/;"	f	file:
add_column_fullname	parse.y	/^add_column_fullname ::= fullname(X). {$/;"	l
add_column_fullname	src/parse.y	/^add_column_fullname ::= fullname(X). {$/;"	l
add_history	src/shell.c	41;"	d	file:
addrOpenEphm	src/sqliteInt.h	/^  int addrOpenEphm[3];   \/* OP_OpenEphem opcodes related to this select *\/$/;"	m	struct:Select
affinity	src/sqliteInt.h	/^  char affinity;         \/* MakeRecord with this affinity for SRT_Set *\/$/;"	m	struct:Select
affinity	src/sqliteInt.h	/^  char affinity;         \/* The affinity of the column or 0 if not a column *\/$/;"	m	struct:Expr
affinity	src/sqliteInt.h	/^  char affinity;   \/* One of the SQLITE_AFF_... values *\/$/;"	m	struct:Column
affinity	src/sqliteInt.h	/^  u8 affinity;      \/* Affinity used when eDest==SRT_Set *\/$/;"	m	struct:SelectDest
afpLockingContext	src/os_unix.c	/^struct afpLockingContext {$/;"	s	file:
afpLockingContext	src/os_unix.c	/^typedef struct afpLockingContext afpLockingContext;$/;"	t	typeref:struct:afpLockingContext	file:
afpLockingStyle	src/os_unix.c	/^        afpLockingStyle,             \/* use afp locks *\/$/;"	e	enum:__anon15	file:
afpUnixCheckReservedLock	src/os_unix.c	/^static int afpUnixCheckReservedLock(sqlite3_file *id){$/;"	f	file:
afpUnixClose	src/os_unix.c	/^static int afpUnixClose(sqlite3_file *id) {$/;"	f	file:
afpUnixLock	src/os_unix.c	/^static int afpUnixLock(sqlite3_file *id, int locktype)$/;"	f	file:
afpUnixUnlock	src/os_unix.c	/^static int afpUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
afpfsByteRangeLock2FSCTL	src/os_unix.c	1471;"	d	file:
aggregate_context	src/sqlite3ext.h	/^  void * (*aggregate_context)(sqlite3_context*,int nBytes);$/;"	m	struct:sqlite3_api_routines
aggregate_count	src/sqlite3ext.h	/^  int  (*aggregate_count)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
aiColumn	src/sqliteInt.h	/^  int *aiColumn;   \/* Which columns are used by this index.  1st is 0 *\/$/;"	m	struct:Index
aiHash	src/mem3.c	/^  u32 aiHash[N_HASH];        \/* For sizes MX_SMALL+1 and larger *\/$/;"	m	struct:__anon22	file:
aiRowEst	src/sqliteInt.h	/^  unsigned *aiRowEst; \/* Result of ANALYZE: Est. rows selected by each column *\/$/;"	m	struct:Index
aiSmall	src/mem3.c	/^  u32 aiSmall[MX_SMALL-1];   \/* For sizes 2 through MX_SMALL, inclusive *\/$/;"	m	struct:__anon22	file:
alarmArg	src/mem1.c	/^  void *alarmArg;$/;"	m	struct:__anon12	file:
alarmArg	src/mem2.c	/^  void *alarmArg;$/;"	m	struct:__anon16	file:
alarmArg	src/mem4.c	/^  void *alarmArg;$/;"	m	struct:__anon18	file:
alarmBusy	src/mem1.c	/^  int alarmBusy;$/;"	m	struct:__anon12	file:
alarmBusy	src/mem2.c	/^  int alarmBusy;$/;"	m	struct:__anon16	file:
alarmBusy	src/mem3.c	/^  int alarmBusy;$/;"	m	struct:__anon22	file:
alarmBusy	src/mem4.c	/^  int alarmBusy;$/;"	m	struct:__anon18	file:
alarmCallback	src/mem1.c	/^  void (*alarmCallback)(void*, sqlite3_int64,int);$/;"	m	struct:__anon12	file:
alarmCallback	src/mem2.c	/^  void (*alarmCallback)(void*, sqlite3_int64, int);$/;"	m	struct:__anon16	file:
alarmCallback	src/mem4.c	/^  void (*alarmCallback)(void*, sqlite3_int64,int);$/;"	m	struct:__anon18	file:
alarmThreshold	src/mem1.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon12	file:
alarmThreshold	src/mem2.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon16	file:
alarmThreshold	src/mem4.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon18	file:
alias	tool/lemon.c	/^  char *alias[MAXRHS];       \/* Aliases for each RHS symbol (or NULL) *\/$/;"	m	struct:pstate	file:
alignmentCollFunc	src/test1.c	/^static int alignmentCollFunc($/;"	f	file:
allSpaces	src/main.c	/^static int allSpaces(const char *z, int n){$/;"	f	file:
all_stop	test/threadtest2.c	/^volatile int all_stop = 0;$/;"	v
allcksum	test/tester.tcl	/^proc allcksum {{db db}} {$/;"	p
allocateBtreePage	src/btree.c	/^static int allocateBtreePage($/;"	f	file:
allocateCursor	src/vdbe.c	/^static Cursor *allocateCursor(Vdbe *p, int iCur, int iDb){$/;"	f	file:
allocateFifoPage	src/vdbefifo.c	/^static FifoPage *allocateFifoPage(int nEntry){$/;"	f	file:
allocateSpace	src/btree.c	/^static int allocateSpace(MemPage *pPage, int nByte){$/;"	f	file:
alloced	ext/fts1/fts1.c	/^  int alloced;  \/* Space allocated for s[] *\/ $/;"	m	struct:StringBuffer	file:
allowAgg	src/sqliteInt.h	/^  u8 allowAgg;         \/* Aggregate functions allowed here *\/$/;"	m	struct:NameContext
allowedOp	src/where.c	/^static int allowedOp(int op){$/;"	f	file:
alwaysRollback	src/pager.c	/^  u8 alwaysRollback;             \/* Disable DontRollback() for this page *\/$/;"	m	struct:PgHdr	file:
alwaysRollback	src/pager.c	/^  u8 alwaysRollback;          \/* Disable DontRollback() for all pages *\/$/;"	m	struct:Pager	file:
anRef	src/btreeInt.h	/^  int *anRef;       \/* Number of times each page is referenced *\/$/;"	m	struct:IntegrityCk
analysisInfo	src/analyze.c	/^struct analysisInfo {$/;"	s	file:
analysisInfo	src/analyze.c	/^typedef struct analysisInfo analysisInfo;$/;"	t	typeref:struct:analysisInfo	file:
analysisLoader	src/analyze.c	/^static int analysisLoader(void *pData, int argc, char **argv, char **azNotUsed){$/;"	f	file:
analyzeAggregate	src/expr.c	/^static int analyzeAggregate(void *pArg, Expr *pExpr){$/;"	f	file:
analyzeDatabase	src/analyze.c	/^static void analyzeDatabase(Parse *pParse, int iDb){$/;"	f	file:
analyzeOneTable	src/analyze.c	/^static void analyzeOneTable($/;"	f	file:
analyzeTable	src/analyze.c	/^static void analyzeTable(Parse *pParse, Table *pTab){$/;"	f	file:
anylist	parse.y	/^anylist ::= .$/;"	l
anylist	parse.y	/^anylist ::= anylist ANY(X).         {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
anylist	src/parse.y	/^anylist ::= .$/;"	l
anylist	src/parse.y	/^anylist ::= anylist ANY(X).         {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
ap	tool/lemon.c	/^  struct action *ap;       \/* Array of actions for this state *\/$/;"	m	struct:state	typeref:struct:state::action	file:
apArg	src/vdbeInt.h	/^  Mem **apArg;        \/* Arguments to currently executing user function *\/$/;"	m	struct:Vdbe
apAux	src/vdbeInt.h	/^  } apAux[1];                   \/* One slot for each function argument *\/$/;"	m	struct:VdbeFunc	typeref:struct:VdbeFunc::AuxData
apCsr	src/vdbeInt.h	/^  Cursor **apCsr;     \/* One element of this array for each open cursor *\/$/;"	m	struct:Vdbe
apInfo	src/sqliteInt.h	/^  sqlite3_index_info **apInfo;  \/* Array of pointers to index info structures *\/$/;"	m	struct:WhereInfo
apVarExpr	src/sqliteInt.h	/^  Expr **apVarExpr;    \/* Pointers to :aaa and $aaaa wildcard expressions *\/$/;"	m	struct:Parse
append	ext/fts1/fts1.c	/^static void append(StringBuffer *sb, const char *zFrom){$/;"	f	file:
append	ext/fts2/fts2.c	/^static void append(StringBuffer *sb, const char *zFrom){$/;"	f	file:
append	ext/fts3/fts3.c	/^static void append(StringBuffer *sb, const char *zFrom){$/;"	f	file:
appendList	ext/fts1/fts1.c	/^static void appendList(StringBuffer *sb, int nString, char **azString){$/;"	f	file:
appendList	ext/fts2/fts2.c	/^static void appendList(StringBuffer *sb, int nString, char **azString){$/;"	f	file:
appendList	ext/fts3/fts3.c	/^static void appendList(StringBuffer *sb, int nString, char **azString){$/;"	f	file:
appendSpace	src/printf.c	/^static void appendSpace(StrAccum *pAccum, int N){$/;"	f	file:
appendText	src/shell.c	/^static char *appendText(char *zIn, char const *zAppend, char quote){$/;"	f	file:
appendToEchoModule	src/test8.c	/^static void appendToEchoModule(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
appendVarint	ext/fts1/fts1.c	/^static void appendVarint(DocList *d, sqlite_int64 i){$/;"	f	file:
appendWhiteSpace	ext/fts1/fts1.c	/^static void appendWhiteSpace(StringBuffer *p){$/;"	f	file:
appendWhiteSpace	ext/fts2/fts2.c	/^static void appendWhiteSpace(StringBuffer *p){$/;"	f	file:
appendWhiteSpace	ext/fts3/fts3.c	/^static void appendWhiteSpace(StringBuffer *p){$/;"	f	file:
append_str	tool/lemon.c	/^PRIVATE char *append_str(char *zText, int n, int p1, int p2){$/;"	f
applyAffinity	src/vdbe.c	/^static void applyAffinity($/;"	f	file:
applyNumericAffinity	src/vdbe.c	/^static void applyNumericAffinity(Mem *pRec){$/;"	f	file:
approx	src/func.c	/^  u8 approx;        \/* True if non-integer value was input to the sum *\/$/;"	m	struct:SumCtx	file:
arg	tool/lemon.c	/^  char *arg;               \/* Declaration of the 3th argument to parser *\/$/;"	m	struct:lemon	file:
arg	tool/lemon.c	/^  char *arg;$/;"	m	struct:s_options	file:
argc	src/test4.c	/^  int argc;             \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argc	src/test7.c	/^  int argc;                \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argindex	tool/lemon.c	/^static int argindex(n)$/;"	f	file:
argv	src/test4.c	/^  const char *argv[100];    \/* result columns *\/$/;"	m	struct:Thread	file:
argv	src/test7.c	/^  const char *argv[100];   \/* result columns *\/$/;"	m	struct:Thread	file:
argv	tool/lemon.c	/^static char **argv;$/;"	v	file:
argv0	tool/lemon.c	/^  char *argv0;             \/* Name of the program *\/$/;"	m	struct:lemon	file:
argvIndex	sqlite3.h	/^    int argvIndex;           \/* if >0, constraint is part of argv to xFilter *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint_usage
assemblePage	src/btree.c	/^static void assemblePage($/;"	f	file:
assertCellInfo	src/btree.c	/^  static void assertCellInfo(BtCursor *pCur){$/;"	f	file:
assertCellInfo	src/btree.c	2853;"	d	file:
assoc	tool/lemon.c	/^  } assoc;                 \/* Associativity if predecence is defined *\/$/;"	m	struct:symbol	typeref:enum:symbol::e_assoc	file:
async	src/test_async.c	/^} async = {$/;"	v	typeref:struct:TestAsyncStaticData	file:
asyncAccess	src/test_async.c	/^static int asyncAccess(sqlite3_vfs *pAsyncVfs, const char *zName, int flags){$/;"	f	file:
asyncCheckReservedLock	src/test_async.c	/^static int asyncCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
asyncClose	src/test_async.c	/^static int asyncClose(sqlite3_file *pFile){$/;"	f	file:
asyncCurrentTime	src/test_async.c	/^static int asyncCurrentTime(sqlite3_vfs *pAsyncVfs, double *pTimeOut){$/;"	f	file:
asyncDelete	src/test_async.c	/^static int asyncDelete(sqlite3_vfs *pAsyncVfs, const char *z, int syncDir){$/;"	f	file:
asyncDeviceCharacteristics	src/test_async.c	/^static int asyncDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
asyncDlClose	src/test_async.c	/^static void asyncDlClose(sqlite3_vfs *pAsyncVfs, void *pHandle){$/;"	f	file:
asyncDlError	src/test_async.c	/^static void asyncDlError(sqlite3_vfs *pAsyncVfs, int nByte, char *zErrMsg){$/;"	f	file:
asyncDlOpen	src/test_async.c	/^static void *asyncDlOpen(sqlite3_vfs *pAsyncVfs, const char *zPath){$/;"	f	file:
asyncDlSym	src/test_async.c	/^static void *asyncDlSym($/;"	f	file:
asyncEnable	src/test_async.c	/^static void asyncEnable(int enable){$/;"	f	file:
asyncFileControl	src/test_async.c	/^static int asyncFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
asyncFileSize	src/test_async.c	/^int asyncFileSize(sqlite3_file *pFile, i64 *piSize){$/;"	f
asyncFullPathname	src/test_async.c	/^static int asyncFullPathname($/;"	f	file:
asyncGetTempname	src/test_async.c	/^static int asyncGetTempname(sqlite3_vfs *pAsyncVfs, int nBufOut, char *zBufOut){$/;"	f	file:
asyncLock	src/test_async.c	/^static int asyncLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncOpen	src/test_async.c	/^static int asyncOpen($/;"	f	file:
asyncRandomness	src/test_async.c	/^static int asyncRandomness(sqlite3_vfs *pAsyncVfs, int nByte, char *zBufOut){$/;"	f	file:
asyncRead	src/test_async.c	/^static int asyncRead(sqlite3_file *pFile, void *zOut, int iAmt, i64 iOffset){$/;"	f	file:
asyncSectorSize	src/test_async.c	/^static int asyncSectorSize(sqlite3_file *pFile){$/;"	f	file:
asyncSleep	src/test_async.c	/^static int asyncSleep(sqlite3_vfs *pAsyncVfs, int nMicro){$/;"	f	file:
asyncSync	src/test_async.c	/^static int asyncSync(sqlite3_file *pFile, int flags){$/;"	f	file:
asyncTrace	src/test_async.c	/^static void asyncTrace(const char *zFormat, ...){$/;"	f	file:
asyncTruncate	src/test_async.c	/^static int asyncTruncate(sqlite3_file *pFile, i64 nByte){$/;"	f	file:
asyncUnlock	src/test_async.c	/^static int asyncUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncWrite	src/test_async.c	/^static int asyncWrite(sqlite3_file *pFile, const void *pBuf, int amt, i64 iOff){$/;"	f	file:
asyncWriterThread	src/test_async.c	/^static void *asyncWriterThread(void *pIsStarted){$/;"	f	file:
async_cond_wait	src/test_async.c	/^static int async_cond_wait(pthread_cond_t *pCond, pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_lock	src/test_async.c	/^static int async_mutex_lock(pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_trylock	src/test_async.c	/^static int async_mutex_trylock(pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_unlock	src/test_async.c	/^static int async_mutex_unlock(pthread_mutex_t *pMutex){$/;"	f	file:
async_vfs	src/test_async.c	/^static sqlite3_vfs async_vfs = {$/;"	v	file:
asyncdebug	src/test_async.c	/^} asyncdebug = {0, 0, 0};$/;"	v	typeref:struct:TestAsyncDebugData	file:
atEnd	ext/fts1/fts1.c	/^static int atEnd(DocListReader *pReader){$/;"	f	file:
atFirst	src/vdbeInt.h	/^  Bool atFirst;         \/* True if pointing to first entry *\/$/;"	m	struct:Cursor
attachFunc	src/attach.c	/^static void attachFunc($/;"	f	file:
auth_callback	src/tclsqlite.c	/^static int auth_callback($/;"	f	file:
autoCommit	src/sqliteInt.h	/^  u8 autoCommit;                \/* The auto-commit flag. *\/$/;"	m	struct:sqlite3
autoExtBrokenObjCmd	src/test_autoext.c	/^static int autoExtBrokenObjCmd($/;"	f	file:
autoExtCubeObjCmd	src/test_autoext.c	/^static int autoExtCubeObjCmd($/;"	f	file:
autoExtSqrObjCmd	src/test_autoext.c	/^static int autoExtSqrObjCmd($/;"	f	file:
autoInc	src/sqliteInt.h	/^  u8 autoInc;      \/* True if the integer primary key is autoincrement *\/$/;"	m	struct:Table
autoIncBegin	src/insert.c	/^static int autoIncBegin($/;"	f	file:
autoIncBegin	src/insert.c	238;"	d	file:
autoIncEnd	src/insert.c	/^static void autoIncEnd($/;"	f	file:
autoIncEnd	src/insert.c	240;"	d	file:
autoIncStep	src/insert.c	/^static void autoIncStep(Parse *pParse, int memId, int regRowid){$/;"	f	file:
autoIncStep	src/insert.c	239;"	d	file:
autoIndex	src/sqliteInt.h	/^  u8 autoIndex;    \/* True if is automatically created (ex: by UNIQUE) *\/$/;"	m	struct:Index
autoVacuum	src/btreeInt.h	/^  u8 autoVacuum;        \/* True if auto-vacuum is enabled *\/$/;"	m	struct:BtShared
autoVacuumCommit	src/btree.c	/^static int autoVacuumCommit(BtShared *pBt, Pgno *pnTrunc){$/;"	f	file:
autoext	src/loadext.c	/^} autoext = { 0, 0 };$/;"	v	typeref:struct:__anon24	file:
autovacuum_overhead	tool/spaceanal.tcl	/^proc autovacuum_overhead {filePages pageSize} {$/;"	p
avgFinalize	src/func.c	/^static void avgFinalize(sqlite3_context *context){$/;"	f	file:
axset	tool/lemon.c	/^struct axset {$/;"	s	file:
axset_compare	tool/lemon.c	/^static int axset_compare(const void *a, const void *b){$/;"	f	file:
azColl	src/sqliteInt.h	/^  char **azColl;   \/* Array of collation sequence names for index *\/$/;"	m	struct:Index
azColumn	ext/fts1/fts1.c	/^  char **azColumn;                 \/* column names.  malloced *\/$/;"	m	struct:fulltext_vtab	file:
azColumn	ext/fts1/fts1.c	/^  char **azColumn;         \/* Original names of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
azColumn	ext/fts2/fts2.c	/^  char **azColumn;                 \/* column names.  malloced *\/$/;"	m	struct:fulltext_vtab	file:
azColumn	ext/fts2/fts2.c	/^  char **azColumn;         \/* Original names of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
azColumn	ext/fts3/fts3.c	/^  char **azColumn;                 \/* column names.  malloced *\/$/;"	m	struct:fulltext_vtab	file:
azColumn	ext/fts3/fts3.c	/^  char **azColumn;         \/* Original names of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
azContentColumn	ext/fts1/fts1.c	/^  char **azContentColumn;          \/* column names in content table; malloced *\/$/;"	m	struct:fulltext_vtab	file:
azContentColumn	ext/fts1/fts1.c	/^  char **azContentColumn;  \/* Column names for %_content *\/$/;"	m	struct:TableSpec	file:
azContentColumn	ext/fts2/fts2.c	/^  char **azContentColumn;          \/* column names in content table; malloced *\/$/;"	m	struct:fulltext_vtab	file:
azContentColumn	ext/fts2/fts2.c	/^  char **azContentColumn;  \/* Column names for %_content *\/$/;"	m	struct:TableSpec	file:
azContentColumn	ext/fts3/fts3.c	/^  char **azContentColumn;          \/* column names in content table; malloced *\/$/;"	m	struct:fulltext_vtab	file:
azContentColumn	ext/fts3/fts3.c	/^  char **azContentColumn;  \/* Column names for %_content *\/$/;"	m	struct:TableSpec	file:
azDefine	tool/lemon.c	/^static char **azDefine = 0;  \/* Name of the -D macros *\/$/;"	v	file:
azElem	test/threadtest1.c	/^  char **azElem;      \/* The result of the query *\/$/;"	m	struct:QueryResult	file:
azModuleArg	src/sqliteInt.h	/^  char **azModuleArg;       \/* Text of all module args. [0] is module name *\/$/;"	m	struct:Table
azOpcodeName	src/test_async.c	/^static const char *azOpcodeName[] = {$/;"	v	file:
azResColumn	src/vdbeInt.h	/^  char **azResColumn;     \/* Values for one row of result *\/ $/;"	m	struct:Vdbe
azResult	src/table.c	/^  char **azResult;$/;"	m	struct:TabResult	file:
azTokenizer	ext/fts1/fts1.c	/^  char **azTokenizer;      \/* Name of tokenizer and its arguments *\/$/;"	m	struct:TableSpec	file:
azTokenizer	ext/fts2/fts2.c	/^  char **azTokenizer;      \/* Name of tokenizer and its arguments *\/$/;"	m	struct:TableSpec	file:
azTokenizer	ext/fts3/fts3.c	/^  char **azTokenizer;      \/* Name of tokenizer and its arguments *\/$/;"	m	struct:TableSpec	file:
azVar	src/vdbeInt.h	/^  char **azVar;       \/* Name of variables *\/$/;"	m	struct:Vdbe
b	ext/fts2/fts2.c	/^  DataBuffer *b;$/;"	m	struct:DLWriter	file:
b	ext/fts2/fts2.c	/^  DataBuffer b;            \/* Includes null terminator. *\/$/;"	m	struct:StringBuffer	file:
b	ext/fts2/fts2.c	/^  DataBuffer b;$/;"	m	struct:DLCollector	file:
b	ext/fts3/fts3.c	/^  DataBuffer *b;$/;"	m	struct:DLWriter	file:
b	ext/fts3/fts3.c	/^  DataBuffer b;            \/* Includes null terminator. *\/$/;"	m	struct:StringBuffer	file:
b	ext/fts3/fts3.c	/^  DataBuffer b;$/;"	m	struct:DLCollector	file:
b	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	m	struct:TrigEvent	file:
bExclusive	src/os_win.c	/^  BOOL bExclusive;    \/* Indicates an exclusive lock has been obtained *\/$/;"	m	struct:winceLock	file:
bPending	src/os_win.c	/^  BOOL bPending;      \/* Indicates a pending lock has been obtained *\/$/;"	m	struct:winceLock	file:
bReserved	src/os_win.c	/^  BOOL bReserved;     \/* Indicates a reserved lock has been obtained *\/$/;"	m	struct:winceLock	file:
backtrace	src/mem2.c	55;"	d	file:
backtrace_symbols_fd	src/mem2.c	56;"	d	file:
bail_on_error	src/shell.c	/^static int bail_on_error = 0;$/;"	v	file:
balance	src/btree.c	/^static int balance(MemPage *pPage, int insert){$/;"	f	file:
balance_deeper	src/btree.c	/^static int balance_deeper(MemPage *pPage){$/;"	f	file:
balance_nonroot	src/btree.c	/^static int balance_nonroot(MemPage *pPage){$/;"	f	file:
balance_quick	src/btree.c	/^static int balance_quick(MemPage *pPage, MemPage *pParent){$/;"	f	file:
balance_shallower	src/btree.c	/^static int balance_shallower(MemPage *pPage){$/;"	f	file:
base	ext/fts1/fts1.c	/^  sqlite3_vtab base;               \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_vtab	file:
base	ext/fts1/fts1.c	/^  sqlite3_vtab_cursor base;        \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_cursor	file:
base	ext/fts1/fts1_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	ext/fts1/fts1_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	ext/fts1/fts1_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	ext/fts1/fts1_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	ext/fts2/fts2.c	/^  sqlite3_vtab base;               \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_vtab	file:
base	ext/fts2/fts2.c	/^  sqlite3_vtab_cursor base;        \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_cursor	file:
base	ext/fts2/fts2_icu.c	/^  sqlite3_tokenizer base;$/;"	m	struct:IcuTokenizer	file:
base	ext/fts2/fts2_icu.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:IcuCursor	file:
base	ext/fts2/fts2_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	ext/fts2/fts2_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	ext/fts2/fts2_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	ext/fts2/fts2_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	ext/fts3/fts3.c	/^  sqlite3_vtab base;               \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_vtab	file:
base	ext/fts3/fts3.c	/^  sqlite3_vtab_cursor base;        \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_cursor	file:
base	ext/fts3/fts3_icu.c	/^  sqlite3_tokenizer base;$/;"	m	struct:IcuTokenizer	file:
base	ext/fts3/fts3_icu.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:IcuCursor	file:
base	ext/fts3/fts3_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	ext/fts3/fts3_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	ext/fts3/fts3_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	ext/fts3/fts3_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	src/printf.c	/^  etByte base;             \/* The base for radix conversion *\/$/;"	m	struct:et_info	file:
base	src/test8.c	/^  sqlite3_vtab base;$/;"	m	struct:echo_vtab	file:
base	src/test8.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:echo_cursor	file:
base	src/test_devsym.c	/^  sqlite3_file base;$/;"	m	struct:devsym_file	file:
base	src/test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:fs_file	file:
base	src/test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:tmp_file	file:
base	src/test_onefile.c	/^  sqlite3_vfs base;$/;"	m	struct:fs_vfs_t	file:
base	src/test_schema.c	/^  sqlite3_vtab base;$/;"	m	struct:schema_vtab	file:
base	src/test_schema.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:schema_cursor	file:
base	src/test_tclvar.c	/^  sqlite3_vtab base;$/;"	m	struct:tclvar_vtab	file:
base	src/test_tclvar.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:tclvar_cursor	file:
base	src/test_thread.c	/^  Tcl_Event base;          \/* Base class of type Tcl_Event *\/$/;"	m	struct:EvalEvent	file:
basis	tool/lemon.c	/^static struct config *basis = 0;         \/* Top of list of basis configs *\/$/;"	v	typeref:struct:config	file:
basisend	tool/lemon.c	/^static struct config **basisend = 0;     \/* End of list of basis configs *\/$/;"	v	typeref:struct:config	file:
basisflag	tool/lemon.c	/^  int basisflag;           \/* Print only basis configurations *\/$/;"	m	struct:lemon	file:
beginTimer	src/shell.c	/^static void beginTimer(void){$/;"	f	file:
benign	src/fault.c	/^  u8 benign;        \/* Ture if next failure will be benign *\/$/;"	m	struct:FaultInjector	file:
bestIndex	src/where.c	/^static double bestIndex($/;"	f	file:
bestVirtualIndex	src/where.c	/^static double bestVirtualIndex($/;"	f	file:
binCollFunc	src/main.c	/^static int binCollFunc($/;"	f	file:
binCompare	ext/fts1/fts1_hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binCompare	ext/fts2/fts2_hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binCompare	src/hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binHash	ext/fts1/fts1_hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binHash	ext/fts2/fts2_hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binHash	src/hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binarize	src/test5.c	/^static int binarize($/;"	f	file:
binaryCompareP5	src/expr.c	/^static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){$/;"	f	file:
bindText	src/vdbeapi.c	/^static int bindText($/;"	f	file:
bind_blob	src/sqlite3ext.h	/^  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_double	src/sqlite3ext.h	/^  int  (*bind_double)(sqlite3_stmt*,int,double);$/;"	m	struct:sqlite3_api_routines
bind_int	src/sqlite3ext.h	/^  int  (*bind_int)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bind_int64	src/sqlite3ext.h	/^  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
bind_null	src/sqlite3ext.h	/^  int  (*bind_null)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_parameter_count	src/sqlite3ext.h	/^  int  (*bind_parameter_count)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
bind_parameter_index	src/sqlite3ext.h	/^  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);$/;"	m	struct:sqlite3_api_routines
bind_parameter_name	src/sqlite3ext.h	/^  const char * (*bind_parameter_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_text	src/sqlite3ext.h	/^  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_text16	src/sqlite3ext.h	/^  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_value	src/sqlite3ext.h	/^  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
bind_zeroblob	src/sqlite3ext.h	/^  int (*bind_zeroblob)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bits	src/test_md5.c	/^  uint32 bits[2];$/;"	m	struct:Context	file:
blobReadWrite	src/vdbeblob.c	/^static int blobReadWrite($/;"	f	file:
blob_bytes	src/sqlite3ext.h	/^  int (*blob_bytes)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_close	src/sqlite3ext.h	/^  int (*blob_close)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_open	src/sqlite3ext.h	/^  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**);$/;"	m	struct:sqlite3_api_routines
blob_read	src/sqlite3ext.h	/^  int (*blob_read)(sqlite3_blob*,void*,int,int);$/;"	m	struct:sqlite3_api_routines
blob_write	src/sqlite3ext.h	/^  int (*blob_write)(sqlite3_blob*,const void*,int,int);$/;"	m	struct:sqlite3_api_routines
block_delete	ext/fts2/fts2.c	/^static int block_delete(fulltext_vtab *v,$/;"	f	file:
block_delete	ext/fts3/fts3.c	/^static int block_delete(fulltext_vtab *v,$/;"	f	file:
block_insert	ext/fts2/fts2.c	/^static int block_insert(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
block_insert	ext/fts3/fts3.c	/^static int block_insert(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
bogusIncrKey	src/vdbeInt.h	/^  u8 bogusIncrKey;      \/* Something for pIncrKey to point to if pKeyInfo==0 *\/$/;"	m	struct:Cursor
booleanValue	src/shell.c	/^static int booleanValue(char *zArg){$/;"	f	file:
bp	tool/lemon.c	/^  struct config *bp;       \/* The basis configurations for this state *\/$/;"	m	struct:state	typeref:struct:state::config	file:
bp	tool/lemon.c	/^  struct config *bp;       \/* The next basis configuration *\/$/;"	m	struct:config	typeref:struct:config::config	file:
bplp	tool/lemon.c	/^  struct plink *bplp;      \/* Follow-set backwards propagation links *\/$/;"	m	struct:config	typeref:struct:config::plink	file:
brk	src/sqliteInt.h	/^  int brk;              \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereLevel
broken_init	src/test_autoext.c	/^static int broken_init($/;"	f	file:
btreeCopyFile	src/btree.c	/^static int btreeCopyFile(Btree *pTo, Btree *pFrom){$/;"	f	file:
btreeCreateTable	src/btree.c	/^static int btreeCreateTable(Btree *p, int *piTable, int flags){$/;"	f	file:
btreeCursor	src/btree.c	/^static int btreeCursor($/;"	f	file:
btreeDropTable	src/btree.c	/^static int btreeDropTable(Btree *p, int iTable, int *piMoved){$/;"	f	file:
btreeIntegrity	src/btreeInt.h	594;"	d
btreeMask	src/vdbeInt.h	/^  int btreeMask;          \/* Bitmask of db->aDb[] entries referenced *\/$/;"	m	struct:Vdbe
btreeNext	src/btree.c	/^static int btreeNext(BtCursor *pCur, int *pRes){$/;"	f	file:
btreePageDump	src/test_btree.c	/^static int btreePageDump($/;"	f	file:
btreePrevious	src/btree.c	/^static int btreePrevious(BtCursor *pCur, int *pRes){$/;"	f	file:
btree_begin_statement	src/test3.c	/^static int btree_begin_statement($/;"	f	file:
btree_begin_transaction	src/test3.c	/^static int btree_begin_transaction($/;"	f	file:
btree_breakpoint	src/test3.c	/^static int btree_breakpoint($/;"	f	file:
btree_clear_table	src/test3.c	/^static int btree_clear_table($/;"	f	file:
btree_close	src/test3.c	/^static int btree_close($/;"	f	file:
btree_close_cursor	src/test3.c	/^static int btree_close_cursor($/;"	f	file:
btree_commit	src/test3.c	/^static int btree_commit($/;"	f	file:
btree_commit_statement	src/test3.c	/^static int btree_commit_statement($/;"	f	file:
btree_create_table	src/test3.c	/^static int btree_create_table($/;"	f	file:
btree_cursor	src/test3.c	/^static int btree_cursor($/;"	f	file:
btree_cursor_info	src/test3.c	/^static int btree_cursor_info($/;"	f	file:
btree_cursor_list	src/test3.c	/^static int btree_cursor_list($/;"	f	file:
btree_data	src/test3.c	/^static int btree_data($/;"	f	file:
btree_delete	src/test3.c	/^static int btree_delete($/;"	f	file:
btree_drop_table	src/test3.c	/^static int btree_drop_table($/;"	f	file:
btree_eof	src/test3.c	/^static int btree_eof($/;"	f	file:
btree_fetch_data	src/test3.c	/^static int btree_fetch_data($/;"	f	file:
btree_fetch_key	src/test3.c	/^static int btree_fetch_key($/;"	f	file:
btree_first	src/test3.c	/^static int btree_first($/;"	f	file:
btree_from_db	src/test3.c	/^static int btree_from_db($/;"	f	file:
btree_get_meta	src/test3.c	/^static int btree_get_meta($/;"	f	file:
btree_insert	src/test3.c	/^static int btree_insert($/;"	f	file:
btree_integrity_check	src/test3.c	/^static int btree_integrity_check($/;"	f	file:
btree_key	src/test3.c	/^static int btree_key($/;"	f	file:
btree_keysize	src/test3.c	/^static int btree_keysize($/;"	f	file:
btree_last	src/test3.c	/^static int btree_last($/;"	f	file:
btree_move_to	src/test3.c	/^static int btree_move_to($/;"	f	file:
btree_next	src/test3.c	/^static int btree_next($/;"	f	file:
btree_open	src/test3.c	/^static int btree_open($/;"	f	file:
btree_ovfl_info	src/test3.c	/^static int btree_ovfl_info($/;"	f	file:
btree_page_dump	src/test3.c	/^static int btree_page_dump($/;"	f	file:
btree_pager_ref_dump	src/test3.c	/^static int btree_pager_ref_dump($/;"	f	file:
btree_pager_stats	src/test3.c	/^static int btree_pager_stats($/;"	f	file:
btree_payload_size	src/test3.c	/^static int btree_payload_size($/;"	f	file:
btree_prev	src/test3.c	/^static int btree_prev($/;"	f	file:
btree_rollback	src/test3.c	/^static int btree_rollback($/;"	f	file:
btree_rollback_statement	src/test3.c	/^static int btree_rollback_statement($/;"	f	file:
btree_set_cache_size	src/test3.c	/^static int btree_set_cache_size($/;"	f	file:
btree_tree_dump	src/test3.c	/^static int btree_tree_dump($/;"	f	file:
btree_update_meta	src/test3.c	/^static int btree_update_meta($/;"	f	file:
btree_varint_test	src/test3.c	/^static int btree_varint_test($/;"	f	file:
buf	src/test_md5.c	/^  uint32 buf[4];$/;"	m	struct:Context	file:
buildIndexProbe	src/where.c	/^static void buildIndexProbe($/;"	f	file:
buildTerms	ext/fts1/fts1.c	/^static int buildTerms(fulltext_vtab *v, fts1Hash *terms, sqlite_int64 iDocid,$/;"	f	file:
buildTerms	ext/fts2/fts2.c	/^static int buildTerms(fulltext_vtab *v, sqlite_int64 iDocid,$/;"	f	file:
buildTerms	ext/fts3/fts3.c	/^static int buildTerms(fulltext_vtab *v, sqlite_int64 iDocid,$/;"	f	file:
buildshifts	tool/lemon.c	/^PRIVATE void buildshifts(lemp,stp)$/;"	f
busy	src/sqliteInt.h	/^    u8 busy;                    \/* TRUE if currently initializing *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
busy	src/test4.c	/^  int busy;              \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busy	src/test7.c	/^  volatile int busy;       \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busyHandler	src/sqliteInt.h	/^  BusyHandler busyHandler;      \/* Busy callback *\/$/;"	m	struct:sqlite3
busyHdr	src/btreeInt.h	/^  BusyHandler busyHdr;  \/* The busy handler for this btree *\/$/;"	m	struct:BtShared
busyTimeout	src/sqliteInt.h	/^  int busyTimeout;              \/* Busy handler timeout, in msec *\/$/;"	m	struct:sqlite3
busy_handler	src/sqlite3ext.h	/^  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);$/;"	m	struct:sqlite3_api_routines
busy_timeout	src/sqlite3ext.h	/^  int  (*busy_timeout)(sqlite3*,int ms);$/;"	m	struct:sqlite3_api_routines
byteReverse	src/test_md5.c	/^static void byteReverse (unsigned char *buf, unsigned longs){$/;"	f	file:
cType	ext/fts1/fts1_porter.c	/^static const char cType[] = {$/;"	v	file:
cType	ext/fts2/fts2_porter.c	/^static const char cType[] = {$/;"	v	file:
cType	ext/fts3/fts3_porter.c	/^static const char cType[] = {$/;"	v	file:
c_collation_test	src/test9.c	/^static int c_collation_test($/;"	f	file:
c_misuse_test	src/test9.c	/^static int c_misuse_test($/;"	f	file:
c_realloc_test	src/test9.c	/^static int c_realloc_test($/;"	f	file:
cacheCtr	src/vdbeInt.h	/^  int cacheCtr;           \/* Cursor row cache generation counter *\/$/;"	m	struct:Vdbe
cacheStatus	src/vdbeInt.h	/^  int cacheStatus;      \/* Cache is valid if this matches Vdbe.cacheCtr *\/$/;"	m	struct:Cursor
cache_size	src/sqliteInt.h	/^  int cache_size;      \/* Number of pages to use in the cache *\/$/;"	m	struct:Schema
callCollNeeded	src/callback.c	/^static void callCollNeeded(sqlite3 *db, const char *zName, int nName){$/;"	f	file:
callFinaliser	src/vtab.c	/^static void callFinaliser(sqlite3 *db, int offset){$/;"	f	file:
callback	src/shell.c	/^static int callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
callback_data	src/shell.c	/^struct callback_data {$/;"	s	file:
canReduce	tool/lemon.c	/^  Boolean canReduce;       \/* True if this rule is ever reduced *\/$/;"	m	struct:rule	file:
carg	parse.y	/^carg ::= CONSTRAINT nm ccons.$/;"	l
carg	parse.y	/^carg ::= ccons.$/;"	l
carg	src/parse.y	/^carg ::= CONSTRAINT nm ccons.$/;"	l
carg	src/parse.y	/^carg ::= ccons.$/;"	l
carglist	parse.y	/^carglist ::= .$/;"	l
carglist	parse.y	/^carglist ::= carglist carg.$/;"	l
carglist	src/parse.y	/^carglist ::= .$/;"	l
carglist	src/parse.y	/^carglist ::= carglist carg.$/;"	l
catchsql	test/tester.tcl	/^proc catchsql {sql {db db}} {$/;"	p
ccons	parse.y	/^ccons ::= CHECK LP expr(X) RP.       {sqlite3AddCheckConstraint(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= COLLATE ids(C).  {sqlite3AddCollateType(pParse, &C);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT LP expr(X) RP.      {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT MINUS term(X).      {$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT PLUS term(X).       {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT id(X).              {$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT term(X).            {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= NOT NULL onconf(R).               {sqlite3AddNotNull(pParse, R);}$/;"	l
ccons	parse.y	/^ccons ::= NULL onconf.$/;"	l
ccons	parse.y	/^ccons ::= PRIMARY KEY sortorder(Z) onconf(R) autoinc(I).$/;"	l
ccons	parse.y	/^ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).$/;"	l
ccons	parse.y	/^ccons ::= UNIQUE onconf(R).    {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0,0,0);}$/;"	l
ccons	parse.y	/^ccons ::= defer_subclause(D).   {sqlite3DeferForeignKey(pParse,D);}$/;"	l
ccons	src/parse.y	/^ccons ::= CHECK LP expr(X) RP.       {sqlite3AddCheckConstraint(pParse,X);}$/;"	l
ccons	src/parse.y	/^ccons ::= COLLATE ids(C).  {sqlite3AddCollateType(pParse, &C);}$/;"	l
ccons	src/parse.y	/^ccons ::= DEFAULT LP expr(X) RP.      {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	src/parse.y	/^ccons ::= DEFAULT MINUS term(X).      {$/;"	l
ccons	src/parse.y	/^ccons ::= DEFAULT PLUS term(X).       {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	src/parse.y	/^ccons ::= DEFAULT id(X).              {$/;"	l
ccons	src/parse.y	/^ccons ::= DEFAULT term(X).            {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	src/parse.y	/^ccons ::= NOT NULL onconf(R).               {sqlite3AddNotNull(pParse, R);}$/;"	l
ccons	src/parse.y	/^ccons ::= NULL onconf.$/;"	l
ccons	src/parse.y	/^ccons ::= PRIMARY KEY sortorder(Z) onconf(R) autoinc(I).$/;"	l
ccons	src/parse.y	/^ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).$/;"	l
ccons	src/parse.y	/^ccons ::= UNIQUE onconf(R).    {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0,0,0);}$/;"	l
ccons	src/parse.y	/^ccons ::= defer_subclause(D).   {sqlite3DeferForeignKey(pParse,D);}$/;"	l
cdateFunc	src/date.c	/^static void cdateFunc($/;"	f	file:
cellOffset	src/btreeInt.h	/^  u16 cellOffset;      \/* Index in aData of first cell pointer *\/$/;"	m	struct:MemPage
cellSize	src/btree.c	/^static int cellSize(MemPage *pPage, int iCell){$/;"	f	file:
cellSizePtr	src/btree.c	/^static int cellSizePtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
cfAccess	src/test6.c	/^static int cfAccess(sqlite3_vfs *pCfVfs, const char *zPath, int flags){$/;"	f	file:
cfCheckReservedLock	src/test6.c	/^static int cfCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
cfClose	src/test6.c	/^static int cfClose(sqlite3_file *pFile){$/;"	f	file:
cfCurrentTime	src/test6.c	/^static int cfCurrentTime(sqlite3_vfs *pCfVfs, double *pTimeOut){$/;"	f	file:
cfDelete	src/test6.c	/^static int cfDelete(sqlite3_vfs *pCfVfs, const char *zPath, int dirSync){$/;"	f	file:
cfDeviceCharacteristics	src/test6.c	/^static int cfDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
cfDlClose	src/test6.c	/^static void cfDlClose(sqlite3_vfs *pCfVfs, void *pHandle){$/;"	f	file:
cfDlError	src/test6.c	/^static void cfDlError(sqlite3_vfs *pCfVfs, int nByte, char *zErrMsg){$/;"	f	file:
cfDlOpen	src/test6.c	/^static void *cfDlOpen(sqlite3_vfs *pCfVfs, const char *zPath){$/;"	f	file:
cfDlSym	src/test6.c	/^static void *cfDlSym(sqlite3_vfs *pCfVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
cfFileControl	src/test6.c	/^static int cfFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
cfFileSize	src/test6.c	/^static int cfFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
cfFullPathname	src/test6.c	/^static int cfFullPathname($/;"	f	file:
cfGetTempname	src/test6.c	/^static int cfGetTempname(sqlite3_vfs *pCfVfs, int nBufOut, char *zBufOut){$/;"	f	file:
cfLock	src/test6.c	/^static int cfLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfOpen	src/test6.c	/^static int cfOpen($/;"	f	file:
cfRandomness	src/test6.c	/^static int cfRandomness(sqlite3_vfs *pCfVfs, int nByte, char *zBufOut){$/;"	f	file:
cfRead	src/test6.c	/^static int cfRead($/;"	f	file:
cfSectorSize	src/test6.c	/^static int cfSectorSize(sqlite3_file *pFile){$/;"	f	file:
cfSleep	src/test6.c	/^static int cfSleep(sqlite3_vfs *pCfVfs, int nMicro){$/;"	f	file:
cfSync	src/test6.c	/^static int cfSync(sqlite3_file *pFile, int flags){$/;"	f	file:
cfTruncate	src/test6.c	/^static int cfTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
cfUnlock	src/test6.c	/^static int cfUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfWrite	src/test6.c	/^static int cfWrite($/;"	f	file:
cfp	tool/lemon.c	/^  struct config *cfp;      \/* All configurations in this set *\/$/;"	m	struct:state	typeref:struct:state::config	file:
cfp	tool/lemon.c	/^  struct config *cfp;      \/* The configuration to which linked *\/$/;"	m	struct:plink	typeref:struct:plink::config	file:
chain	ext/fts1/fts1_hash.h	/^    fts1HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:fts1Hash::_fts1ht
chain	ext/fts2/fts2_hash.h	/^    fts2HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:fts2Hash::_fts2ht
chain	ext/fts3/fts3_hash.h	/^    fts3HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:fts3Hash::_fts3ht
chain	src/hash.h	/^    HashElem *chain;         \/* Pointer to first entry with this hash *\/$/;"	m	struct:Hash::_ht
changeCntOn	src/vdbeInt.h	/^  u8 changeCntOn;         \/* True to update the change-counter *\/$/;"	m	struct:Vdbe
changeCountDone	src/pager.c	/^  u8 changeCountDone;         \/* Set after incrementing the change-counter *\/$/;"	m	struct:Pager	file:
changeTempStorage	src/pragma.c	/^static int changeTempStorage(Parse *pParse, const char *zStorageType){$/;"	f	file:
changes	src/func.c	/^static void changes($/;"	f	file:
changes	src/sqlite3ext.h	/^  int  (*changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
channel	src/tclsqlite.c	/^  Tcl_Channel channel;      \/* Channel identifier *\/$/;"	m	struct:IncrblobChannel	file:
charMap	src/tokenize.c	32;"	d	file:
charMap	src/tokenize.c	35;"	d	file:
charset	src/printf.c	/^  etByte charset;          \/* Offset into aDigits[] of the digits string *\/$/;"	m	struct:et_info	file:
checkActiveVdbeCnt	src/vdbeaux.c	/^static void checkActiveVdbeCnt(sqlite3 *db){$/;"	f	file:
checkActiveVdbeCnt	src/vdbeaux.c	1363;"	d	file:
checkAppendMsg	src/btree.c	/^static void checkAppendMsg($/;"	f	file:
checkColumnOverLap	src/trigger.c	/^static int checkColumnOverLap(IdList *pIdList, ExprList *pEList){$/;"	f	file:
checkColumnSpecifier	ext/fts1/fts1.c	/^static int checkColumnSpecifier($/;"	f	file:
checkColumnSpecifier	ext/fts2/fts2.c	/^static int checkColumnSpecifier($/;"	f	file:
checkColumnSpecifier	ext/fts3/fts3.c	/^static int checkColumnSpecifier($/;"	f	file:
checkForMultiColumnSelectError	src/select.c	/^static int checkForMultiColumnSelectError($/;"	f	file:
checkList	src/btree.c	/^static void checkList($/;"	f	file:
checkPage	src/pager.c	/^static void checkPage(PgHdr *pPg){$/;"	f	file:
checkPtrmap	src/btree.c	/^static void checkPtrmap($/;"	f	file:
checkReadLocks	src/btree.c	/^static int checkReadLocks(Btree *pBtree, Pgno pgnoRoot, BtCursor *pExclude){$/;"	f	file:
checkRef	src/btree.c	/^static int checkRef(IntegrityCk *pCheck, int iPage, char *zContext){$/;"	f	file:
checkSchema	src/sqliteInt.h	/^  u8 checkSchema;      \/* Causes schema cookie check after an error *\/$/;"	m	struct:Parse
checkTreePage	src/btree.c	/^static int checkTreePage($/;"	f	file:
check_callback	test/threadtest2.c	/^int check_callback(void *pid, int argc, char **argv, char **notUsed2){$/;"	f
childPtrSize	src/btreeInt.h	/^  u8 childPtrSize;     \/* 0 if leaf==1.  4 if leaf==0 *\/$/;"	m	struct:MemPage
ckBase	src/sqliteInt.h	/^  int ckBase;          \/* Base register of data during check constraints *\/$/;"	m	struct:Parse
cksum	test/tester.tcl	/^proc cksum {{db db}} {$/;"	p
cksumInit	src/pager.c	/^  u32 cksumInit;              \/* Quasi-random value added to every checksum *\/$/;"	m	struct:Pager	file:
clearCell	src/btree.c	/^static int clearCell(MemPage *pPage, unsigned char *pCell){$/;"	f	file:
clearCursorPosition	src/btree.c	/^static void clearCursorPosition(BtCursor *pCur){$/;"	f	file:
clearDatabasePage	src/btree.c	/^static int clearDatabasePage($/;"	f	file:
clearHistory	src/pager.c	/^static void clearHistory(PgHistory *pHist){$/;"	f	file:
clearHistory	src/pager.c	2481;"	d	file:
clearPendingTerms	ext/fts2/fts2.c	/^static int clearPendingTerms(fulltext_vtab *v){$/;"	f	file:
clearPendingTerms	ext/fts3/fts3.c	/^static int clearPendingTerms(fulltext_vtab *v){$/;"	f	file:
clearSelect	src/select.c	/^static void clearSelect(Select *p){$/;"	f	file:
clearTableSpec	ext/fts1/fts1.c	/^static void clearTableSpec(TableSpec *p) {$/;"	f	file:
clearTableSpec	ext/fts2/fts2.c	/^static void clearTableSpec(TableSpec *p) {$/;"	f	file:
clearTableSpec	ext/fts3/fts3.c	/^static void clearTableSpec(TableSpec *p) {$/;"	f	file:
clearYMD_HMS_TZ	src/date.c	/^static void clearYMD_HMS_TZ(DateTime *p){$/;"	f	file:
clear_bindings	src/sqlite3ext.h	/^  int (*clear_bindings)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
clientMutex	src/test_server.c	/^  pthread_mutex_t clientMutex; \/* Hold this mutex to access the message *\/$/;"	m	struct:SqlMessage	file:
clientWakeup	src/test_server.c	/^  pthread_cond_t clientWakeup; \/* Signal to wake up the client *\/$/;"	m	struct:SqlMessage	file:
client_main	src/test7.c	/^static void *client_main(void *pArg){$/;"	f	file:
client_wait	src/test7.c	/^static void client_wait(Thread *p){$/;"	f	file:
close	src/sqlite3ext.h	/^  int  (*close)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
close	src/test_async.c	/^  AsyncWrite close;$/;"	m	struct:AsyncFileData	file:
closeAllCursorsExceptActiveVtabs	src/vdbeaux.c	/^static void closeAllCursorsExceptActiveVtabs(Vdbe *p){$/;"	f	file:
closeIncrblobChannels	src/tclsqlite.c	/^static void closeIncrblobChannels(SqliteDb *pDb){$/;"	f	file:
closeIncrblobChannels	src/tclsqlite.c	347;"	d	file:
cmd	parse.y	/^cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(Y). {$/;"	l
cmd	parse.y	/^cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {$/;"	l
cmd	parse.y	/^cmd ::= ANALYZE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}$/;"	l
cmd	parse.y	/^cmd ::= ANALYZE.                {sqlite3Analyze(pParse, 0, 0);}$/;"	l
cmd	parse.y	/^cmd ::= ATTACH database_kw_opt expr(F) AS expr(D) key_opt(K). {$/;"	l
cmd	parse.y	/^cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}$/;"	l
cmd	parse.y	/^cmd ::= COMMIT trans_opt.      {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= CREATE trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {$/;"	l
cmd	parse.y	/^cmd ::= CREATE(S) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)$/;"	l
cmd	parse.y	/^cmd ::= CREATE(X) temp(T) VIEW ifnotexists(E) nm(Y) dbnm(Z) AS select(S). {$/;"	l
cmd	parse.y	/^cmd ::= DELETE FROM fullname(X) where_opt(Y). {sqlite3DeleteFrom(pParse,X,Y);}$/;"	l
cmd	parse.y	/^cmd ::= DETACH database_kw_opt expr(D). {$/;"	l
cmd	parse.y	/^cmd ::= DROP INDEX ifexists(E) fullname(X).   {sqlite3DropIndex(pParse, X, E);}$/;"	l
cmd	parse.y	/^cmd ::= DROP TABLE ifexists(E) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP TRIGGER ifexists(NOERR) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP VIEW ifexists(E) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= END trans_opt.         {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ ON(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). {$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ nmnum(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP nmnum(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z).             {sqlite3Pragma(pParse,&X,&Z,0,0);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}$/;"	l
cmd	parse.y	/^cmd ::= ROLLBACK trans_opt.    {sqlite3RollbackTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= UPDATE orconf(R) fullname(X) SET setlist(Y) where_opt(Z).  {$/;"	l
cmd	parse.y	/^cmd ::= VACUUM nm.             {sqlite3Vacuum(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= VACUUM.                {sqlite3Vacuum(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= create_table create_table_args.$/;"	l
cmd	parse.y	/^cmd ::= create_vtab LP vtabarglist RP(X).  {sqlite3VtabFinishParse(pParse,&X);}$/;"	l
cmd	parse.y	/^cmd ::= create_vtab.                       {sqlite3VtabFinishParse(pParse,0);}$/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) $/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) DEFAULT VALUES.$/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) select(S).$/;"	l
cmd	parse.y	/^cmd ::= select(X).  {$/;"	l
cmd	src/parse.y	/^cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(Y). {$/;"	l
cmd	src/parse.y	/^cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {$/;"	l
cmd	src/parse.y	/^cmd ::= ANALYZE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}$/;"	l
cmd	src/parse.y	/^cmd ::= ANALYZE.                {sqlite3Analyze(pParse, 0, 0);}$/;"	l
cmd	src/parse.y	/^cmd ::= ATTACH database_kw_opt expr(F) AS expr(D) key_opt(K). {$/;"	l
cmd	src/parse.y	/^cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}$/;"	l
cmd	src/parse.y	/^cmd ::= COMMIT trans_opt.      {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	src/parse.y	/^cmd ::= CREATE trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {$/;"	l
cmd	src/parse.y	/^cmd ::= CREATE(S) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)$/;"	l
cmd	src/parse.y	/^cmd ::= CREATE(X) temp(T) VIEW ifnotexists(E) nm(Y) dbnm(Z) AS select(S). {$/;"	l
cmd	src/parse.y	/^cmd ::= DELETE FROM fullname(X) where_opt(Y). {sqlite3DeleteFrom(pParse,X,Y);}$/;"	l
cmd	src/parse.y	/^cmd ::= DETACH database_kw_opt expr(D). {$/;"	l
cmd	src/parse.y	/^cmd ::= DROP INDEX ifexists(E) fullname(X).   {sqlite3DropIndex(pParse, X, E);}$/;"	l
cmd	src/parse.y	/^cmd ::= DROP TABLE ifexists(E) fullname(X). {$/;"	l
cmd	src/parse.y	/^cmd ::= DROP TRIGGER ifexists(NOERR) fullname(X). {$/;"	l
cmd	src/parse.y	/^cmd ::= DROP VIEW ifexists(E) fullname(X). {$/;"	l
cmd	src/parse.y	/^cmd ::= END trans_opt.         {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	src/parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ ON(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	src/parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). {$/;"	l
cmd	src/parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ nmnum(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	src/parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP nmnum(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	src/parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z).             {sqlite3Pragma(pParse,&X,&Z,0,0);}$/;"	l
cmd	src/parse.y	/^cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}$/;"	l
cmd	src/parse.y	/^cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}$/;"	l
cmd	src/parse.y	/^cmd ::= ROLLBACK trans_opt.    {sqlite3RollbackTransaction(pParse);}$/;"	l
cmd	src/parse.y	/^cmd ::= UPDATE orconf(R) fullname(X) SET setlist(Y) where_opt(Z).  {$/;"	l
cmd	src/parse.y	/^cmd ::= VACUUM nm.             {sqlite3Vacuum(pParse);}$/;"	l
cmd	src/parse.y	/^cmd ::= VACUUM.                {sqlite3Vacuum(pParse);}$/;"	l
cmd	src/parse.y	/^cmd ::= create_table create_table_args.$/;"	l
cmd	src/parse.y	/^cmd ::= create_vtab LP vtabarglist RP(X).  {sqlite3VtabFinishParse(pParse,&X);}$/;"	l
cmd	src/parse.y	/^cmd ::= create_vtab.                       {sqlite3VtabFinishParse(pParse,0);}$/;"	l
cmd	src/parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) $/;"	l
cmd	src/parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) DEFAULT VALUES.$/;"	l
cmd	src/parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) select(S).$/;"	l
cmd	src/parse.y	/^cmd ::= select(X).  {$/;"	l
cmdlist	parse.y	/^cmdlist ::= cmdlist ecmd.$/;"	l
cmdlist	parse.y	/^cmdlist ::= ecmd.$/;"	l
cmdlist	src/parse.y	/^cmdlist ::= cmdlist ecmd.$/;"	l
cmdlist	src/parse.y	/^cmdlist ::= ecmd.$/;"	l
cmdx	parse.y	/^cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }$/;"	l
cmdx	src/parse.y	/^cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }$/;"	l
cnt	src/func.c	/^  i64 cnt;          \/* Number of elements summed *\/$/;"	m	struct:SumCtx	file:
cnt	src/mutex.c	/^  int cnt;    \/* Number of entries without a matching leave *\/$/;"	m	struct:sqlite3_mutex	file:
cnt	src/os_unix.c	/^  int cnt;             \/* Number of SHARED locks held *\/$/;"	m	struct:lockInfo	file:
cnt	src/shell.c	/^  int cnt;               \/* Number of records displayed so far *\/$/;"	m	struct:callback_data	file:
cnt	src/vdbe.h	/^  int cnt;            \/* Number of times this instruction was executed *\/$/;"	m	struct:VdbeOp
code	tool/lemon.c	/^  char *code;              \/* The code executed when this rule is reduced *\/$/;"	m	struct:rule	file:
codeAllEqualityTerms	src/where.c	/^static int codeAllEqualityTerms($/;"	f	file:
codeAttach	src/attach.c	/^static void codeAttach($/;"	f	file:
codeCompare	src/expr.c	/^static int codeCompare($/;"	f	file:
codeDistinct	src/select.c	/^static void codeDistinct($/;"	f	file:
codeEqualityTerm	src/where.c	/^static void codeEqualityTerm($/;"	f	file:
codeInteger	src/expr.c	/^static void codeInteger(Vdbe *v, const char *z, int n, int negFlag, int iMem){$/;"	f	file:
codeOffset	src/select.c	/^static void codeOffset($/;"	f	file:
codeReal	src/expr.c	/^static void codeReal(Vdbe *v, const char *z, int n, int negateFlag, int iMem){$/;"	f	file:
codeTableLocks	src/build.c	/^static void codeTableLocks(Parse *pParse){$/;"	f	file:
codeTableLocks	src/build.c	121;"	d	file:
codeTriggerProgram	src/trigger.c	/^static int codeTriggerProgram($/;"	f	file:
colNamesSet	src/sqliteInt.h	/^  u8 colNamesSet;      \/* TRUE after OP_ColumnName has been issued to pVdbe *\/$/;"	m	struct:Parse
colUsed	src/sqliteInt.h	/^    Bitmask colUsed;  \/* Bit N (1<<N) set if column N or pTab is used *\/$/;"	m	struct:SrcList::SrcList_item
colWidth	src/shell.c	/^  int colWidth[100];     \/* Requested width of each column when in column mode*\/$/;"	m	struct:callback_data	file:
colWidth	src/shell.c	/^  int colWidth[100];$/;"	m	struct:previous_mode_data	file:
collationMatch	src/build.c	/^static int collationMatch(const char *zColl, Index *pIndex){$/;"	f	file:
collation_needed	src/sqlite3ext.h	/^  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const char*));$/;"	m	struct:sqlite3_api_routines
collation_needed16	src/sqlite3ext.h	/^  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const void*));$/;"	m	struct:sqlite3_api_routines
collide	tool/lemon.c	/^  struct action *collide;  \/* Next action with the same hash *\/$/;"	m	struct:action	typeref:struct:action::action	file:
columnIndex	src/select.c	/^static int columnIndex(Table *pTab, const char *zCol){$/;"	f	file:
columnMallocFailure	src/vdbeapi.c	/^static void columnMallocFailure(sqlite3_stmt *pStmt)$/;"	f	file:
columnMem	src/vdbeapi.c	/^static Mem *columnMem(sqlite3_stmt *pStmt, int i){$/;"	f	file:
columnName	src/vdbeapi.c	/^static const void *columnName($/;"	f	file:
columnType	src/select.c	/^static const char *columnType($/;"	f	file:
column_blob	src/sqlite3ext.h	/^  const void * (*column_blob)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes	src/sqlite3ext.h	/^  int  (*column_bytes)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes16	src/sqlite3ext.h	/^  int  (*column_bytes16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_count	src/sqlite3ext.h	/^  int  (*column_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
column_database_name	src/sqlite3ext.h	/^  const char * (*column_database_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_database_name16	src/sqlite3ext.h	/^  const void * (*column_database_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_decltype	src/sqlite3ext.h	/^  const char * (*column_decltype)(sqlite3_stmt*,int i);$/;"	m	struct:sqlite3_api_routines
column_decltype16	src/sqlite3ext.h	/^  const void * (*column_decltype16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_double	src/sqlite3ext.h	/^  double  (*column_double)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int	src/sqlite3ext.h	/^  int  (*column_int)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int64	src/sqlite3ext.h	/^  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_name	src/sqlite3ext.h	/^  const char * (*column_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_name16	src/sqlite3ext.h	/^  const void * (*column_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name	src/sqlite3ext.h	/^  const char * (*column_origin_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name16	src/sqlite3ext.h	/^  const void * (*column_origin_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name	src/sqlite3ext.h	/^  const char * (*column_table_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name16	src/sqlite3ext.h	/^  const void * (*column_table_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_text	src/sqlite3ext.h	/^  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_text16	src/sqlite3ext.h	/^  const void * (*column_text16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_type	src/sqlite3ext.h	/^  int  (*column_type)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_value	src/sqlite3ext.h	/^  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
columnlist	parse.y	/^columnlist ::= column.$/;"	l
columnlist	parse.y	/^columnlist ::= columnlist COMMA column.$/;"	l
columnlist	src/parse.y	/^columnlist ::= column.$/;"	l
columnlist	src/parse.y	/^columnlist ::= columnlist COMMA column.$/;"	l
colv	src/test4.c	/^  const char *colv[100];    \/* result column names *\/$/;"	m	struct:Thread	file:
colv	src/test7.c	/^  const char *colv[100];   \/* result column names *\/$/;"	m	struct:Thread	file:
commit_hook	src/sqlite3ext.h	/^  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
compare2pow63	src/util.c	/^static int compare2pow63(const char *zNum){$/;"	f	file:
compareFunction	ext/fts1/fts1_hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareFunction	ext/fts2/fts2_hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareFunction	src/hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareInfo	src/func.c	/^struct compareInfo {$/;"	s	file:
comparisonAffinity	src/expr.c	/^static char comparisonAffinity(Expr *pExpr){$/;"	f	file:
complete	src/sqlite3ext.h	/^  int  (*complete)(const char*sql);$/;"	m	struct:sqlite3_api_routines
complete16	src/sqlite3ext.h	/^  int  (*complete16)(const void*sql);$/;"	m	struct:sqlite3_api_routines
completed	src/test4.c	/^  int completed;        \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
completed	src/test7.c	/^  volatile int completed;  \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
computeColumnNames	src/tclsqlite.c	/^computeColumnNames($/;"	f	file:
computeHMS	src/date.c	/^static void computeHMS(DateTime *p){$/;"	f	file:
computeJD	src/date.c	/^static void computeJD(DateTime *p){$/;"	f	file:
computeLimitRegisters	src/select.c	/^static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){$/;"	f	file:
computeYMD	src/date.c	/^static void computeYMD(DateTime *p){$/;"	f	file:
computeYMD_HMS	src/date.c	/^static void computeYMD_HMS(DateTime *p){$/;"	f	file:
compute_action	tool/lemon.c	/^PRIVATE int compute_action(lemp,ap)$/;"	f
config	tool/lemon.c	/^struct config {$/;"	s	file:
confighash	tool/lemon.c	/^PRIVATE int confighash(a)$/;"	f
conslist	parse.y	/^conslist ::= conslist COMMA tcons.$/;"	l
conslist	parse.y	/^conslist ::= conslist tcons.$/;"	l
conslist	parse.y	/^conslist ::= tcons.$/;"	l
conslist	src/parse.y	/^conslist ::= conslist COMMA tcons.$/;"	l
conslist	src/parse.y	/^conslist ::= conslist tcons.$/;"	l
conslist	src/parse.y	/^conslist ::= tcons.$/;"	l
constructVtab	ext/fts1/fts1.c	/^static int constructVtab($/;"	f	file:
constructVtab	ext/fts2/fts2.c	/^static int constructVtab($/;"	f	file:
constructVtab	ext/fts3/fts3.c	/^static int constructVtab($/;"	f	file:
cont	src/sqliteInt.h	/^  int cont;             \/* Jump here to continue with the next loop cycle *\/$/;"	m	struct:WhereLevel
contentInsertStatement	ext/fts1/fts1.c	/^static const char *contentInsertStatement(fulltext_vtab *v){$/;"	f	file:
contentInsertStatement	ext/fts2/fts2.c	/^static const char *contentInsertStatement(fulltext_vtab *v){$/;"	f	file:
contentInsertStatement	ext/fts3/fts3.c	/^static const char *contentInsertStatement(fulltext_vtab *v){$/;"	f	file:
contentSelectStatement	ext/fts3/fts3.c	/^static const char *contentSelectStatement(fulltext_vtab *v){$/;"	f	file:
contentUpdateStatement	ext/fts1/fts1.c	/^static const char *contentUpdateStatement(fulltext_vtab *v){$/;"	f	file:
contentUpdateStatement	ext/fts2/fts2.c	/^static const char *contentUpdateStatement(fulltext_vtab *v){$/;"	f	file:
contentUpdateStatement	ext/fts3/fts3.c	/^static const char *contentUpdateStatement(fulltext_vtab *v){$/;"	f	file:
content_delete	ext/fts1/fts1.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
content_delete	ext/fts2/fts2.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
content_delete	ext/fts3/fts3.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iDocid){$/;"	f	file:
content_insert	ext/fts1/fts1.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,$/;"	f	file:
content_insert	ext/fts2/fts2.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,$/;"	f	file:
content_insert	ext/fts3/fts3.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *docid,$/;"	f	file:
content_select	ext/fts1/fts1.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
content_select	ext/fts2/fts2.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
content_select	ext/fts3/fts3.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iDocid,$/;"	f	file:
content_update	ext/fts1/fts1.c	/^static int content_update(fulltext_vtab *v, sqlite3_value **pValues,$/;"	f	file:
content_update	ext/fts2/fts2.c	/^static int content_update(fulltext_vtab *v, sqlite3_value **pValues,$/;"	f	file:
content_update	ext/fts3/fts3.c	/^static int content_update(fulltext_vtab *v, sqlite3_value **pValues,$/;"	f	file:
contextMalloc	src/func.c	/^static void *contextMalloc(sqlite3_context *context, int nByte){$/;"	f	file:
contextStack	src/vdbeInt.h	/^  Context *contextStack;  \/* Stack used by opcodes ContextPush & ContextPop*\/$/;"	m	struct:Vdbe
contextStackDepth	src/vdbeInt.h	/^  int contextStackDepth;  \/* The size of the "context" stack *\/$/;"	m	struct:Vdbe
contextStackTop	src/vdbeInt.h	/^  int contextStackTop;    \/* Index of top element in the context stack *\/$/;"	m	struct:Vdbe
continuePrompt	src/shell.c	/^static char continuePrompt[20]; \/* Continuation prompt. default: "   ...> " *\/$/;"	v	file:
convertUtf8Filename	src/os_win.c	/^static void *convertUtf8Filename(const char *zFilename){$/;"	f	file:
cookieGoto	src/sqliteInt.h	/^  int cookieGoto;      \/* Address of OP_Goto to cookie verifier subroutine *\/$/;"	m	struct:Parse
cookieMask	src/sqliteInt.h	/^  u32 cookieMask;      \/* Bitmask of schema verified databases *\/$/;"	m	struct:Parse
cookieValue	src/sqliteInt.h	/^  int cookieValue[SQLITE_MAX_ATTACHED+2];  \/* Values of cookies to verify *\/$/;"	m	struct:Parse
copyKey	ext/fts1/fts1_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:fts1Hash
copyKey	ext/fts2/fts2_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:fts2Hash
copyKey	ext/fts3/fts3_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:fts3Hash
copyKey	src/hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:Hash
copyPayload	src/btree.c	/^static int copyPayload($/;"	f	file:
copy_file	ext/fts2/mkfts2amal.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	ext/fts3/mkfts3amal.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	test/tester.tcl	/^proc copy_file {from to} {$/;"	p
copy_file	tool/mksqlite3c.tcl	/^proc copy_file {filename} {$/;"	p
copy_stemmer	ext/fts1/fts1_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
copy_stemmer	ext/fts2/fts2_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
copy_stemmer	ext/fts3/fts3_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
corruptSchema	src/prepare.c	/^static void corruptSchema(InitData *pData, const char *zExtra){$/;"	f	file:
count	ext/fts1/fts1_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:fts1Hash::_fts1ht
count	ext/fts1/fts1_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:fts1Hash
count	ext/fts2/fts2_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:fts2Hash::_fts2ht
count	ext/fts2/fts2_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:fts2Hash
count	ext/fts3/fts3_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:fts3Hash::_fts3ht
count	ext/fts3/fts3_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:fts3Hash
count	src/hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:Hash::_ht
count	src/hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:Hash
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x1	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x2	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x3	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x4	file:
countFinalize	src/func.c	/^static void countFinalize(sqlite3_context *context){$/;"	f	file:
countStep	src/func.c	/^static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
countWriteCursors	src/btree.c	/^static int countWriteCursors(BtShared *pBt){$/;"	f	file:
crashAppData	src/test6.c	/^struct crashAppData {$/;"	s	file:
crashEnableCmd	src/test6.c	/^static int crashEnableCmd($/;"	f	file:
crashParamsObjCmd	src/test6.c	/^static int crashParamsObjCmd($/;"	f	file:
crash_free	src/test6.c	/^static void crash_free(void *p){$/;"	f	file:
crash_malloc	src/test6.c	/^static void *crash_malloc(int nByte){$/;"	f	file:
crash_realloc	src/test6.c	/^static void *crash_realloc(void *p, int n){$/;"	f	file:
crashsql	test/tester.tcl	/^proc crashsql {args} {$/;"	p
createCollation	src/main.c	/^static int createCollation($/;"	f	file:
createFile	src/journal.c	/^static int createFile(JournalFile *p){$/;"	f	file:
createIncrblobChannel	src/tclsqlite.c	/^static int createIncrblobChannel($/;"	f	file:
createMask	src/where.c	/^static void createMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
createModule	src/vtab.c	/^static int createModule($/;"	f	file:
createSortingIndex	src/select.c	/^static void createSortingIndex(Parse *pParse, Select *p, ExprList *pOrderBy){$/;"	f	file:
createTableStmt	src/build.c	/^static char *createTableStmt(sqlite3 *db, Table *p, int isTemp){$/;"	f	file:
createVarMap	src/vdbeapi.c	/^static void createVarMap(Vdbe *p){$/;"	f	file:
create_collation	src/sqlite3ext.h	/^  int  (*create_collation)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));$/;"	m	struct:sqlite3_api_routines
create_collation16	src/sqlite3ext.h	/^  int  (*create_collation16)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));$/;"	m	struct:sqlite3_api_routines
create_collation_v2	src/sqlite3ext.h	/^  int (*create_collation_v2)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*),void(*)(void*));$/;"	m	struct:sqlite3_api_routines
create_function	src/sqlite3ext.h	/^  int  (*create_function)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));$/;"	m	struct:sqlite3_api_routines
create_function16	src/sqlite3ext.h	/^  int  (*create_function16)(sqlite3*,const void*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));$/;"	m	struct:sqlite3_api_routines
create_module	src/sqlite3ext.h	/^  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);$/;"	m	struct:sqlite3_api_routines
create_module_v2	src/sqlite3ext.h	/^  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy)(void *));$/;"	m	struct:sqlite3_api_routines
create_table	parse.y	/^create_table ::= CREATE temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {$/;"	l
create_table	src/parse.y	/^create_table ::= CREATE temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= AS select(S). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= LP columnlist conslist_opt(X) RP(Y). {$/;"	l
create_table_args	src/parse.y	/^create_table_args ::= AS select(S). {$/;"	l
create_table_args	src/parse.y	/^create_table_args ::= LP columnlist conslist_opt(X) RP(Y). {$/;"	l
create_vtab	parse.y	/^create_vtab ::= CREATE VIRTUAL TABLE nm(X) dbnm(Y) USING nm(Z). {$/;"	l
create_vtab	src/parse.y	/^create_vtab ::= CREATE VIRTUAL TABLE nm(X) dbnm(Y) USING nm(Z). {$/;"	l
ctimeFunc	src/date.c	/^static void ctimeFunc($/;"	f	file:
ctimestampFunc	src/date.c	/^static void ctimestampFunc($/;"	f	file:
cubeFunc	src/test_autoext.c	/^static void cubeFunc($/;"	f	file:
cube_init	src/test_autoext.c	/^static int cube_init($/;"	f	file:
current	tool/lemon.c	/^static struct config *current = 0;       \/* Top of list of configurations *\/$/;"	v	typeref:struct:config	file:
currentTimeFunc	src/date.c	/^static void currentTimeFunc($/;"	f	file:
currentend	tool/lemon.c	/^static struct config **currentend = 0;   \/* Last on list of configs *\/$/;"	v	typeref:struct:config	file:
cursorHoldsMutex	src/btree.c	/^static int cursorHoldsMutex(BtCursor *p){$/;"	f	file:
cursor_info	tool/fragck.tcl	/^proc cursor_info {arrayvar csr {up 0}} {$/;"	p
cursor_info	tool/spaceanal.tcl	/^proc cursor_info {arrayvar csr {up 0}} {$/;"	p
cursor_vtab	ext/fts1/fts1.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
cursor_vtab	ext/fts2/fts2.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
cursor_vtab	ext/fts3/fts3.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
cycles	src/vdbe.h	/^  long long cycles;   \/* Total time spend executing this instruction *\/$/;"	m	struct:VdbeOp
data	ext/fts1/fts1_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:fts1HashElem
data	ext/fts2/fts2.c	/^  DataBuffer data;                \/* encoding buffer *\/$/;"	m	struct:LeafWriter	file:
data	ext/fts2/fts2.c	/^  DataBuffer data;           \/* Accumulated data for the block. *\/$/;"	m	struct:InteriorBlock	file:
data	ext/fts2/fts2_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:fts2HashElem
data	ext/fts3/fts3.c	/^  DataBuffer data;                \/* encoding buffer *\/$/;"	m	struct:LeafWriter	file:
data	ext/fts3/fts3.c	/^  DataBuffer data;           \/* Accumulated data for the block. *\/$/;"	m	struct:InteriorBlock	file:
data	ext/fts3/fts3_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:fts3HashElem
data	src/hash.h	/^  void *data;              \/* Data associated with this element *\/$/;"	m	struct:HashElem
data	tool/lemon.c	/^  char *data;                  \/* The data *\/$/;"	m	struct:s_x1node	file:
data	tool/lemon.c	/^  struct config *data;                  \/* The data *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::config	file:
data	tool/lemon.c	/^  struct state *data;                  \/* The data *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::state	file:
data	tool/lemon.c	/^  struct symbol *data;                  \/* The data *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::symbol	file:
dataBufferAppend	ext/fts2/fts2.c	/^static void dataBufferAppend(DataBuffer *pBuffer,$/;"	f	file:
dataBufferAppend	ext/fts3/fts3.c	/^static void dataBufferAppend(DataBuffer *pBuffer,$/;"	f	file:
dataBufferAppend2	ext/fts2/fts2.c	/^static void dataBufferAppend2(DataBuffer *pBuffer,$/;"	f	file:
dataBufferAppend2	ext/fts3/fts3.c	/^static void dataBufferAppend2(DataBuffer *pBuffer,$/;"	f	file:
dataBufferDestroy	ext/fts2/fts2.c	/^static void dataBufferDestroy(DataBuffer *pBuffer){$/;"	f	file:
dataBufferDestroy	ext/fts3/fts3.c	/^static void dataBufferDestroy(DataBuffer *pBuffer){$/;"	f	file:
dataBufferExpand	ext/fts2/fts2.c	/^static void dataBufferExpand(DataBuffer *pBuffer, int nAddCapacity){$/;"	f	file:
dataBufferExpand	ext/fts3/fts3.c	/^static void dataBufferExpand(DataBuffer *pBuffer, int nAddCapacity){$/;"	f	file:
dataBufferInit	ext/fts2/fts2.c	/^static void dataBufferInit(DataBuffer *pBuffer, int nCapacity){$/;"	f	file:
dataBufferInit	ext/fts3/fts3.c	/^static void dataBufferInit(DataBuffer *pBuffer, int nCapacity){$/;"	f	file:
dataBufferReplace	ext/fts2/fts2.c	/^static void dataBufferReplace(DataBuffer *pBuffer,$/;"	f	file:
dataBufferReplace	ext/fts3/fts3.c	/^static void dataBufferReplace(DataBuffer *pBuffer,$/;"	f	file:
dataBufferReset	ext/fts2/fts2.c	/^static void dataBufferReset(DataBuffer *pBuffer){$/;"	f	file:
dataBufferReset	ext/fts3/fts3.c	/^static void dataBufferReset(DataBuffer *pBuffer){$/;"	f	file:
dataBufferSwap	ext/fts3/fts3.c	/^static void dataBufferSwap(DataBuffer *pBuffer1, DataBuffer *pBuffer2){$/;"	f	file:
data_count	src/sqlite3ext.h	/^  int  (*data_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
database_kw_opt	parse.y	/^database_kw_opt ::= .$/;"	l
database_kw_opt	parse.y	/^database_kw_opt ::= DATABASE.$/;"	l
database_kw_opt	src/parse.y	/^database_kw_opt ::= .$/;"	l
database_kw_opt	src/parse.y	/^database_kw_opt ::= DATABASE.$/;"	l
datatype	tool/lemon.c	/^  char *datatype;          \/* The data type of information held by this$/;"	m	struct:symbol	file:
dateFunc	src/date.c	/^static void dateFunc($/;"	f	file:
datetimeFunc	src/date.c	/^static void datetimeFunc($/;"	f	file:
db	ext/fts1/fts1.c	/^  sqlite3 *db;                     \/* The database connection *\/$/;"	m	struct:fulltext_vtab	file:
db	ext/fts2/fts2.c	/^  sqlite3 *db;                     \/* The database connection *\/$/;"	m	struct:fulltext_vtab	file:
db	ext/fts3/fts3.c	/^  sqlite3 *db;                     \/* The database connection *\/$/;"	m	struct:fulltext_vtab	file:
db	src/analyze.c	/^  sqlite3 *db;$/;"	m	struct:analysisInfo	file:
db	src/btreeInt.h	/^  sqlite3 *db;          \/* Database connection currently using this Btree *\/$/;"	m	struct:BtShared
db	src/btreeInt.h	/^  sqlite3 *db;       \/* The database connection holding this btree *\/$/;"	m	struct:Btree
db	src/shell.c	/^  sqlite3 *db;            \/* The database *\/$/;"	m	struct:callback_data	file:
db	src/shell.c	/^static sqlite3 *db = 0;$/;"	v	file:
db	src/sqliteInt.h	/^  sqlite3 *db;         \/* "Owner" connection. See comment above *\/$/;"	m	struct:Schema
db	src/sqliteInt.h	/^  sqlite3 *db;         \/* The main database structure *\/$/;"	m	struct:Parse
db	src/sqliteInt.h	/^  sqlite3 *db;        \/* The database being initialized *\/$/;"	m	struct:__anon14
db	src/sqliteInt.h	/^  sqlite3 *db;        \/* The database connection *\/$/;"	m	struct:KeyInfo
db	src/tclsqlite.c	/^  sqlite3 *db;               \/* The "real" database structure. MUST BE FIRST *\/$/;"	m	struct:SqliteDb	file:
db	src/test1.c	/^  sqlite3 *db;$/;"	m	struct:SqliteDb	file:
db	src/test4.c	/^  sqlite3 *db;           \/* Open database *\/$/;"	m	struct:Thread	file:
db	src/test7.c	/^  sqlite3 *db;             \/* Open database *\/$/;"	m	struct:Thread	file:
db	src/test8.c	/^  sqlite3 *db;            \/* Database connection *\/$/;"	m	struct:echo_vtab	file:
db	src/test_schema.c	/^  sqlite3 *db;$/;"	m	struct:schema_vtab	file:
db	src/vdbeInt.h	/^  sqlite3 *db;        \/* The associated database connection *\/$/;"	m	struct:Mem
db	src/vdbeInt.h	/^  sqlite3 *db;        \/* The whole database *\/$/;"	m	struct:Vdbe
db	src/vdbeblob.c	/^  sqlite3 *db;            \/* The associated database *\/$/;"	m	struct:Incrblob	file:
db	tool/showdb.c	/^static int db = -1;$/;"	v	file:
db	tool/showjournal.c	/^static int db = -1;$/;"	v	file:
db1	tool/diffdb.c	/^static int db1 = -1;$/;"	v	file:
db2	tool/diffdb.c	/^static int db2 = -1;$/;"	v	file:
dbFileVers	src/pager.c	/^  char dbFileVers[16];        \/* Changes whenever database file changes *\/$/;"	m	struct:Pager	file:
dbSize	src/pager.c	/^  int dbSize;                 \/* Number of pages in the file *\/$/;"	m	struct:Pager	file:
dbTextToObj	src/tclsqlite.c	/^static Tcl_Obj *dbTextToObj(char const *zText){$/;"	f	file:
db_check	test/threadtest1.c	/^void db_check(const char *zFile, const char *zMsg, char **az, ...){$/;"	f
db_enter	src/test1.c	/^static int db_enter($/;"	f	file:
db_execute	test/threadtest1.c	/^void db_execute(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_handle	src/sqlite3ext.h	/^  sqlite3 * (*db_handle)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
db_is_locked	test/threadtest1.c	/^static int db_is_locked(void *NotUsed, int iCount){$/;"	f	file:
db_leave	src/test1.c	/^static int db_leave($/;"	f	file:
db_query	test/threadtest1.c	/^char **db_query(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_query_callback	test/threadtest1.c	/^static int db_query_callback($/;"	f	file:
db_query_free	test/threadtest1.c	/^void db_query_free(char **az){$/;"	f
declareVtab	src/sqliteInt.h	/^  u8 declareVtab;            \/* True if inside sqlite3_declare_vtab() *\/$/;"	m	struct:Parse
declare_vtab	src/sqlite3ext.h	/^  int (*declare_vtab)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
declare_vtab	src/test8.c	/^static int declare_vtab($/;"	f	file:
declargslot	tool/lemon.c	/^  char **declargslot;        \/* Where the declaration argument should be put *\/$/;"	m	struct:pstate	file:
declassoc	tool/lemon.c	/^  enum e_assoc declassoc;    \/* Assign this association to decl arguments *\/$/;"	m	struct:pstate	typeref:enum:pstate::e_assoc	file:
declkeyword	tool/lemon.c	/^  char *declkeyword;         \/* Keyword of a declaration *\/$/;"	m	struct:pstate	file:
decllnslot	tool/lemon.c	/^  int *decllnslot;           \/* Where the declaration linenumber is put *\/$/;"	m	struct:pstate	file:
decodeFlags	src/btree.c	/^static void decodeFlags(MemPage *pPage, int flagByte){$/;"	f	file:
deferredMoveto	src/vdbeInt.h	/^  Bool deferredMoveto;  \/* A call to sqlite3BtreeMoveto() is needed *\/$/;"	m	struct:Cursor
defragmentPage	src/btree.c	/^static int defragmentPage(MemPage *pPage){$/;"	f	file:
delOnClose	src/os_os2.c	/^  int delOnClose;           \/* True if file is to be deleted on close *\/$/;"	m	struct:os2File	file:
deleteConf	src/sqliteInt.h	/^  u8 deleteConf;    \/* How to resolve conflicts that occur on DELETE *\/$/;"	m	struct:FKey
deleteTerms	ext/fts1/fts1.c	/^static int deleteTerms(fulltext_vtab *v, fts1Hash *pTerms, sqlite_int64 iRowid){$/;"	f	file:
deleteTerms	ext/fts2/fts2.c	/^static int deleteTerms(fulltext_vtab *v, sqlite_int64 iRowid){$/;"	f	file:
deleteTerms	ext/fts3/fts3.c	/^static int deleteTerms(fulltext_vtab *v, sqlite_int64 iDocid){$/;"	f	file:
delete_collation	src/test1.c	/^static int delete_collation($/;"	f	file:
delete_function	src/test1.c	/^static int delete_function($/;"	f	file:
deleteconfig	tool/lemon.c	/^PRIVATE void deleteconfig(old)$/;"	f
delim	ext/fts1/fts1_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
delim	ext/fts2/fts2_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
delim	ext/fts3/fts3_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
dequoteString	ext/fts1/fts1.c	/^static void dequoteString(char *z){$/;"	f	file:
dequoteString	ext/fts2/fts2.c	/^static void dequoteString(char *z){$/;"	f	file:
dequoteString	ext/fts3/fts3.c	/^static void dequoteString(char *z){$/;"	f	file:
dequoteString	src/test8.c	/^static void dequoteString(char *z){$/;"	f	file:
desc	sqlite3.h	/^     unsigned char desc;       \/* True for DESC.  False for ASC. *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_orderby
destroyRootPage	src/build.c	/^static void destroyRootPage(Parse *pParse, int iTable, int iDb){$/;"	f	file:
destroyTable	src/build.c	/^static void destroyTable(Parse *pParse, Table *pTab){$/;"	f	file:
destructor	src/func.c	/^static void destructor(void *p){$/;"	f	file:
destructor	tool/lemon.c	/^  char *destructor;        \/* Code which executes whenever this symbol is$/;"	m	struct:symbol	file:
destructorln	tool/lemon.c	/^  int destructorln;        \/* Line number of destructor code *\/$/;"	m	struct:symbol	file:
detachFunc	src/attach.c	/^static void detachFunc($/;"	f	file:
dev	src/os_unix.c	/^  dev_t dev;       \/* Device number *\/$/;"	m	struct:lockKey	file:
dev	src/os_unix.c	/^  dev_t dev;   \/* Device number *\/$/;"	m	struct:openKey	file:
devSymObjCmd	src/test6.c	/^static int devSymObjCmd($/;"	f	file:
devsymAccess	src/test_devsym.c	/^static int devsymAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
devsymCheckReservedLock	src/test_devsym.c	/^static int devsymCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
devsymClose	src/test_devsym.c	/^static int devsymClose(sqlite3_file *pFile){$/;"	f	file:
devsymCurrentTime	src/test_devsym.c	/^static int devsymCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
devsymDelete	src/test_devsym.c	/^static int devsymDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
devsymDeviceCharacteristics	src/test_devsym.c	/^static int devsymDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
devsymDlClose	src/test_devsym.c	/^static void devsymDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
devsymDlError	src/test_devsym.c	/^static void devsymDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
devsymDlOpen	src/test_devsym.c	/^static void *devsymDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
devsymDlSym	src/test_devsym.c	/^static void *devsymDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
devsymFileControl	src/test_devsym.c	/^static int devsymFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
devsymFileSize	src/test_devsym.c	/^static int devsymFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
devsymFullPathname	src/test_devsym.c	/^static int devsymFullPathname($/;"	f	file:
devsymGetTempName	src/test_devsym.c	/^static int devsymGetTempName(sqlite3_vfs *pVfs, int nOut, char *zBufOut){$/;"	f	file:
devsymLock	src/test_devsym.c	/^static int devsymLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymOpen	src/test_devsym.c	/^static int devsymOpen($/;"	f	file:
devsymRandomness	src/test_devsym.c	/^static int devsymRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
devsymRead	src/test_devsym.c	/^static int devsymRead($/;"	f	file:
devsymSectorSize	src/test_devsym.c	/^static int devsymSectorSize(sqlite3_file *pFile){$/;"	f	file:
devsymSleep	src/test_devsym.c	/^static int devsymSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
devsymSync	src/test_devsym.c	/^static int devsymSync(sqlite3_file *pFile, int flags){$/;"	f	file:
devsymTruncate	src/test_devsym.c	/^static int devsymTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
devsymUnlock	src/test_devsym.c	/^static int devsymUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymWrite	src/test_devsym.c	/^static int devsymWrite($/;"	f	file:
devsym_file	src/test_devsym.c	/^struct devsym_file {$/;"	s	file:
devsym_file	src/test_devsym.c	/^typedef struct devsym_file devsym_file;$/;"	t	typeref:struct:devsym_file	file:
devsym_io_methods	src/test_devsym.c	/^static sqlite3_io_methods devsym_io_methods = {$/;"	v	file:
devsym_register	src/test_devsym.c	/^void devsym_register(int iDeviceChar, int iSectorSize){$/;"	f
devsym_vfs	src/test_devsym.c	/^static sqlite3_vfs devsym_vfs = {$/;"	v	file:
dfltColumn	ext/fts1/fts1.c	/^  int dfltColumn;       \/* The default column *\/$/;"	m	struct:Query	file:
dfltColumn	ext/fts2/fts2.c	/^  int dfltColumn;       \/* The default column *\/$/;"	m	struct:Query	file:
dfltColumn	ext/fts3/fts3.c	/^  int dfltColumn;       \/* The default column *\/$/;"	m	struct:Query	file:
dfltCompare	src/btree.c	/^static int dfltCompare($/;"	f	file:
dfltLockMode	src/sqliteInt.h	/^  u8 dfltLockMode;              \/* Default locking-mode for attached dbs *\/$/;"	m	struct:sqlite3
directMode	src/sqliteInt.h	/^  u8 directMode;          \/* Direct rendering mode means take data directly$/;"	m	struct:AggInfo
dirfd	src/os_unix.c	/^  int dirfd;                \/* File descriptor for the directory *\/$/;"	m	struct:unixFile	file:
dirty	src/pager.c	/^  u8 dirty;                      \/* TRUE if we need to write back changes *\/$/;"	m	struct:PgHdr	file:
dirtyCache	src/pager.c	/^  u8 dirtyCache;              \/* True if cached pages have changed *\/$/;"	m	struct:Pager	file:
disableTerm	src/where.c	/^static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){$/;"	f	file:
disable_simulated_io_errors	src/pager.c	/^void disable_simulated_io_errors(void){$/;"	f
disable_simulated_io_errors	src/pager.c	2396;"	d	file:
disable_simulated_io_errors	src/pager.h	122;"	d
disallow	src/mem2.c	/^  int disallow; \/* Do not allow memory allocation *\/$/;"	m	struct:__anon16	file:
disallowOrderBy	src/sqliteInt.h	/^  u8 disallowOrderBy;    \/* Do not allow an ORDER BY to be attached if TRUE *\/$/;"	m	struct:Select
displayP4	src/vdbeaux.c	/^static char *displayP4(Op *pOp, char *zTemp, int nTemp){$/;"	f	file:
divide	tool/spaceanal.tcl	/^proc divide {num denom} {$/;"	p
dlcAddDoclist	ext/fts2/fts2.c	/^static void dlcAddDoclist(DLCollector *pCollector, DataBuffer *b){$/;"	f	file:
dlcAddDoclist	ext/fts3/fts3.c	/^static void dlcAddDoclist(DLCollector *pCollector, DataBuffer *b){$/;"	f	file:
dlcAddPos	ext/fts2/fts2.c	/^static void dlcAddPos(DLCollector *pCollector, int iColumn, int iPos,$/;"	f	file:
dlcAddPos	ext/fts3/fts3.c	/^static void dlcAddPos(DLCollector *pCollector, int iColumn, int iPos,$/;"	f	file:
dlcDelete	ext/fts2/fts2.c	/^static void dlcDelete(DLCollector *pCollector){$/;"	f	file:
dlcDelete	ext/fts3/fts3.c	/^static void dlcDelete(DLCollector *pCollector){$/;"	f	file:
dlcNew	ext/fts2/fts2.c	/^static DLCollector *dlcNew(sqlite_int64 iDocid, DocListType iType){$/;"	f	file:
dlcNew	ext/fts3/fts3.c	/^static DLCollector *dlcNew(sqlite_int64 iDocid, DocListType iType){$/;"	f	file:
dlcNext	ext/fts2/fts2.c	/^static void dlcNext(DLCollector *pCollector, sqlite_int64 iDocid){$/;"	f	file:
dlcNext	ext/fts3/fts3.c	/^static void dlcNext(DLCollector *pCollector, sqlite_int64 iDocid){$/;"	f	file:
dld_link	configure	/^dld_link ();$/;"	f
dlopen	configure	/^dlopen ();$/;"	f
dlrAllDataBytes	ext/fts2/fts2.c	/^static int dlrAllDataBytes(DLReader *pReader){$/;"	f	file:
dlrAllDataBytes	ext/fts3/fts3.c	/^static int dlrAllDataBytes(DLReader *pReader){$/;"	f	file:
dlrAtEnd	ext/fts2/fts2.c	/^static int dlrAtEnd(DLReader *pReader){$/;"	f	file:
dlrAtEnd	ext/fts3/fts3.c	/^static int dlrAtEnd(DLReader *pReader){$/;"	f	file:
dlrDestroy	ext/fts2/fts2.c	/^static void dlrDestroy(DLReader *pReader){$/;"	f	file:
dlrDestroy	ext/fts3/fts3.c	/^static void dlrDestroy(DLReader *pReader){$/;"	f	file:
dlrDocData	ext/fts2/fts2.c	/^static const char *dlrDocData(DLReader *pReader){$/;"	f	file:
dlrDocData	ext/fts3/fts3.c	/^static const char *dlrDocData(DLReader *pReader){$/;"	f	file:
dlrDocDataBytes	ext/fts2/fts2.c	/^static int dlrDocDataBytes(DLReader *pReader){$/;"	f	file:
dlrDocDataBytes	ext/fts3/fts3.c	/^static int dlrDocDataBytes(DLReader *pReader){$/;"	f	file:
dlrDocid	ext/fts2/fts2.c	/^static sqlite_int64 dlrDocid(DLReader *pReader){$/;"	f	file:
dlrDocid	ext/fts3/fts3.c	/^static sqlite_int64 dlrDocid(DLReader *pReader){$/;"	f	file:
dlrInit	ext/fts2/fts2.c	/^static void dlrInit(DLReader *pReader, DocListType iType,$/;"	f	file:
dlrInit	ext/fts3/fts3.c	/^static void dlrInit(DLReader *pReader, DocListType iType,$/;"	f	file:
dlrPosData	ext/fts2/fts2.c	/^static const char *dlrPosData(DLReader *pReader){$/;"	f	file:
dlrPosData	ext/fts3/fts3.c	/^static const char *dlrPosData(DLReader *pReader){$/;"	f	file:
dlrPosDataLen	ext/fts2/fts2.c	/^static int dlrPosDataLen(DLReader *pReader){$/;"	f	file:
dlrPosDataLen	ext/fts3/fts3.c	/^static int dlrPosDataLen(DLReader *pReader){$/;"	f	file:
dlrStep	ext/fts2/fts2.c	/^static void dlrStep(DLReader *pReader){$/;"	f	file:
dlrStep	ext/fts3/fts3.c	/^static void dlrStep(DLReader *pReader){$/;"	f	file:
dlw	ext/fts2/fts2.c	/^  DLWriter *dlw;$/;"	m	struct:PLWriter	file:
dlw	ext/fts2/fts2.c	/^  DLWriter dlw;$/;"	m	struct:DLCollector	file:
dlw	ext/fts3/fts3.c	/^  DLWriter *dlw;$/;"	m	struct:PLWriter	file:
dlw	ext/fts3/fts3.c	/^  DLWriter dlw;$/;"	m	struct:DLCollector	file:
dlwAdd	ext/fts2/fts2.c	/^static void dlwAdd(DLWriter *pWriter, sqlite_int64 iDocid){$/;"	f	file:
dlwAdd	ext/fts3/fts3.c	/^static void dlwAdd(DLWriter *pWriter, sqlite_int64 iDocid){$/;"	f	file:
dlwAppend	ext/fts2/fts2.c	/^static void dlwAppend(DLWriter *pWriter,$/;"	f	file:
dlwAppend	ext/fts3/fts3.c	/^static void dlwAppend(DLWriter *pWriter,$/;"	f	file:
dlwCopy	ext/fts2/fts2.c	/^static void dlwCopy(DLWriter *pWriter, DLReader *pReader){$/;"	f	file:
dlwCopy	ext/fts3/fts3.c	/^static void dlwCopy(DLWriter *pWriter, DLReader *pReader){$/;"	f	file:
dlwDestroy	ext/fts2/fts2.c	/^static void dlwDestroy(DLWriter *pWriter){$/;"	f	file:
dlwDestroy	ext/fts3/fts3.c	/^static void dlwDestroy(DLWriter *pWriter){$/;"	f	file:
dlwInit	ext/fts2/fts2.c	/^static void dlwInit(DLWriter *pWriter, DocListType iType, DataBuffer *b){$/;"	f	file:
dlwInit	ext/fts3/fts3.c	/^static void dlwInit(DLWriter *pWriter, DocListType iType, DataBuffer *b){$/;"	f	file:
doNotSync	src/pager.c	/^  u8 doNotSync;               \/* Boolean. While true, do not spill the cache *\/$/;"	m	struct:Pager	file:
do_compile	src/test4.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_compile	src/test7.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_finalize	src/test4.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_finalize	src/test7.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_fuzzy_test	test/fuzz_common.tcl	/^proc do_fuzzy_test {testname args} {$/;"	p
do_ioerr_test	test/tester.tcl	/^proc do_ioerr_test {testname args} {$/;"	p
do_malloc_test	test/malloc_common.tcl	/^proc do_malloc_test {tn args} {$/;"	p
do_meta_command	src/shell.c	/^static int do_meta_command(char *zLine, struct callback_data *p){$/;"	f	file:
do_reset	src/test7.c	/^static void do_reset(Thread *p){$/;"	f	file:
do_step	src/test4.c	/^static void do_step(Thread *p){$/;"	f	file:
do_step	src/test7.c	/^static void do_step(Thread *p){$/;"	f	file:
do_test	test/tester.tcl	/^proc do_test {name cmd expected} {$/;"	p
do_test	test/thread_common.tcl	/^  proc do_test {name script result} {$/;"	p
docListAccumulate	ext/fts1/fts1.c	/^static void docListAccumulate(DocList *pAcc, DocList *pUpdate){$/;"	f	file:
docListAccumulateUnion	ext/fts3/fts3.c	/^static void docListAccumulateUnion(DataBuffer *acc,$/;"	f	file:
docListAddDocid	ext/fts1/fts1.c	/^static void docListAddDocid(DocList *d, sqlite_int64 iDocid){$/;"	f	file:
docListAddPos	ext/fts1/fts1.c	/^static void docListAddPos(DocList *d, int iColumn, int iPos){$/;"	f	file:
docListAddPosOffset	ext/fts1/fts1.c	/^static void docListAddPosOffset($/;"	f	file:
docListAndMerge	ext/fts1/fts1.c	/^static void docListAndMerge($/;"	f	file:
docListAndMerge	ext/fts2/fts2.c	/^static void docListAndMerge($/;"	f	file:
docListAndMerge	ext/fts3/fts3.c	/^static void docListAndMerge($/;"	f	file:
docListDelete	ext/fts1/fts1.c	/^static void docListDelete(DocList *d){$/;"	f	file:
docListDestroy	ext/fts1/fts1.c	/^static void docListDestroy(DocList *d){$/;"	f	file:
docListDiscardEmpty	ext/fts1/fts1.c	/^static void docListDiscardEmpty(DocList *in) {$/;"	f	file:
docListEnd	ext/fts1/fts1.c	/^static char *docListEnd(DocList *d){$/;"	f	file:
docListExceptMerge	ext/fts1/fts1.c	/^static void docListExceptMerge($/;"	f	file:
docListExceptMerge	ext/fts2/fts2.c	/^static void docListExceptMerge($/;"	f	file:
docListExceptMerge	ext/fts3/fts3.c	/^static void docListExceptMerge($/;"	f	file:
docListInit	ext/fts1/fts1.c	/^static void docListInit(DocList *d, DocListType iType,$/;"	f	file:
docListMerge	ext/fts2/fts2.c	/^static void docListMerge(DataBuffer *out,$/;"	f	file:
docListMerge	ext/fts3/fts3.c	/^static void docListMerge(DataBuffer *out,$/;"	f	file:
docListNew	ext/fts1/fts1.c	/^static DocList *docListNew(DocListType iType){$/;"	f	file:
docListOfTerm	ext/fts1/fts1.c	/^static int docListOfTerm($/;"	f	file:
docListOfTerm	ext/fts2/fts2.c	/^static int docListOfTerm($/;"	f	file:
docListOfTerm	ext/fts3/fts3.c	/^static int docListOfTerm($/;"	f	file:
docListOrMerge	ext/fts1/fts1.c	/^static void docListOrMerge($/;"	f	file:
docListOrMerge	ext/fts2/fts2.c	/^static void docListOrMerge($/;"	f	file:
docListOrMerge	ext/fts3/fts3.c	/^static void docListOrMerge($/;"	f	file:
docListPhraseMerge	ext/fts1/fts1.c	/^static void docListPhraseMerge($/;"	f	file:
docListPhraseMerge	ext/fts2/fts2.c	/^static void docListPhraseMerge($/;"	f	file:
docListPhraseMerge	ext/fts3/fts3.c	/^static void docListPhraseMerge($/;"	f	file:
docListRestrictColumn	ext/fts1/fts1.c	/^static void docListRestrictColumn(DocList *in, int iRestrictColumn){$/;"	f	file:
docListSpliceElement	ext/fts1/fts1.c	/^static void docListSpliceElement(DocListReader *r, sqlite_int64 iDocid,$/;"	f	file:
docListTrim	ext/fts2/fts2.c	/^static void docListTrim(DocListType iType, const char *pData, int nData,$/;"	f	file:
docListTrim	ext/fts3/fts3.c	/^static void docListTrim(DocListType iType, const char *pData, int nData,$/;"	f	file:
docListUnion	ext/fts2/fts2.c	/^static void docListUnion($/;"	f	file:
docListUnion	ext/fts3/fts3.c	/^static void docListUnion($/;"	f	file:
docListUpdate	ext/fts1/fts1.c	/^static void docListUpdate(DocList *d, DocList *pUpdate){$/;"	f	file:
docListValidate	ext/fts2/fts2.c	/^static void docListValidate(DocListType iType, const char *pData, int nData,$/;"	f	file:
docListValidate	ext/fts3/fts3.c	/^static void docListValidate(DocListType iType, const char *pData, int nData,$/;"	f	file:
done	src/sqliteInt.h	/^    u8 done;               \/* A flag to indicate when processing is finished *\/$/;"	m	struct:ExprList::ExprList_item
dot	tool/lemon.c	/^  int dot;                 \/* The parse point *\/$/;"	m	struct:config	file:
dotlockLockingContext	src/os_unix.c	/^struct dotlockLockingContext {$/;"	s	file:
dotlockLockingContext	src/os_unix.c	/^typedef struct dotlockLockingContext dotlockLockingContext;$/;"	t	typeref:struct:dotlockLockingContext	file:
dotlockLockingStyle	src/os_unix.c	/^        dotlockLockingStyle,         \/* use <file>.lock files *\/$/;"	e	enum:__anon15	file:
dotlockUnixCheckReservedLock	src/os_unix.c	/^static int dotlockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
dotlockUnixClose	src/os_unix.c	/^static int dotlockUnixClose(sqlite3_file *id) {$/;"	f	file:
dotlockUnixLock	src/os_unix.c	/^static int dotlockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
dotlockUnixUnlock	src/os_unix.c	/^static int dotlockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
double	sqlite3.h	209;"	d
double	sqlite3.h	4795;"	d
double	src/sqliteInt.h	168;"	d
doubleConsonant	ext/fts1/fts1_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleConsonant	ext/fts2/fts2_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleConsonant	ext/fts3/fts3_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleToInt64	src/vdbemem.c	/^static i64 doubleToInt64(double r){$/;"	f	file:
dropCell	src/btree.c	/^static void dropCell(MemPage *pPage, int idx, int sz){$/;"	f	file:
dstr	src/test1.c	/^struct dstr {$/;"	s	file:
dstrAppend	src/test1.c	/^static void dstrAppend(struct dstr *p, const char *z, int divider){$/;"	f	file:
dtnum	tool/lemon.c	/^  int dtnum;               \/* The data type number.  In the parser, the value$/;"	m	struct:symbol	file:
dump_callback	src/shell.c	/^static int dump_callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
dup8bytes	src/expr.c	/^static char *dup8bytes(Vdbe *v, const char *in){$/;"	f	file:
dyn	src/sqliteInt.h	/^  unsigned dyn  : 1;      \/* True for malloced memory, false for static *\/$/;"	m	struct:Token
eAsyncLock	src/test_async.c	/^  int eAsyncLock;           \/* Lock-state with write-queue unlock *\/$/;"	m	struct:AsyncFileLock	file:
eDest	src/sqliteInt.h	/^  u8 eDest;         \/* How to dispose of the results *\/$/;"	m	struct:SelectDest
eLock	src/btreeInt.h	/^  u8 eLock;             \/* READ_LOCK or WRITE_LOCK *\/$/;"	m	struct:BtLock
eLock	src/test_async.c	/^  int eLock;                \/* Internally visible lock state (sqlite pov) *\/$/;"	m	struct:AsyncFileLock	file:
eLock	src/test_async.c	/^  int eLock;$/;"	m	struct:AsyncLock	file:
eOperator	parse.c	/^  Token eOperator;  \/* "like" or "glob" or "regexp" *\/$/;"	m	struct:LikeOp	file:
eOperator	src/where.c	/^  u16 eOperator;          \/* A WO_xx value describing <op> *\/$/;"	m	struct:WhereTerm	file:
eState	src/btreeInt.h	/^  u8 eState;                \/* One of the CURSOR_XXX constants (see below) *\/$/;"	m	struct:BtCursor
eType	src/test_onefile.c	/^  int eType;$/;"	m	struct:fs_file	file:
e_action	tool/lemon.c	/^  enum e_action {$/;"	g	struct:action	file:
e_assoc	tool/lemon.c	/^  enum e_assoc {$/;"	g	struct:symbol	file:
e_state	tool/lemon.c	/^  enum e_state {$/;"	g	struct:pstate	file:
ebcdicToAscii	src/tokenize.c	/^const unsigned char ebcdicToAscii[] = {$/;"	v
echoBegin	src/test8.c	/^static int echoBegin(sqlite3_vtab *tab){$/;"	f	file:
echoBestIndex	src/test8.c	/^static int echoBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
echoClose	src/test8.c	/^static int echoClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoColumn	src/test8.c	/^static int echoColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
echoCommit	src/test8.c	/^static int echoCommit(sqlite3_vtab *tab){$/;"	f	file:
echoConnect	src/test8.c	/^static int echoConnect($/;"	f	file:
echoConstructor	src/test8.c	/^static int echoConstructor($/;"	f	file:
echoCreate	src/test8.c	/^static int echoCreate($/;"	f	file:
echoDeclareVtab	src/test8.c	/^static int echoDeclareVtab($/;"	f	file:
echoDestroy	src/test8.c	/^static int echoDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
echoDestructor	src/test8.c	/^static int echoDestructor(sqlite3_vtab *pVtab){$/;"	f	file:
echoDisconnect	src/test8.c	/^static int echoDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
echoEof	src/test8.c	/^static int echoEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoFilter	src/test8.c	/^static int echoFilter($/;"	f	file:
echoFindFunction	src/test8.c	/^static int echoFindFunction($/;"	f	file:
echoModule	src/test8.c	/^static sqlite3_module echoModule = {$/;"	v	file:
echoNext	src/test8.c	/^static int echoNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoOn	src/shell.c	/^  int echoOn;            \/* True to echo input commands *\/$/;"	m	struct:callback_data	file:
echoOpen	src/test8.c	/^static int echoOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
echoRename	src/test8.c	/^static int echoRename(sqlite3_vtab *vtab, const char *zNewName){$/;"	f	file:
echoRollback	src/test8.c	/^static int echoRollback(sqlite3_vtab *tab){$/;"	f	file:
echoRowid	src/test8.c	/^static int echoRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
echoSync	src/test8.c	/^static int echoSync(sqlite3_vtab *tab){$/;"	f	file:
echoTransactionCall	src/test8.c	/^static int echoTransactionCall(sqlite3_vtab *tab, const char *zCall){$/;"	f	file:
echoUpdate	src/test8.c	/^int echoUpdate($/;"	f
echo_cursor	src/test8.c	/^struct echo_cursor {$/;"	s	file:
echo_cursor	src/test8.c	/^typedef struct echo_cursor echo_cursor;$/;"	t	typeref:struct:echo_cursor	file:
echo_vtab	src/test8.c	/^struct echo_vtab {$/;"	s	file:
echo_vtab	src/test8.c	/^typedef struct echo_vtab echo_vtab;$/;"	t	typeref:struct:echo_vtab	file:
ecmd	parse.y	/^ecmd ::= SEMI.$/;"	l
ecmd	parse.y	/^ecmd ::= explain cmdx SEMI.$/;"	l
ecmd	src/parse.y	/^ecmd ::= SEMI.$/;"	l
ecmd	src/parse.y	/^ecmd ::= explain cmdx SEMI.$/;"	l
elapse	src/os_common.h	/^static unsigned int elapse;$/;"	v
emit_code	tool/lemon.c	/^PRIVATE void emit_code(out,rp,lemp,lineno)$/;"	f
emit_destructor_code	tool/lemon.c	/^void emit_destructor_code(out,sp,lemp,lineno)$/;"	f
emptySignal	src/test_async.c	/^  pthread_cond_t emptySignal;  \/* Notify when the write queue is empty *\/$/;"	m	struct:TestAsyncStaticData	file:
emsg	tool/lemon.c	/^static char emsg[] = "Command line syntax error: ";$/;"	v	file:
enable	src/fault.c	/^  u8 enable;        \/* True if enabled *\/$/;"	m	struct:FaultInjector	file:
enableTimer	src/shell.c	/^static int enableTimer = 0;$/;"	v	file:
enable_shared_cache	src/sqlite3ext.h	/^  int  (*enable_shared_cache)(int);$/;"	m	struct:sqlite3_api_routines
enable_simulated_io_errors	src/pager.c	/^void enable_simulated_io_errors(void){$/;"	f
enable_simulated_io_errors	src/pager.c	2397;"	d	file:
enable_simulated_io_errors	src/pager.h	123;"	d
enc	src/sqliteInt.h	/^  u8 enc;               \/* Text encoding handled by xCmp() *\/$/;"	m	struct:CollSeq
enc	src/sqliteInt.h	/^  u8 enc;              \/* Text encoding used by this database *\/$/;"	m	struct:Schema
enc	src/sqliteInt.h	/^  u8 enc;             \/* Text encoding - one of the TEXT_Utf* values *\/$/;"	m	struct:KeyInfo
enc	src/vdbeInt.h	/^  u8  enc;            \/* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE *\/$/;"	m	struct:Mem
endTimer	src/shell.c	/^static void endTimer(void){$/;"	f	file:
endsInWhiteSpace	ext/fts2/fts2.c	/^static int endsInWhiteSpace(StringBuffer *p){$/;"	f	file:
endsInWhiteSpace	ext/fts3/fts3.c	/^static int endsInWhiteSpace(StringBuffer *p){$/;"	f	file:
enterMem	src/mem1.c	/^static void enterMem(void){$/;"	f	file:
enterMem	src/mem2.c	/^static void enterMem(void){$/;"	f	file:
enterMutex	src/os_unix.c	/^static void enterMutex(){$/;"	f	file:
eof	ext/fts1/fts1.c	/^  int eof;                         \/* True if at End Of Results *\/$/;"	m	struct:fulltext_cursor	file:
eof	ext/fts2/fts2.c	/^  int eof;                         \/* True if at End Of Results *\/$/;"	m	struct:fulltext_cursor	file:
eof	ext/fts2/fts2.c	/^  int eof;                  \/* we've seen SQLITE_DONE from pStmt. *\/$/;"	m	struct:LeavesReader	file:
eof	ext/fts3/fts3.c	/^  int eof;                         \/* True if at End Of Results *\/$/;"	m	struct:fulltext_cursor	file:
eof	ext/fts3/fts3.c	/^  int eof;                  \/* we've seen SQLITE_DONE from pStmt. *\/$/;"	m	struct:LeavesReader	file:
errCode	src/pager.c	/^  int errCode;                \/* One of several kinds of errors *\/$/;"	m	struct:Pager	file:
errCode	src/sqliteInt.h	/^  int errCode;                  \/* Most recent error code (SQLITE_*) *\/$/;"	m	struct:sqlite3
errCode	src/test_server.c	/^  int errCode;                 \/* Error code returned *\/$/;"	m	struct:SqlMessage	file:
errMask	src/sqliteInt.h	/^  int errMask;                  \/* & result codes with this before returning *\/$/;"	m	struct:sqlite3
errcode	src/sqlite3ext.h	/^  int  (*errcode)(sqlite3*db);$/;"	m	struct:sqlite3_api_routines
errline	tool/lemon.c	/^static void errline(n,k,err)$/;"	f	file:
errmsg	src/sqlite3ext.h	/^  const char * (*errmsg)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
errmsg16	src/sqlite3ext.h	/^  const void * (*errmsg16)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
error	tool/lemon.c	/^  char *error;             \/* Code to execute when an error is seen *\/$/;"	m	struct:lemon	file:
errorAction	src/vdbeInt.h	/^  int errorAction;        \/* Recovery action to do in case of an error *\/$/;"	m	struct:Vdbe
errorName	src/test2.c	/^static char *errorName(int rc){$/;"	f	file:
errorName	src/test3.c	/^static char *errorName(int rc){$/;"	f	file:
errorcnt	tool/lemon.c	/^  int errorcnt;            \/* Number of errors *\/$/;"	m	struct:lemon	file:
errorcnt	tool/lemon.c	/^  int errorcnt;         \/* Number of errors so far *\/$/;"	m	struct:pstate	file:
errorln	tool/lemon.c	/^  int  errorln;            \/* Line number for start of error code *\/$/;"	m	struct:lemon	file:
errstream	tool/lemon.c	/^static FILE *errstream;$/;"	v	file:
errsym	tool/lemon.c	/^  struct symbol *errsym;   \/* The error symbol *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
estLog	src/where.c	/^static double estLog(double N){$/;"	f	file:
estimatedCost	sqlite3.h	/^  double estimatedCost;      \/* Estimated cost of using this index *\/$/;"	m	struct:sqlite3_index_info
etBUFSIZE	src/printf.c	193;"	d	file:
etByte	src/printf.c	/^typedef unsigned char etByte;$/;"	t	file:
etCHARLIT	src/printf.c	69;"	d	file:
etCHARX	src/printf.c	67;"	d	file:
etDYNSTRING	src/printf.c	65;"	d	file:
etEXP	src/printf.c	61;"	d	file:
etFLOAT	src/printf.c	60;"	d	file:
etGENERIC	src/printf.c	62;"	d	file:
etNINFO	src/printf.c	139;"	d	file:
etORDINAL	src/printf.c	77;"	d	file:
etPERCENT	src/printf.c	66;"	d	file:
etPOINTER	src/printf.c	75;"	d	file:
etRADIX	src/printf.c	59;"	d	file:
etSIZE	src/printf.c	63;"	d	file:
etSQLESCAPE	src/printf.c	70;"	d	file:
etSQLESCAPE2	src/printf.c	71;"	d	file:
etSQLESCAPE3	src/printf.c	76;"	d	file:
etSRCLIST	src/printf.c	74;"	d	file:
etSTRING	src/printf.c	64;"	d	file:
etTOKEN	src/printf.c	73;"	d	file:
et_getdigit	src/printf.c	/^static int et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){$/;"	f	file:
et_info	src/printf.c	/^typedef struct et_info {   \/* Information about each format field *\/$/;"	s	file:
et_info	src/printf.c	/^} et_info;$/;"	t	typeref:struct:et_info	file:
exclusiveMode	src/pager.c	/^  u8 exclusiveMode;           \/* Boolean. True if locking_mode==EXCLUSIVE *\/$/;"	m	struct:Pager	file:
exec	src/sqlite3ext.h	/^  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);$/;"	m	struct:sqlite3_api_routines
execExecSql	src/vacuum.c	/^static int execExecSql(sqlite3 *db, const char *zSql){$/;"	f	file:
execFuncCallback	src/test1.c	/^static int execFuncCallback(void *pData, int argc, char **argv, char **NotUsed){$/;"	f	file:
execSql	src/vacuum.c	/^static int execSql(sqlite3 *db, const char *zSql){$/;"	f	file:
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_printf_cb	src/test1.c	/^static int exec_printf_cb(void *pArg, int argc, char **argv, char **name){$/;"	f	file:
execsql	test/tester.tcl	/^proc execsql {sql {db db}} {$/;"	p
execsql	test/thread_common.tcl	/^  proc execsql {sql} {$/;"	p
execsql2	test/tester.tcl	/^proc execsql2 {sql} {$/;"	p
expandBlob	src/vdbemem.c	26;"	d	file:
expired	src/sqlite3ext.h	/^  int  (*expired)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
expired	src/vdbeInt.h	/^  u8 expired;             \/* True if the VM needs to be recompiled *\/$/;"	m	struct:Vdbe
explain	parse.y	/^explain ::= .           { sqlite3BeginParse(pParse, 0); }$/;"	l
explain	parse.y	/^explain ::= EXPLAIN QUERY PLAN.   { sqlite3BeginParse(pParse, 2); }$/;"	l
explain	parse.y	/^explain ::= EXPLAIN.              { sqlite3BeginParse(pParse, 1); }$/;"	l
explain	src/parse.y	/^explain ::= .           { sqlite3BeginParse(pParse, 0); }$/;"	l
explain	src/parse.y	/^explain ::= EXPLAIN QUERY PLAN.   { sqlite3BeginParse(pParse, 2); }$/;"	l
explain	src/parse.y	/^explain ::= EXPLAIN.              { sqlite3BeginParse(pParse, 1); }$/;"	l
explain	src/sqliteInt.h	/^  u8 explain;          \/* True if the EXPLAIN flag is found on the query *\/$/;"	m	struct:Parse
explain	src/vdbeInt.h	/^  u8 explain;             \/* True if EXPLAIN present on SQL command *\/$/;"	m	struct:Vdbe
explain	test/tester.tcl	/^proc explain {sql {db db}} {$/;"	p
explainPrev	src/shell.c	/^  struct previous_mode_data explainPrev;$/;"	m	struct:callback_data	typeref:struct:callback_data::previous_mode_data	file:
exprAnalyze	src/where.c	/^static void exprAnalyze($/;"	f	file:
exprAnalyzeAll	src/where.c	/^static void exprAnalyzeAll($/;"	f	file:
exprCommute	src/where.c	/^static void exprCommute(Expr *pExpr){$/;"	f	file:
exprListTableUsage	src/where.c	/^static Bitmask exprListTableUsage(ExprMaskSet *pMaskSet, ExprList *pList){$/;"	f	file:
exprNodeIsConstant	src/expr.c	/^static int exprNodeIsConstant(void *pArg, Expr *pExpr){$/;"	f	file:
exprSelectTableUsage	src/where.c	/^static Bitmask exprSelectTableUsage(ExprMaskSet *pMaskSet, Select *pS){$/;"	f	file:
exprTableUsage	src/where.c	/^static Bitmask exprTableUsage(ExprMaskSet *pMaskSet, Expr *p){$/;"	f	file:
extracode	tool/lemon.c	/^  char *extracode;         \/* Code appended to the generated file *\/$/;"	m	struct:lemon	file:
extracodeln	tool/lemon.c	/^  int  extracodeln;        \/* Line number for the start of the extra code *\/$/;"	m	struct:lemon	file:
failure	tool/lemon.c	/^  char *failure;           \/* Code to execute on parser failure *\/$/;"	m	struct:lemon	file:
failureln	tool/lemon.c	/^  int  failureln;          \/* Line number for start of failure code *\/$/;"	m	struct:lemon	file:
fake_big_file	src/test2.c	/^static int fake_big_file($/;"	f	file:
fallback	tool/lemon.c	/^  struct symbol *fallback;   \/* The fallback token *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
fallback	tool/lemon.c	/^  struct symbol *fallback; \/* fallback token in case this token doesn't parse *\/$/;"	m	struct:symbol	typeref:struct:symbol::symbol	file:
fcntl	src/os_unix.c	134;"	d	file:
fcntl	src/os_unix.c	468;"	d	file:
fd	src/os_unix.c	/^  int fd;                           \/* file desc to assoc this lock with *\/$/;"	m	struct:ByteRangeLockPB2	file:
fd	src/os_unix.c	/^  int fd;                \/* File to be locked *\/$/;"	m	struct:threadTestData	file:
fd	src/pager.c	/^  sqlite3_file *fd, *jfd;     \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
fdatasync	configure	/^fdatasync ();$/;"	f
fdatasync	src/os_unix.c	898;"	d	file:
fetchId	src/vdbeInt.h	/^  int fetchId;          \/* Statement number used by sqlite3_fetch_statement *\/$/;"	m	struct:Vdbe
fetchPayload	src/btree.c	/^static const unsigned char *fetchPayload($/;"	f	file:
filePath	src/os_unix.c	/^  char *filePath;$/;"	m	struct:afpLockingContext	file:
file_control	src/sqlite3ext.h	/^  int (*file_control)(sqlite3*,const char*,int,void*);$/;"	m	struct:sqlite3_api_routines
file_control_test	src/test1.c	/^static int file_control_test($/;"	f	file:
file_format	src/sqliteInt.h	/^  u8 file_format;      \/* Schema format version for this file *\/$/;"	m	struct:Schema
file_makename	tool/lemon.c	/^PRIVATE char *file_makename(lemp,suffix)$/;"	f
file_open	tool/lemon.c	/^PRIVATE FILE *file_open(lemp,suffix,mode)$/;"	f
filename	tool/lemon.c	/^  char *filename;          \/* Name of the input file *\/$/;"	m	struct:lemon	file:
filename	tool/lemon.c	/^  char *filename;       \/* Name of the input file *\/$/;"	m	struct:pstate	file:
fillInCell	src/btree.c	/^static int fillInCell($/;"	f	file:
fillInUnixFile	src/os_unix.c	/^static int fillInUnixFile($/;"	f	file:
finalize	src/sqlite3ext.h	/^  int  (*finalize)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
finalize	src/test_schema.c	/^static int finalize(sqlite3_stmt **ppStmt){$/;"	f	file:
finalize	tool/mkopts.tcl	/^proc finalize {} {$/;"	p
finalizeAggFunctions	src/select.c	/^static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
finalize_testing	test/tester.tcl	/^proc finalize_testing {} {$/;"	p
findById	tool/mkkeywordhash.c	/^static Keyword *findById(int id){$/;"	f	file:
findCell	src/btree.c	499;"	d	file:
findCollSeqEntry	src/callback.c	/^static CollSeq *findCollSeqEntry($/;"	f	file:
findElementGivenHash	ext/fts1/fts1_hash.c	/^static fts1HashElem *findElementGivenHash($/;"	f	file:
findElementGivenHash	ext/fts2/fts2_hash.c	/^static fts2HashElem *findElementGivenHash($/;"	f	file:
findElementGivenHash	src/hash.c	/^static HashElem *findElementGivenHash($/;"	f	file:
findLockInfo	src/os_unix.c	/^static int findLockInfo($/;"	f	file:
findOverflowCell	src/btree.c	/^static u8 *findOverflowCell(MemPage *pPage, int iCell){$/;"	f	file:
findSqlFunc	src/tclsqlite.c	/^static SqlFunc *findSqlFunc(SqliteDb *pDb, const char *zName){$/;"	f	file:
findTerm	src/where.c	/^static WhereTerm *findTerm($/;"	f	file:
find_home_dir	src/shell.c	/^static char *find_home_dir(void){$/;"	f	file:
findbreak	tool/lemon.c	/^static int findbreak(msg,min,max)$/;"	f	file:
finish_test	test/tester.tcl	/^proc finish_test {} {$/;"	p
first	ext/fts1/fts1_hash.h	/^  fts1HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:fts1Hash
first	ext/fts2/fts2.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
first	ext/fts2/fts2_hash.h	/^  fts2HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:fts2Hash
first	ext/fts3/fts3.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
first	ext/fts3/fts3_hash.h	/^  fts3HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:fts3Hash
first	src/hash.h	/^  HashElem *first;        \/* The first element of the array *\/$/;"	m	struct:Hash
firstDocid	ext/fts1/fts1.c	/^static sqlite_int64 firstDocid(DocList *d){$/;"	f	file:
firstFree	src/mem4.c	/^  int firstFree;$/;"	m	struct:__anon18	file:
firstToken	ext/fts1/fts1.c	/^static char *firstToken(char *zIn, char **pzTail){$/;"	f	file:
firstToken	ext/fts2/fts2.c	/^static char *firstToken(char *zIn, char **pzTail){$/;"	f	file:
firstToken	ext/fts3/fts3.c	/^static char *firstToken(char *zIn, char **pzTail){$/;"	f	file:
firstUnused	src/mem4.c	/^  int firstUnused;$/;"	m	struct:__anon18	file:
firstrule	tool/lemon.c	/^  struct rule *firstrule;    \/* Pointer to first rule in the grammar *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
firstset	tool/lemon.c	/^  char *firstset;          \/* First-set for all rules of this symbol *\/$/;"	m	struct:symbol	file:
fix_ifcapable_expr	test/tester.tcl	/^proc fix_ifcapable_expr {expr} {$/;"	p
flagPragma	src/pragma.c	/^static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){$/;"	f	file:
flags	src/journal.c	/^  int flags;                      \/* xOpen flags *\/$/;"	m	struct:JournalFile	file:
flags	src/printf.c	/^  etByte flags;            \/* One or more of FLAG_ constants below *\/$/;"	m	struct:et_info	file:
flags	src/sqliteInt.h	/^  int flags;                    \/* Miscellanous flags. See below *\/$/;"	m	struct:sqlite3
flags	src/sqliteInt.h	/^  int flags;            \/* Flags associated with this level *\/$/;"	m	struct:WhereLevel
flags	src/sqliteInt.h	/^  u16 flags;             \/* Various flags.  See below *\/$/;"	m	struct:Expr
flags	src/sqliteInt.h	/^  u16 flags;           \/* Flags associated with this schema *\/$/;"	m	struct:Schema
flags	src/sqliteInt.h	/^  u8 flags;            \/* Some combination of SQLITE_FUNC_* *\/$/;"	m	struct:FuncDef
flags	src/vdbe.h	/^  u8 flags;           \/* Flags for internal use *\/$/;"	m	struct:VdbeOp
flags	src/vdbeInt.h	/^  u16 flags;          \/* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. *\/$/;"	m	struct:Mem
flags	src/vdbeblob.c	/^  int flags;              \/* Copy of "flags" passed to sqlite3_blob_open() *\/$/;"	m	struct:Incrblob	file:
flags	src/where.c	/^  u8 flags;               \/* Bit flags.  See below *\/$/;"	m	struct:WhereTerm	file:
flattenSubquery	src/select.c	/^static int flattenSubquery($/;"	f	file:
floatSwap	src/vdbeaux.c	/^static u64 floatSwap(u64 in){$/;"	f	file:
flockLockingContext	src/os_unix.c	/^typedef void flockLockingContext;$/;"	t	file:
flockLockingStyle	src/os_unix.c	/^        flockLockingStyle,           \/* use flock() *\/$/;"	e	enum:__anon15	file:
flockUnixCheckReservedLock	src/os_unix.c	/^static int flockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
flockUnixClose	src/os_unix.c	/^static int flockUnixClose(sqlite3_file *pId) {$/;"	f	file:
flockUnixLock	src/os_unix.c	/^static int flockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
flockUnixUnlock	src/os_unix.c	/^static int flockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
flushPendingTerms	ext/fts2/fts2.c	/^static int flushPendingTerms(fulltext_vtab *v){$/;"	f	file:
flushPendingTerms	ext/fts3/fts3.c	/^static int flushPendingTerms(fulltext_vtab *v){$/;"	f	file:
flushStmtCache	src/tclsqlite.c	/^static void flushStmtCache( SqliteDb *pDb ){$/;"	f	file:
fmtinfo	src/printf.c	/^static const et_info fmtinfo[] = {$/;"	v	file:
fmttype	src/printf.c	/^  char fmttype;            \/* The format field code letter *\/$/;"	m	struct:et_info	file:
forcedelete	test/tester.tcl	/^proc forcedelete {filename} {$/;"	p
foreach_clause	parse.y	/^foreach_clause ::= .$/;"	l
foreach_clause	parse.y	/^foreach_clause ::= FOR EACH ROW.$/;"	l
foreach_clause	src/parse.y	/^foreach_clause ::= .$/;"	l
foreach_clause	src/parse.y	/^foreach_clause ::= FOR EACH ROW.$/;"	l
fplp	tool/lemon.c	/^  struct plink *fplp;      \/* Follow-set forward propagation links *\/$/;"	m	struct:config	typeref:struct:config::plink	file:
free	src/pager.c	/^  PagerLruLink free;             \/* Next and previous free pages *\/$/;"	m	struct:PgHdr	file:
free	src/sqlite3ext.h	/^  void  (*free)(void*);$/;"	m	struct:sqlite3_api_routines
freeEphemeralFunction	src/vdbeaux.c	/^static void freeEphemeralFunction(FuncDef *pDef){$/;"	f	file:
freeIndex	src/build.c	/^static void freeIndex(Index *p){$/;"	f	file:
freeP4	src/vdbeaux.c	/^static void freeP4(int p4type, void *p3){$/;"	f	file:
freePage	src/btree.c	/^static int freePage(MemPage *pPage){$/;"	f	file:
freeSpace	src/btree.c	/^static void freeSpace(MemPage *pPage, int start, int size){$/;"	f	file:
freeStringArray	ext/fts1/fts1.c	/^static void freeStringArray(int nString, const char **pString){$/;"	f	file:
freeStringArray	ext/fts2/fts2.c	/^static void freeStringArray(int nString, const char **pString){$/;"	f	file:
freeStringArray	ext/fts3/fts3.c	/^static void freeStringArray(int nString, const char **pString){$/;"	f	file:
free_table	src/sqlite3ext.h	/^  void  (*free_table)(char**result);$/;"	m	struct:sqlite3_api_routines
free_test_auxdata	src/func.c	/^static void free_test_auxdata(void *p) {sqlite3_free(p);}$/;"	f	file:
freelist	tool/lemon.c	/^static struct config *freelist = 0;      \/* List of free configurations *\/$/;"	v	typeref:struct:config	file:
from	tool/lemon.c	/^  struct s_x1node **from;  \/* Previous link *\/$/;"	m	struct:s_x1node	typeref:struct:s_x1node::s_x1node	file:
from	tool/lemon.c	/^  struct s_x2node **from;  \/* Previous link *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::s_x2node	file:
from	tool/lemon.c	/^  struct s_x3node **from;  \/* Previous link *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::s_x3node	file:
from	tool/lemon.c	/^  struct s_x4node **from;  \/* Previous link *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::s_x4node	file:
fsAccess	src/test_onefile.c	/^static int fsAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
fsCheckReservedLock	src/test_onefile.c	/^static int fsCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
fsClose	src/test_onefile.c	/^static int fsClose(sqlite3_file *pFile){$/;"	f	file:
fsCurrentTime	src/test_onefile.c	/^static int fsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
fsDelete	src/test_onefile.c	/^static int fsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
fsDeviceCharacteristics	src/test_onefile.c	/^static int fsDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
fsDlClose	src/test_onefile.c	/^static void fsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
fsDlError	src/test_onefile.c	/^static void fsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
fsDlOpen	src/test_onefile.c	/^static void *fsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
fsDlSym	src/test_onefile.c	/^static void *fsDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
fsFileControl	src/test_onefile.c	/^static int fsFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
fsFileSize	src/test_onefile.c	/^static int fsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
fsFullPathname	src/test_onefile.c	/^static int fsFullPathname($/;"	f	file:
fsGetTempname	src/test_onefile.c	/^static int fsGetTempname(sqlite3_vfs *pVfs, int nBufOut, char *zBufOut){$/;"	f	file:
fsLock	src/test_onefile.c	/^static int fsLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsOpen	src/test_onefile.c	/^static int fsOpen($/;"	f	file:
fsRandomness	src/test_onefile.c	/^static int fsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
fsRead	src/test_onefile.c	/^static int fsRead($/;"	f	file:
fsSectorSize	src/test_onefile.c	/^static int fsSectorSize(sqlite3_file *pFile){$/;"	f	file:
fsSleep	src/test_onefile.c	/^static int fsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
fsSync	src/test_onefile.c	/^static int fsSync(sqlite3_file *pFile, int flags){$/;"	f	file:
fsTruncate	src/test_onefile.c	/^static int fsTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
fsUnlock	src/test_onefile.c	/^static int fsUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsWrite	src/test_onefile.c	/^static int fsWrite($/;"	f	file:
fs_file	src/test_onefile.c	/^struct fs_file {$/;"	s	file:
fs_file	src/test_onefile.c	/^typedef struct fs_file fs_file;$/;"	t	typeref:struct:fs_file	file:
fs_io_methods	src/test_onefile.c	/^static sqlite3_io_methods fs_io_methods = {$/;"	v	file:
fs_real_file	src/test_onefile.c	/^struct fs_real_file {$/;"	s	file:
fs_real_file	src/test_onefile.c	/^typedef struct fs_real_file fs_real_file;$/;"	t	typeref:struct:fs_real_file	file:
fs_register	src/test_onefile.c	/^int fs_register(){$/;"	f
fs_vfs	src/test_onefile.c	/^static fs_vfs_t fs_vfs = {$/;"	v	file:
fs_vfs_t	src/test_onefile.c	/^struct fs_vfs_t {$/;"	s	file:
fs_vfs_t	src/test_onefile.c	/^typedef struct fs_vfs_t fs_vfs_t;$/;"	t	typeref:struct:fs_vfs_t	file:
fts1Hash	ext/fts1/fts1_hash.h	/^struct fts1Hash {$/;"	s
fts1Hash	ext/fts1/fts1_hash.h	/^typedef struct fts1Hash fts1Hash;$/;"	t	typeref:struct:fts1Hash
fts1HashClear	ext/fts1/fts1_hash.h	87;"	d
fts1HashCount	ext/fts1/fts1_hash.h	110;"	d
fts1HashData	ext/fts1/fts1_hash.h	103;"	d
fts1HashElem	ext/fts1/fts1_hash.h	/^struct fts1HashElem {$/;"	s
fts1HashElem	ext/fts1/fts1_hash.h	/^typedef struct fts1HashElem fts1HashElem;$/;"	t	typeref:struct:fts1HashElem
fts1HashFind	ext/fts1/fts1_hash.h	86;"	d
fts1HashFirst	ext/fts1/fts1_hash.h	101;"	d
fts1HashInit	ext/fts1/fts1_hash.h	84;"	d
fts1HashInsert	ext/fts1/fts1_hash.h	85;"	d
fts1HashKey	ext/fts1/fts1_hash.h	104;"	d
fts1HashKeysize	ext/fts1/fts1_hash.h	105;"	d
fts1HashNext	ext/fts1/fts1_hash.h	102;"	d
fts2Hash	ext/fts2/fts2_hash.h	/^struct fts2Hash {$/;"	s
fts2Hash	ext/fts2/fts2_hash.h	/^typedef struct fts2Hash fts2Hash;$/;"	t	typeref:struct:fts2Hash
fts2HashClear	ext/fts2/fts2_hash.h	87;"	d
fts2HashCount	ext/fts2/fts2_hash.h	110;"	d
fts2HashData	ext/fts2/fts2_hash.h	103;"	d
fts2HashElem	ext/fts2/fts2_hash.h	/^struct fts2HashElem {$/;"	s
fts2HashElem	ext/fts2/fts2_hash.h	/^typedef struct fts2HashElem fts2HashElem;$/;"	t	typeref:struct:fts2HashElem
fts2HashFind	ext/fts2/fts2_hash.h	86;"	d
fts2HashFirst	ext/fts2/fts2_hash.h	101;"	d
fts2HashInit	ext/fts2/fts2_hash.h	84;"	d
fts2HashInsert	ext/fts2/fts2_hash.h	85;"	d
fts2HashKey	ext/fts2/fts2_hash.h	104;"	d
fts2HashKeysize	ext/fts2/fts2_hash.h	105;"	d
fts2HashNext	ext/fts2/fts2_hash.h	102;"	d
fts2Module	ext/fts2/fts2.c	/^static const sqlite3_module fts2Module = {$/;"	v	file:
fts2Module	ext/fts2/fts2.c	/^static const sqlite3_module fts2Module;   \/* forward declaration *\/$/;"	v	file:
fts3BinCompare	ext/fts3/fts3_hash.c	/^static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
fts3BinHash	ext/fts3/fts3_hash.c	/^static int fts3BinHash(const void *pKey, int nKey){$/;"	f	file:
fts3FindElementByHash	ext/fts3/fts3_hash.c	/^static fts3HashElem *fts3FindElementByHash($/;"	f	file:
fts3GetVarint	ext/fts3/fts3.c	/^static int fts3GetVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
fts3GetVarint32	ext/fts3/fts3.c	/^static int fts3GetVarint32(const char *p, int *pi){$/;"	f	file:
fts3Hash	ext/fts3/fts3_hash.h	/^struct fts3Hash {$/;"	s
fts3Hash	ext/fts3/fts3_hash.h	/^typedef struct fts3Hash fts3Hash;$/;"	t	typeref:struct:fts3Hash
fts3HashClear	ext/fts3/fts3_hash.h	85;"	d
fts3HashCount	ext/fts3/fts3_hash.h	108;"	d
fts3HashData	ext/fts3/fts3_hash.h	101;"	d
fts3HashElem	ext/fts3/fts3_hash.h	/^struct fts3HashElem {$/;"	s
fts3HashElem	ext/fts3/fts3_hash.h	/^typedef struct fts3HashElem fts3HashElem;$/;"	t	typeref:struct:fts3HashElem
fts3HashFind	ext/fts3/fts3_hash.h	84;"	d
fts3HashFirst	ext/fts3/fts3_hash.h	99;"	d
fts3HashFree	ext/fts3/fts3_hash.c	/^static void fts3HashFree(void *p){$/;"	f	file:
fts3HashInit	ext/fts3/fts3_hash.h	82;"	d
fts3HashInsert	ext/fts3/fts3_hash.h	83;"	d
fts3HashInsertElement	ext/fts3/fts3_hash.c	/^static void fts3HashInsertElement($/;"	f	file:
fts3HashKey	ext/fts3/fts3_hash.h	102;"	d
fts3HashKeysize	ext/fts3/fts3_hash.h	103;"	d
fts3HashMalloc	ext/fts3/fts3_hash.c	/^static void *fts3HashMalloc(int n){$/;"	f	file:
fts3HashNext	ext/fts3/fts3_hash.h	100;"	d
fts3Module	ext/fts3/fts3.c	/^static const sqlite3_module fts3Module = {$/;"	v	file:
fts3Module	ext/fts3/fts3.c	/^static const sqlite3_module fts3Module;   \/* forward declaration *\/$/;"	v	file:
fts3PutVarint	ext/fts3/fts3.c	/^static int fts3PutVarint(char *p, sqlite_int64 v){$/;"	f	file:
fts3Rehash	ext/fts3/fts3_hash.c	/^static void fts3Rehash(fts3Hash *pH, int new_size){$/;"	f	file:
fts3RemoveElementByHash	ext/fts3/fts3_hash.c	/^static void fts3RemoveElementByHash($/;"	f	file:
fts3StrCompare	ext/fts3/fts3_hash.c	/^static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
fts3StrHash	ext/fts3/fts3_hash.c	/^static int fts3StrHash(const void *pKey, int nKey){$/;"	f	file:
ftsCompareFunction	ext/fts3/fts3_hash.c	/^static int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
ftsGetToken	ext/fts3/fts3.c	/^static int ftsGetToken(const char *z, int *tokenType){$/;"	f	file:
ftsHashFunction	ext/fts3/fts3_hash.c	/^static int (*ftsHashFunction(int keyClass))(const void*,int){$/;"	f	file:
ftsIdChar	ext/fts3/fts3.c	2492;"	d	file:
fullSync	src/pager.c	/^  u8 fullSync;                \/* Do extra syncs of the journal for robustness *\/$/;"	m	struct:Pager	file:
full_fsync	src/os_unix.c	/^static int full_fsync(int fd, int fullSync, int dataOnly){$/;"	f	file:
fulltextBegin	ext/fts2/fts2.c	/^static int fulltextBegin(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextBegin	ext/fts3/fts3.c	/^static int fulltextBegin(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextBestIndex	ext/fts1/fts1.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextBestIndex	ext/fts2/fts2.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextBestIndex	ext/fts3/fts3.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextClose	ext/fts1/fts1.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextClose	ext/fts2/fts2.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextClose	ext/fts3/fts3.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextColumn	ext/fts1/fts1.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextColumn	ext/fts2/fts2.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextColumn	ext/fts3/fts3.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextCommit	ext/fts2/fts2.c	/^static int fulltextCommit(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextCommit	ext/fts3/fts3.c	/^static int fulltextCommit(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextConnect	ext/fts1/fts1.c	/^static int fulltextConnect($/;"	f	file:
fulltextConnect	ext/fts2/fts2.c	/^static int fulltextConnect($/;"	f	file:
fulltextConnect	ext/fts3/fts3.c	/^static int fulltextConnect($/;"	f	file:
fulltextCreate	ext/fts1/fts1.c	/^static int fulltextCreate(sqlite3 *db, void *pAux,$/;"	f	file:
fulltextCreate	ext/fts2/fts2.c	/^static int fulltextCreate(sqlite3 *db, void *pAux,$/;"	f	file:
fulltextCreate	ext/fts3/fts3.c	/^static int fulltextCreate(sqlite3 *db, void *pAux,$/;"	f	file:
fulltextDestroy	ext/fts1/fts1.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDestroy	ext/fts2/fts2.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDestroy	ext/fts3/fts3.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	ext/fts1/fts1.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	ext/fts2/fts2.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	ext/fts3/fts3.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextEof	ext/fts1/fts1.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextEof	ext/fts2/fts2.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextEof	ext/fts3/fts3.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextFilter	ext/fts1/fts1.c	/^static int fulltextFilter($/;"	f	file:
fulltextFilter	ext/fts2/fts2.c	/^static int fulltextFilter($/;"	f	file:
fulltextFilter	ext/fts3/fts3.c	/^static int fulltextFilter($/;"	f	file:
fulltextFindFunction	ext/fts1/fts1.c	/^static int fulltextFindFunction($/;"	f	file:
fulltextFindFunction	ext/fts2/fts2.c	/^static int fulltextFindFunction($/;"	f	file:
fulltextFindFunction	ext/fts3/fts3.c	/^static int fulltextFindFunction($/;"	f	file:
fulltextModule	ext/fts1/fts1.c	/^static const sqlite3_module fulltextModule = {$/;"	v	file:
fulltextModule	ext/fts1/fts1.c	/^static const sqlite3_module fulltextModule;   \/* forward declaration *\/$/;"	v	file:
fulltextNext	ext/fts1/fts1.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextNext	ext/fts2/fts2.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextNext	ext/fts3/fts3.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextOpen	ext/fts1/fts1.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextOpen	ext/fts2/fts2.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextOpen	ext/fts3/fts3.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextQuery	ext/fts1/fts1.c	/^static int fulltextQuery($/;"	f	file:
fulltextQuery	ext/fts2/fts2.c	/^static int fulltextQuery($/;"	f	file:
fulltextQuery	ext/fts3/fts3.c	/^static int fulltextQuery($/;"	f	file:
fulltextRename	ext/fts1/fts1.c	/^static int fulltextRename($/;"	f	file:
fulltextRename	ext/fts2/fts2.c	/^static int fulltextRename($/;"	f	file:
fulltextRename	ext/fts3/fts3.c	/^static int fulltextRename($/;"	f	file:
fulltextRollback	ext/fts2/fts2.c	/^static int fulltextRollback(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextRollback	ext/fts3/fts3.c	/^static int fulltextRollback(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextRowid	ext/fts1/fts1.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextRowid	ext/fts2/fts2.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextRowid	ext/fts3/fts3.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextSchema	ext/fts1/fts1.c	/^static char *fulltextSchema($/;"	f	file:
fulltextSchema	ext/fts2/fts2.c	/^static char *fulltextSchema($/;"	f	file:
fulltextSchema	ext/fts3/fts3.c	/^static char *fulltextSchema($/;"	f	file:
fulltextSync	ext/fts2/fts2.c	/^static int fulltextSync(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextSync	ext/fts3/fts3.c	/^static int fulltextSync(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextUpdate	ext/fts1/fts1.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltextUpdate	ext/fts2/fts2.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltextUpdate	ext/fts3/fts3.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltext_cursor	ext/fts1/fts1.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	ext/fts1/fts1.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_cursor	ext/fts2/fts2.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	ext/fts2/fts2.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_cursor	ext/fts3/fts3.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	ext/fts3/fts3.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_statement	ext/fts1/fts1.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	ext/fts1/fts1.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_statement	ext/fts2/fts2.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	ext/fts2/fts2.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_statement	ext/fts3/fts3.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	ext/fts3/fts3.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_vtab	ext/fts1/fts1.c	/^struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	ext/fts1/fts1.c	/^typedef struct fulltext_vtab fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab	ext/fts2/fts2.c	/^struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	ext/fts2/fts2.c	/^typedef struct fulltext_vtab fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab	ext/fts3/fts3.c	/^struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	ext/fts3/fts3.c	/^typedef struct fulltext_vtab fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab_destroy	ext/fts1/fts1.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_vtab_destroy	ext/fts2/fts2.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_vtab_destroy	ext/fts3/fts3.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_zStatement	ext/fts1/fts1.c	/^static const char *const fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
fulltext_zStatement	ext/fts2/fts2.c	/^static const char *const fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
fulltext_zStatement	ext/fts3/fts3.c	/^static const char *const fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
func_extract_an_archive	libtool	/^func_extract_an_archive ()$/;"	f
func_extract_an_archive	ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	libtool	/^func_extract_archives ()$/;"	f
func_extract_archives	ltmain.sh	/^func_extract_archives ()$/;"	f
func_infer_tag	libtool	/^func_infer_tag ()$/;"	f
func_infer_tag	ltmain.sh	/^func_infer_tag ()$/;"	f
func_mktempdir	libtool	/^func_mktempdir ()$/;"	f
func_mktempdir	ltmain.sh	/^func_mktempdir ()$/;"	f
func_win32_libid	libtool	/^func_win32_libid ()$/;"	f
func_win32_libid	ltmain.sh	/^func_win32_libid ()$/;"	f
fuzz	test/fuzz_common.tcl	/^proc fuzz {TemplateList} {$/;"	p
fws	tool/lemon.c	/^  char *fws;               \/* Follow-set for this configuration only *\/$/;"	m	struct:config	file:
g	src/test6.c	/^static CrashGlobal g = {0, 0, SQLITE_DEFAULT_SECTOR_SIZE, 0, 0};$/;"	v	file:
g	src/test_devsym.c	/^struct DevsymGlobal g = {0, 0, 512};$/;"	v	typeref:struct:DevsymGlobal
g	src/test_server.c	/^} g = {$/;"	v	typeref:struct:ServerState	file:
g_start	src/os_common.h	/^static unsigned long long int g_start;$/;"	v
generateColumnNames	src/select.c	/^static void generateColumnNames($/;"	f	file:
generateColumnTypes	src/select.c	/^static void generateColumnTypes($/;"	f	file:
generateSortTail	src/select.c	/^static void generateSortTail($/;"	f	file:
generate_makefile	tool/soak1.tcl	/^proc generate_makefile {pattern} {$/;"	p
get2byte	src/btreeInt.h	631;"	d
get4byte	src/btreeInt.h	633;"	d
getAndInitPage	src/btree.c	/^static int getAndInitPage($/;"	f	file:
getAutoVacuum	src/pragma.c	/^static int getAutoVacuum(const char *z){$/;"	f	file:
getBoolean	src/pragma.c	/^static int getBoolean(const char *z){$/;"	f	file:
getCellInfo	src/btree.c	/^  static void getCellInfo(BtCursor *pCur){$/;"	f	file:
getCellInfo	src/btree.c	2866;"	d	file:
getChildrenContaining	ext/fts2/fts2.c	/^static void getChildrenContaining(const char *pData, int nData,$/;"	f	file:
getChildrenContaining	ext/fts3/fts3.c	/^static void getChildrenContaining(const char *pData, int nData,$/;"	f	file:
getColumnNames	src/test8.c	/^static int getColumnNames($/;"	f	file:
getDbPointer	src/test1.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	src/test8.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	src/test_schema.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	src/test_tclvar.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDigits	src/date.c	/^static int getDigits(const char *zDate, ...){$/;"	f	file:
getFileLock	src/test_async.c	/^static int getFileLock(AsyncLock *pLock){$/;"	f	file:
getIndexArray	src/test8.c	/^static int getIndexArray($/;"	f	file:
getLockingMode	src/pragma.c	/^static int getLockingMode(const char *z){$/;"	f	file:
getMask	src/where.c	/^static Bitmask getMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
getOverflowPage	src/btree.c	/^static int getOverflowPage($/;"	f	file:
getReadLock	src/os_os2.c	/^static int getReadLock( os2File *pFile ){$/;"	f	file:
getReadLock	src/os_win.c	/^static int getReadLock(winFile *pFile){$/;"	f	file:
getSafetyLevel	src/pragma.c	/^static int getSafetyLevel(const char *z){$/;"	f	file:
getStmtPointer	src/test1.c	/^static int getStmtPointer($/;"	f	file:
getTempStore	src/pragma.c	/^static int getTempStore(const char *z){$/;"	f	file:
getToken	ext/fts1/fts1.c	/^static int getToken(const char *z, int *tokenType){$/;"	f	file:
getToken	ext/fts2/fts2.c	/^static int getToken(const char *z, int *tokenType){$/;"	f	file:
getToken	src/tokenize.c	/^static int getToken(const unsigned char *z, int *tokenType){$/;"	f	file:
getValue	src/date.c	126;"	d	file:
getVarint	ext/fts1/fts1.c	/^static int getVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
getVarint	ext/fts2/fts2.c	/^static int getVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
getVarint	src/btreeInt.h	500;"	d
getVarint32	ext/fts1/fts1.c	/^static int getVarint32(const char *p, int *pi){$/;"	f	file:
getVarint32	ext/fts2/fts2.c	/^static int getVarint32(const char *p, int *pi){$/;"	f	file:
getVarint32	src/btreeInt.h	501;"	d
get_autocommit	src/sqlite3ext.h	/^  int  (*get_autocommit)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
get_autocommit	src/test1.c	/^static int get_autocommit($/;"	f	file:
get_auxdata	src/sqlite3ext.h	/^  void * (*get_auxdata)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
get_sqlite_pointer	src/test1.c	/^static int get_sqlite_pointer($/;"	f	file:
get_table	src/sqlite3ext.h	/^  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);$/;"	m	struct:sqlite3_api_routines
getstate	tool/lemon.c	/^PRIVATE struct state *getstate(lemp)$/;"	f
gfree	src/pager.c	/^  PagerLruLink gfree;            \/* Global list of nRef==0 pages *\/$/;"	m	struct:PgHdr	file:
globInfo	src/func.c	/^static const struct compareInfo globInfo = { '*', '?', '[', 0 };$/;"	v	typeref:struct:compareInfo	file:
global_recover	src/sqlite3ext.h	/^  int  (*global_recover)(void);$/;"	m	struct:sqlite3_api_routines
gp	tool/lemon.c	/^  struct lemon *gp;     \/* Global state vector *\/$/;"	m	struct:pstate	typeref:struct:pstate::lemon	file:
groupConcatFinalize	src/func.c	/^static void groupConcatFinalize(sqlite3_context *context){$/;"	f	file:
groupConcatStep	src/func.c	/^static void groupConcatStep($/;"	f	file:
h	src/date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
h	src/os_os2.c	/^  HFILE h;                  \/* Handle for accessing the file *\/$/;"	m	struct:os2File	file:
h	src/os_unix.c	/^  int h;                    \/* The file descriptor *\/$/;"	m	struct:unixFile	file:
h	src/os_win.c	/^  HANDLE h;               \/* Handle for accessing the file *\/$/;"	m	struct:winFile	file:
hMutex	src/os_win.c	/^  HANDLE hMutex;          \/* Mutex used to control access to shared lock *\/  $/;"	m	struct:winFile	file:
hShared	src/os_win.c	/^  HANDLE hShared;         \/* Shared memory segment used for locking *\/$/;"	m	struct:winFile	file:
halfFunc	src/test_loadext.c	/^static void halfFunc($/;"	f	file:
handle_D_option	tool/lemon.c	/^static void handle_D_option(char *z){$/;"	f	file:
handleflags	tool/lemon.c	/^static int handleflags(i,err)$/;"	f	file:
handleswitch	tool/lemon.c	/^static int handleswitch(i,err)$/;"	f	file:
hasAgg	src/sqliteInt.h	/^  u8 hasAgg;           \/* True if aggregates are seen *\/$/;"	m	struct:NameContext
hasData	src/btreeInt.h	/^  u8 hasData;          \/* True if this page stores data *\/$/;"	m	struct:MemPage
hasHotJournal	src/pager.c	/^static int hasHotJournal(Pager *pPager){$/;"	f	file:
hasPrimKey	src/sqliteInt.h	/^  u8 hasPrimKey;   \/* True if there exists a primary key *\/$/;"	m	struct:Table
hasVowel	ext/fts1/fts1_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
hasVowel	ext/fts2/fts2_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
hasVowel	ext/fts3/fts3_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
has_destructor	tool/lemon.c	/^int has_destructor(sp, lemp)$/;"	f
has_fallback	tool/lemon.c	/^  int has_fallback;        \/* True if any %fallback is seen in the grammer *\/$/;"	m	struct:lemon	file:
has_iPrevDocid	ext/fts2/fts2.c	/^  int has_iPrevDocid;$/;"	m	struct:DLWriter	file:
has_iPrevDocid	ext/fts3/fts3.c	/^  int has_iPrevDocid;$/;"	m	struct:DLWriter	file:
has_parent	ext/fts2/fts2.c	/^  int has_parent;$/;"	m	struct:LeafWriter	file:
has_parent	ext/fts3/fts3.c	/^  int has_parent;$/;"	m	struct:LeafWriter	file:
hash	src/vdbeInt.h	/^  Hash hash;             \/* A set is just a hash table *\/$/;"	m	struct:Set
hash	tool/mkkeywordhash.c	/^  int hash;            \/* Hash on the keyword *\/$/;"	m	struct:Keyword	file:
hashDestroy	ext/fts2/fts2.c	/^static void hashDestroy(void *p){$/;"	f	file:
hashDestroy	ext/fts3/fts3.c	/^static void hashDestroy(void *p){$/;"	f	file:
hashFunction	ext/fts1/fts1_hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashFunction	ext/fts2/fts2_hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashFunction	src/hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashString	src/test8.c	/^static int hashString(const char *zString){$/;"	f	file:
hdr	src/mem3.c	/^    } hdr;$/;"	m	union:Mem3Block::__anon19	typeref:struct:Mem3Block::__anon19::__anon20	file:
hdrOffset	src/btreeInt.h	/^  u8 hdrOffset;        \/* 100 for page 1.  0 otherwise *\/$/;"	m	struct:MemPage
heightOfExpr	src/expr.c	/^static void heightOfExpr(Expr *p, int *pnHeight){$/;"	f	file:
heightOfExprList	src/expr.c	/^static void heightOfExprList(ExprList *p, int *pnHeight){$/;"	f	file:
heightOfSelect	src/expr.c	/^static void heightOfSelect(Select *p, int *pnHeight){$/;"	f	file:
hex16Func	src/test1.c	/^static void hex16Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hex8Func	src/test1.c	/^static void hex8Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hexFunc	src/func.c	/^static void hexFunc($/;"	f	file:
hexToInt	src/test_malloc.c	/^static int hexToInt(int h){$/;"	f	file:
hexToInt	src/util.c	/^static int hexToInt(int h){$/;"	f	file:
hexdigits	src/func.c	/^static const char hexdigits[] = {$/;"	v	file:
hexio_get_int	src/test_hexio.c	/^static int hexio_get_int($/;"	f	file:
hexio_read	src/test_hexio.c	/^static int hexio_read($/;"	f	file:
hexio_render_int16	src/test_hexio.c	/^static int hexio_render_int16($/;"	f	file:
hexio_render_int32	src/test_hexio.c	/^static int hexio_render_int32($/;"	f	file:
hexio_write	src/test_hexio.c	/^static int hexio_write($/;"	f	file:
ht	ext/fts1/fts1_hash.h	/^  } *ht;$/;"	m	struct:fts1Hash	typeref:struct:fts1Hash::_fts1ht
ht	ext/fts2/fts2_hash.h	/^  } *ht;$/;"	m	struct:fts2Hash	typeref:struct:fts2Hash::_fts2ht
ht	ext/fts3/fts3_hash.h	/^  } *ht;$/;"	m	struct:fts3Hash	typeref:struct:fts3Hash::_fts3ht
ht	src/hash.h	/^  } *ht;$/;"	m	struct:Hash	typeref:struct:Hash::_ht
ht	tool/lemon.c	/^  struct s_x1node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x1	typeref:struct:s_x1::s_x1node	file:
ht	tool/lemon.c	/^  struct s_x2node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x2	typeref:struct:s_x2::s_x2node	file:
ht	tool/lemon.c	/^  struct s_x3node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x3	typeref:struct:s_x3::s_x3node	file:
ht	tool/lemon.c	/^  struct s_x4node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x4	typeref:struct:s_x4::s_x4node	file:
htsize	ext/fts1/fts1_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:fts1Hash
htsize	ext/fts2/fts2_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:fts2Hash
htsize	ext/fts3/fts3_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:fts3Hash
htsize	src/hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:Hash
hwtime	src/os_common.h	/^__inline__ unsigned long long int hwtime(void){$/;"	f
hwtime	src/vdbe.c	/^__inline__ unsigned long long int hwtime(void){$/;"	f
i	src/random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
i	src/vdbe.h	/^    int i;                 \/* Integer value if p4type==P4_INT32 *\/$/;"	m	union:VdbeOp::__anon23
i	src/vdbeInt.h	/^    i64 i;              \/* Integer value. Or FuncDef* when flags==MEM_Agg *\/$/;"	m	union:Mem::__anon17
i1	src/test_tclvar.c	/^  int i1;              \/* Current item in pList1 *\/$/;"	m	struct:tclvar_cursor	file:
i16	src/sqliteInt.h	/^typedef INT16_TYPE i16;            \/* 2-byte signed integer *\/$/;"	t
i2	src/test_tclvar.c	/^  int i2;              \/* Current item (if any) in pList2 *\/$/;"	m	struct:tclvar_cursor	file:
i64	src/sqliteInt.h	/^typedef sqlite_int64 i64;          \/* 8-byte signed integer *\/$/;"	t
i8	src/sqliteInt.h	/^typedef UINT8_TYPE i8;             \/* 1-byte signed integer *\/$/;"	t
iAgg	src/sqliteInt.h	/^  int iAgg;              \/* Which entry in pAggInfo->aCol[] or ->aFunc[] *\/$/;"	m	struct:Expr
iBlockid	ext/fts2/fts2.c	/^  sqlite_int64 iBlockid;$/;"	m	struct:InteriorReader	file:
iBlockid	ext/fts3/fts3.c	/^  sqlite_int64 iBlockid;$/;"	m	struct:InteriorReader	file:
iBreak	src/sqliteInt.h	/^  int iBreak;          \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereInfo
iCol	ext/fts1/fts1.c	/^    short int iCol;      \/* The column that contains the match *\/$/;"	m	struct:Snippet::snippetMatch	file:
iCol	ext/fts2/fts2.c	/^    short int iCol;      \/* The column that contains the match *\/$/;"	m	struct:Snippet::snippetMatch	file:
iCol	ext/fts3/fts3.c	/^    short int iCol;      \/* The column that contains the match *\/$/;"	m	struct:Snippet::snippetMatch	file:
iColumn	ext/fts1/fts1.c	/^  int iColumn;                     \/* Column being searched *\/$/;"	m	struct:fulltext_cursor	file:
iColumn	ext/fts1/fts1.c	/^  short int iColumn; \/* Column of the index that must match this term *\/$/;"	m	struct:QueryTerm	file:
iColumn	ext/fts2/fts2.c	/^  int iColumn;                     \/* Column being searched *\/$/;"	m	struct:fulltext_cursor	file:
iColumn	ext/fts2/fts2.c	/^  int iColumn;         \/* the last column read *\/$/;"	m	struct:PLReader	file:
iColumn	ext/fts2/fts2.c	/^  int iColumn;    \/* the last column written *\/$/;"	m	struct:PLWriter	file:
iColumn	ext/fts2/fts2.c	/^  short int iColumn; \/* Column of the index that must match this term *\/$/;"	m	struct:QueryTerm	file:
iColumn	ext/fts3/fts3.c	/^  int iColumn;                     \/* Column being searched *\/$/;"	m	struct:fulltext_cursor	file:
iColumn	ext/fts3/fts3.c	/^  int iColumn;         \/* the last column read *\/$/;"	m	struct:PLReader	file:
iColumn	ext/fts3/fts3.c	/^  int iColumn;    \/* the last column written *\/$/;"	m	struct:PLWriter	file:
iColumn	ext/fts3/fts3.c	/^  short int iColumn; \/* Column of the index that must match this term *\/$/;"	m	struct:QueryTerm	file:
iColumn	sqlite3.h	/^     int iColumn;              \/* Column number *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_orderby
iColumn	sqlite3.h	/^     int iColumn;              \/* Column on left-hand side of constraint *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint
iColumn	src/sqliteInt.h	/^    int iColumn;             \/* Column number within the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iColumn	src/sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iContinue	src/sqliteInt.h	/^  int iContinue;       \/* Jump here to continue with next record *\/$/;"	m	struct:WhereInfo
iCountdown	src/fault.c	/^  int iCountdown;   \/* Number of pending successes before we hit a failure *\/$/;"	m	struct:FaultInjector	file:
iCrash	src/test6.c	/^  int iCrash;                  \/* Crash on the iCrash'th call to xSync() *\/$/;"	m	struct:CrashGlobal	file:
iCur	src/sqliteInt.h	/^    int iCur;              \/* The VDBE cursor used by this IN operator *\/$/;"	m	struct:WhereLevel::InLoop
iCursor	src/sqliteInt.h	/^    int iCursor;      \/* The VDBE cursor number used to access this table *\/$/;"	m	struct:SrcList::SrcList_item
iCursorType	ext/fts1/fts1.c	/^  QueryType iCursorType;           \/* Copy of sqlite3_index_info.idxNum *\/$/;"	m	struct:fulltext_cursor	file:
iCursorType	ext/fts2/fts2.c	/^  QueryType iCursorType;           \/* Copy of sqlite3_index_info.idxNum *\/$/;"	m	struct:fulltext_cursor	file:
iCursorType	ext/fts3/fts3.c	/^  QueryType iCursorType;           \/* Copy of sqlite3_index_info.idxNum *\/$/;"	m	struct:fulltext_cursor	file:
iDb	src/build.c	/^  int iDb;             \/* The database containing the table to be locked *\/$/;"	m	struct:TableLock	file:
iDb	src/sqliteInt.h	/^    int iDb;                    \/* When back is being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
iDb	src/sqliteInt.h	/^  int iDb;            \/* 0 for main database.  1 for TEMP, 2.. for ATTACHed *\/$/;"	m	struct:__anon14
iDb	src/vdbeInt.h	/^  int iDb;              \/* Index of cursor database in db->aDb[] (or -1) *\/$/;"	m	struct:Cursor
iDeviceChar	src/test_devsym.c	/^  int iDeviceChar;$/;"	m	struct:DevsymGlobal	file:
iDeviceCharacteristics	src/test6.c	/^  int iDeviceCharacteristics;  \/* Value of simulated device characteristics *\/$/;"	m	struct:CrashGlobal	file:
iDflt	tool/lemon.c	/^  int iDflt;               \/* Default action *\/$/;"	m	struct:state	file:
iDistinct	src/sqliteInt.h	/^    int iDistinct;           \/* Ephermeral table used to enforce DISTINCT *\/$/;"	m	struct:AggInfo::AggInfo_func
iDocid	ext/fts2/fts2.c	/^  sqlite_int64 iDocid;$/;"	m	struct:DLReader	file:
iDocid	ext/fts3/fts3.c	/^  sqlite_int64 iDocid;$/;"	m	struct:DLReader	file:
iECursor	src/sqliteInt.h	/^  int iECursor;          \/* VDBE Cursor associated with this ExprList *\/$/;"	m	struct:ExprList
iEndBlockid	ext/fts2/fts2.c	/^  sqlite_int64 iEndBlockid;       \/* when we're done writing. *\/$/;"	m	struct:LeafWriter	file:
iEndBlockid	ext/fts3/fts3.c	/^  sqlite_int64 iEndBlockid;       \/* when we're done writing. *\/$/;"	m	struct:LeafWriter	file:
iEndOffset	ext/fts2/fts2.c	/^  int iEndOffset;      \/* the last end offset read *\/$/;"	m	struct:PLReader	file:
iEndOffset	ext/fts3/fts3.c	/^  int iEndOffset;      \/* the last end offset read *\/$/;"	m	struct:PLReader	file:
iForeGuard	src/mem2.c	/^  int iForeGuard;                     \/* Guard word for sanity *\/$/;"	m	struct:MemBlockHdr	file:
iFrom	src/sqliteInt.h	/^    int iFrom;         \/* Index of column in pFrom *\/$/;"	m	struct:FKey::sColMap
iFrom	src/sqliteInt.h	/^  int iFrom;            \/* Which entry in the FROM clause *\/$/;"	m	struct:WhereLevel
iHeight	ext/fts2/fts2.c	/^  int iHeight;                   \/* from 0 at leaves. *\/$/;"	m	struct:InteriorWriter	file:
iHeight	ext/fts3/fts3.c	/^  int iHeight;                   \/* from 0 at leaves. *\/$/;"	m	struct:InteriorWriter	file:
iIdxCur	src/sqliteInt.h	/^  int iIdxCur;          \/* The VDBE cursor used to acesss pIdx *\/$/;"	m	struct:WhereLevel
iInUseDB	src/pager.c	/^  int iInUseDB;               \/* Non-zero if in sqlite3_release_memory() *\/$/;"	m	struct:Pager	file:
iInUseMM	src/pager.c	/^  int iInUseMM;               \/* Non-zero if unavailable to MM *\/$/;"	m	struct:Pager	file:
iKey	src/vdbeInt.h	/^  i64 iKey;             \/* Key for the NEW or OLD pseudo-table row *\/$/;"	m	struct:Cursor
iLastChildBlock	ext/fts2/fts2.c	/^  sqlite_int64 iLastChildBlock;  \/* for consistency checks. *\/$/;"	m	struct:InteriorWriter	file:
iLastChildBlock	ext/fts3/fts3.c	/^  sqlite_int64 iLastChildBlock;  \/* for consistency checks. *\/$/;"	m	struct:InteriorWriter	file:
iLastColumn	ext/fts1/fts1.c	/^  int iLastColumn;    \/* the last column written *\/$/;"	m	struct:DocList	file:
iLastColumn	ext/fts1/fts1.c	/^  int iLastColumn;$/;"	m	struct:DocListReader	file:
iLastOffset	ext/fts1/fts1.c	/^  int iLastOffset;    \/* the last start offset written *\/$/;"	m	struct:DocList	file:
iLastPos	ext/fts1/fts1.c	/^  int iLastPos;       \/* the last position written *\/$/;"	m	struct:DocList	file:
iLastPos	ext/fts1/fts1.c	/^  int iLastPos;  \/* the last position read, or -1 when not in a position list *\/$/;"	m	struct:DocListReader	file:
iLeftJoin	src/sqliteInt.h	/^  int iLeftJoin;        \/* Memory cell used to implement LEFT OUTER JOIN *\/$/;"	m	struct:WhereLevel
iLevel	ext/fts2/fts2.c	/^  int iLevel;$/;"	m	struct:LeafWriter	file:
iLevel	ext/fts3/fts3.c	/^  int iLevel;$/;"	m	struct:LeafWriter	file:
iLimit	src/sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iMaster	src/mem3.c	/^  u32 iMaster;$/;"	m	struct:__anon22	file:
iMem	src/sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_col
iMem	src/sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_func
iMem	src/sqliteInt.h	/^  int iMem;             \/* First memory cell used by this level *\/$/;"	m	struct:WhereLevel
iMem	src/sqliteInt.h	/^  int iMem;         \/* Base register where results are written *\/$/;"	m	struct:SelectDest
iNext	tool/mkkeywordhash.c	/^  int iNext;           \/* Index in aKeywordTable[] of next with same hash *\/$/;"	m	struct:Keyword	file:
iNtOfst	tool/lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iOffset	ext/fts1/fts1_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	ext/fts1/fts1_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	ext/fts2/fts2.c	/^  int iOffset;    \/* the last start offset written *\/$/;"	m	struct:PLWriter	file:
iOffset	ext/fts2/fts2_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	ext/fts2/fts2_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	ext/fts3/fts3.c	/^  int iOffset;    \/* the last start offset written *\/$/;"	m	struct:PLWriter	file:
iOffset	ext/fts3/fts3_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	ext/fts3/fts3_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	src/sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iOffset	src/test6.c	/^  i64 iOffset;                 \/* Byte offset of the start of this write() *\/$/;"	m	struct:WriteBuffer	file:
iOffset	src/test_async.c	/^  i64 iOffset;        \/* See above *\/$/;"	m	struct:AsyncWrite	file:
iOffset	src/vdbeblob.c	/^  int iOffset;            \/* Byte offset of blob in cursor data *\/$/;"	m	struct:Incrblob	file:
iOpeningChildBlock	ext/fts2/fts2.c	/^  sqlite_int64 iOpeningChildBlock; \/* First child block in block "last". *\/$/;"	m	struct:InteriorWriter	file:
iOpeningChildBlock	ext/fts3/fts3.c	/^  sqlite_int64 iOpeningChildBlock; \/* First child block in block "last". *\/$/;"	m	struct:InteriorWriter	file:
iOverflow	src/btreeInt.h	/^  u16 iOverflow; \/* Offset to overflow page number.  Zero if no overflow *\/$/;"	m	struct:CellInfo
iPKey	src/sqliteInt.h	/^  int iPKey;       \/* If not less then 0, use aCol[iPKey] as the primary key *\/$/;"	m	struct:Table
iParent	src/where.c	/^  i16 iParent;            \/* Disable pWC->a[iParent] when this term disabled *\/$/;"	m	struct:WhereTerm	file:
iParm	src/sqliteInt.h	/^  int iParm;        \/* A parameter used by the eDest disposal method *\/$/;"	m	struct:SelectDest
iPhrase	ext/fts1/fts1.c	/^  short int iPhrase; \/* This is the i-th term of a phrase. *\/$/;"	m	struct:QueryTerm	file:
iPhrase	ext/fts2/fts2.c	/^  short int iPhrase; \/* This is the i-th term of a phrase. *\/$/;"	m	struct:QueryTerm	file:
iPhrase	ext/fts3/fts3.c	/^  short int iPhrase; \/* This is the i-th term of a phrase. *\/$/;"	m	struct:QueryTerm	file:
iPos	ext/fts2/fts2.c	/^  int iPos;       \/* the last position written *\/$/;"	m	struct:PLWriter	file:
iPos	ext/fts3/fts3.c	/^  int iPos;       \/* the last position written *\/$/;"	m	struct:PLWriter	file:
iPosition	ext/fts2/fts2.c	/^  int iPosition;       \/* the last position read *\/$/;"	m	struct:PLReader	file:
iPosition	ext/fts3/fts3.c	/^  int iPosition;       \/* the last position read *\/$/;"	m	struct:PLReader	file:
iPrefEnc	src/sqliteInt.h	/^  u8 iPrefEnc;         \/* Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) *\/$/;"	m	struct:FuncDef
iPrevDocid	ext/fts2/fts2.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:DLWriter	file:
iPrevDocid	ext/fts2/fts2.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:fulltext_vtab	file:
iPrevDocid	ext/fts3/fts3.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:DLWriter	file:
iPrevDocid	ext/fts3/fts3.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:fulltext_vtab	file:
iRangeReg	src/sqliteInt.h	/^  int iRangeReg;       \/* First register in temporary register block *\/$/;"	m	struct:Parse
iRead	src/vdbeInt.h	/^  int iRead;         \/* Read the next value from this entry in aSlot[] *\/$/;"	m	struct:FifoPage
iRightJoinTable	src/sqliteInt.h	/^  int iRightJoinTable;   \/* If EP_FromJoin, the right table of the join *\/$/;"	m	struct:Expr
iSectorSize	src/test6.c	/^  int iSectorSize;             \/* Value of simulated sector size *\/$/;"	m	struct:CrashGlobal	file:
iSectorSize	src/test_devsym.c	/^  int iSectorSize;$/;"	m	struct:DevsymGlobal	file:
iSeek	src/tclsqlite.c	/^  int iSeek;                \/* Current seek offset *\/$/;"	m	struct:IncrblobChannel	file:
iSize	src/journal.c	/^  int iSize;                      \/* Amount of zBuf[] currently used *\/$/;"	m	struct:JournalFile	file:
iSize	src/mem2.c	/^  int iSize;                          \/* Size of this allocation *\/$/;"	m	struct:MemBlockHdr	file:
iSize	src/test6.c	/^  int iSize;                           \/* Size of file in bytes *\/$/;"	m	struct:CrashFile	file:
iSorterColumn	src/sqliteInt.h	/^    int iSorterColumn;       \/* Column number in the sorting index *\/$/;"	m	struct:AggInfo::AggInfo_col
iStart	ext/fts1/fts1.c	/^    int iStart;          \/* The offset to the first character of the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iStart	ext/fts2/fts2.c	/^    int iStart;          \/* The offset to the first character of the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iStart	ext/fts3/fts3.c	/^    int iStart;          \/* The offset to the first character of the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iStartBlockid	ext/fts2/fts2.c	/^  sqlite_int64 iStartBlockid;     \/* needed to create the root info *\/$/;"	m	struct:LeafWriter	file:
iStartBlockid	ext/fts3/fts3.c	/^  sqlite_int64 iStartBlockid;     \/* needed to create the root info *\/$/;"	m	struct:LeafWriter	file:
iStartOffset	ext/fts2/fts2.c	/^  int iStartOffset;    \/* the last start offset read *\/$/;"	m	struct:PLReader	file:
iStartOffset	ext/fts3/fts3.c	/^  int iStartOffset;    \/* the last start offset read *\/$/;"	m	struct:PLReader	file:
iSum	src/func.c	/^  i64 iSum;         \/* Integer sum *\/   $/;"	m	struct:SumCtx	file:
iTab	src/build.c	/^  int iTab;            \/* The root page of the table to be locked *\/$/;"	m	struct:TableLock	file:
iTabCur	src/sqliteInt.h	/^  int iTabCur;          \/* The VDBE cursor used to access the table *\/$/;"	m	struct:WhereLevel
iTable	src/btreeInt.h	/^  Pgno iTable;          \/* Root page of table *\/$/;"	m	struct:BtLock
iTable	src/sqliteInt.h	/^    int iTable;              \/* Cursor number of the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iTable	src/sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iTerm	ext/fts1/fts1.c	/^    short int iTerm;     \/* The index in Query.pTerms[] of the matching term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iTerm	ext/fts2/fts2.c	/^    short int iTerm;     \/* The index in Query.pTerms[] of the matching term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iTerm	ext/fts3/fts3.c	/^    short int iTerm;     \/* The index in Query.pTerms[] of the matching term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iTermOffset	sqlite3.h	/^     int iTermOffset;          \/* Used internally - xBestIndex should ignore *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint
iTknOfst	tool/lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iToken	ext/fts1/fts1_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	ext/fts1/fts1_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	ext/fts2/fts2_icu.c	/^  int iToken;$/;"	m	struct:IcuCursor	file:
iToken	ext/fts2/fts2_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	ext/fts2/fts2_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	ext/fts3/fts3.c	/^    int iToken;          \/* The index of the matching document token *\/$/;"	m	struct:Snippet::snippetMatch	file:
iToken	ext/fts3/fts3_icu.c	/^  int iToken;$/;"	m	struct:IcuCursor	file:
iToken	ext/fts3/fts3_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	ext/fts3/fts3_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iTop	src/sqliteInt.h	/^  int iTop;            \/* The very beginning of the WHERE loop *\/$/;"	m	struct:WhereInfo
iType	ext/fts1/fts1.c	/^  DocListType iType;$/;"	m	struct:DocList	file:
iType	ext/fts2/fts2.c	/^  DocListType iType;$/;"	m	struct:DLReader	file:
iType	ext/fts2/fts2.c	/^  DocListType iType;$/;"	m	struct:DLWriter	file:
iType	ext/fts2/fts2.c	/^  DocListType iType;$/;"	m	struct:PLReader	file:
iType	ext/fts3/fts3.c	/^  DocListType iType;$/;"	m	struct:DLReader	file:
iType	ext/fts3/fts3.c	/^  DocListType iType;$/;"	m	struct:DLWriter	file:
iType	ext/fts3/fts3.c	/^  DocListType iType;$/;"	m	struct:PLReader	file:
iVersion	ext/fts1/fts1_tokenizer.h	/^  int iVersion;                  \/* currently 0 *\/$/;"	m	struct:sqlite3_tokenizer_module
iVersion	ext/fts2/fts2_tokenizer.h	/^  int iVersion;$/;"	m	struct:sqlite3_tokenizer_module
iVersion	ext/fts3/fts3_tokenizer.h	/^  int iVersion;$/;"	m	struct:sqlite3_tokenizer_module
iVersion	sqlite3.h	/^  int iVersion;            \/* Structure version number *\/$/;"	m	struct:sqlite3_vfs
iVersion	sqlite3.h	/^  int iVersion;$/;"	m	struct:sqlite3_io_methods
iVersion	sqlite3.h	/^  int iVersion;$/;"	m	struct:sqlite3_module
iWrite	src/vdbeInt.h	/^  int iWrite;        \/* Push the next value into this entry in aSlot[] *\/$/;"	m	struct:FifoPage
icuCaseFunc16	ext/icu/icu.c	/^static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){$/;"	f	file:
icuClose	ext/fts2/fts2_icu.c	/^static int icuClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
icuClose	ext/fts3/fts3_icu.c	/^static int icuClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
icuCollationColl	ext/icu/icu.c	/^static int icuCollationColl($/;"	f	file:
icuCollationDel	ext/icu/icu.c	/^static void icuCollationDel(void *pCtx){$/;"	f	file:
icuCreate	ext/fts2/fts2_icu.c	/^static int icuCreate($/;"	f	file:
icuCreate	ext/fts3/fts3_icu.c	/^static int icuCreate($/;"	f	file:
icuDestroy	ext/fts2/fts2_icu.c	/^static int icuDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
icuDestroy	ext/fts3/fts3_icu.c	/^static int icuDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
icuFunctionError	ext/icu/icu.c	/^static void icuFunctionError($/;"	f	file:
icuLikeCompare	ext/icu/icu.c	/^static int icuLikeCompare($/;"	f	file:
icuLikeFunc	ext/icu/icu.c	/^static void icuLikeFunc($/;"	f	file:
icuLoadCollation	ext/icu/icu.c	/^static void icuLoadCollation($/;"	f	file:
icuNext	ext/fts2/fts2_icu.c	/^static int icuNext($/;"	f	file:
icuNext	ext/fts3/fts3_icu.c	/^static int icuNext($/;"	f	file:
icuOpen	ext/fts2/fts2_icu.c	/^static int icuOpen($/;"	f	file:
icuOpen	ext/fts3/fts3_icu.c	/^static int icuOpen($/;"	f	file:
icuRegexpDelete	ext/icu/icu.c	/^static void icuRegexpDelete(void *p){$/;"	f	file:
icuRegexpFunc	ext/icu/icu.c	/^static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){$/;"	f	file:
icuTokenizerModule	ext/fts2/fts2_icu.c	/^static const sqlite3_tokenizer_module icuTokenizerModule = {$/;"	v	file:
icuTokenizerModule	ext/fts3/fts3_icu.c	/^static const sqlite3_tokenizer_module icuTokenizerModule = {$/;"	v	file:
id	src/mutex.c	/^  int id;     \/* The mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	src/mutex_os2.c	/^  int  id;          \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	src/mutex_unix.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	src/mutex_w32.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	tool/mkkeywordhash.c	/^  int id;              \/* Unique ID for this record *\/$/;"	m	struct:Keyword	file:
idChar	ext/fts1/fts1_porter.c	571;"	d	file:
identLength	src/build.c	/^static int identLength(const char *z){$/;"	f	file:
identPut	src/build.c	/^static void identPut(char *z, int *pIdx, char *zSignedIdent){$/;"	f	file:
idx	ext/fts2/fts2.c	/^  int idx;                  \/* Index within the segment. *\/$/;"	m	struct:LeavesReader	file:
idx	ext/fts2/fts2.c	/^  int idx;$/;"	m	struct:LeafWriter	file:
idx	ext/fts2/fts2.c	/^  int idx;$/;"	m	struct:OrderedDLReader	file:
idx	ext/fts3/fts3.c	/^  int idx;                  \/* Index within the segment. *\/$/;"	m	struct:LeavesReader	file:
idx	ext/fts3/fts3.c	/^  int idx;$/;"	m	struct:LeafWriter	file:
idx	ext/fts3/fts3.c	/^  int idx;$/;"	m	struct:OrderedDLReader	file:
idx	src/btreeInt.h	/^    u16 idx;            \/* Insert this cell before idx-th non-overflow cell *\/$/;"	m	struct:MemPage::_OvflCell
idx	src/btreeInt.h	/^  int idx;                  \/* Index of the entry in pPage->aCell[] *\/$/;"	m	struct:BtCursor
idx	src/sqliteInt.h	/^    int idx;          \/* Index in some Table.aCol[] of a column named zName *\/$/;"	m	struct:IdList::IdList_item
idxHash	src/sqliteInt.h	/^  Hash idxHash;        \/* All (named) indices indexed by name *\/$/;"	m	struct:Schema
idxNum	sqlite3.h	/^  int idxNum;                \/* Number used to identify the index *\/$/;"	m	struct:sqlite3_index_info
idxParent	src/btreeInt.h	/^  u16 idxParent;       \/* Index in parent of this node *\/$/;"	m	struct:MemPage
idxShift	src/btreeInt.h	/^  u8 idxShift;         \/* True if Cell indices have changed *\/$/;"	m	struct:MemPage
idxStr	sqlite3.h	/^  char *idxStr;              \/* String, possibly obtained from sqlite3_malloc *\/$/;"	m	struct:sqlite3_index_info
ifcapable	test/tester.tcl	/^proc ifcapable {expr code {else ""} {elsecode ""}} {$/;"	p
ifnullFunc	src/func.c	/^static void ifnullFunc($/;"	f	file:
ignoreJump	src/sqliteInt.h	/^  int ignoreJump;      \/* where to jump to for a RAISE(IGNORE) *\/$/;"	m	struct:TriggerStack
in	src/test_md5.c	/^  unsigned char in[64];$/;"	m	struct:Context	file:
inJournal	src/pager.c	/^  u8 inJournal;                  \/* TRUE if has been written to journal *\/$/;"	m	struct:PgHdr	file:
inStmt	src/btreeInt.h	/^  u8 inStmt;            \/* True if we are in a statement subtransaction *\/$/;"	m	struct:BtShared
inStmt	src/pager.c	/^  u8 inStmt;                     \/* TRUE if in the statement subjournal *\/$/;"	m	struct:PgHistory	file:
inTempTrans	src/vdbeInt.h	/^  int inTempTrans;        \/* True if temp database is transactioned *\/$/;"	m	struct:Vdbe
inTrans	src/btreeInt.h	/^  u8 inTrans;        \/* TRANS_NONE, TRANS_READ or TRANS_WRITE *\/$/;"	m	struct:Btree
inTrans	src/sqliteInt.h	/^  u8 inTrans;          \/* 0: not writable.  1: Transaction.  2: Checkpoint *\/$/;"	m	struct:Db
inTransaction	src/btreeInt.h	/^  u8 inTransaction;     \/* Transaction state *\/$/;"	m	struct:BtShared
inVtabMethod	src/vdbeInt.h	/^  u8 inVtabMethod;        \/* See comments above *\/$/;"	m	struct:Vdbe
include	tool/lemon.c	/^  char *include;           \/* Code to put at the start of the C file *\/$/;"	m	struct:lemon	file:
includeln	tool/lemon.c	/^  int  includeln;          \/* Line number for start of include code *\/$/;"	m	struct:lemon	file:
incrKey	src/sqliteInt.h	/^  u8 incrKey;         \/* Increase 2nd key by epsilon before comparison *\/$/;"	m	struct:KeyInfo
incrOpenFileCount	src/test_async.c	/^static void incrOpenFileCount(){$/;"	f	file:
incrVacuum	src/btreeInt.h	/^  u8 incrVacuum;        \/* True if incr-vacuum is enabled *\/$/;"	m	struct:BtShared
incrVacuumStep	src/btree.c	/^static int incrVacuumStep(BtShared *pBt, Pgno nFin){$/;"	f	file:
incrblobClose	src/tclsqlite.c	/^static int incrblobClose(ClientData instanceData, Tcl_Interp *interp){$/;"	f	file:
incrblobHandle	src/tclsqlite.c	/^static int incrblobHandle(ClientData instanceData, int dir, ClientData *hPtr){$/;"	f	file:
incrblobInput	src/tclsqlite.c	/^static int incrblobInput($/;"	f	file:
incrblobOutput	src/tclsqlite.c	/^static int incrblobOutput($/;"	f	file:
incrblobSeek	src/tclsqlite.c	/^static int incrblobSeek($/;"	f	file:
incrblobWatch	src/tclsqlite.c	/^static void incrblobWatch(ClientData instanceData, int mode){ $/;"	f	file:
index	tool/lemon.c	/^  int index;               \/* An index number for this rule *\/$/;"	m	struct:rule	file:
index	tool/lemon.c	/^  int index;               \/* Index number for this symbol *\/$/;"	m	struct:symbol	file:
index_delete	ext/fts1/fts1.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow, fts1Hash *pTerms){$/;"	f	file:
index_delete	ext/fts2/fts2.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
index_delete	ext/fts3/fts3.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
index_insert	ext/fts1/fts1.c	/^static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestRowid,$/;"	f	file:
index_insert	ext/fts2/fts2.c	/^static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestRowid,$/;"	f	file:
index_insert	ext/fts3/fts3.c	/^static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestDocid,$/;"	f	file:
index_insert_term	ext/fts1/fts1.c	/^static int index_insert_term(fulltext_vtab *v, const char *pTerm, int nTerm,$/;"	f	file:
index_update	ext/fts1/fts1.c	/^static int index_update(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
index_update	ext/fts2/fts2.c	/^static int index_update(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
index_update	ext/fts3/fts3.c	/^static int index_update(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
info	src/btreeInt.h	/^  CellInfo info;            \/* A parse of the cell we are pointing at *\/$/;"	m	struct:BtCursor
init	src/sqliteInt.h	/^  } init;$/;"	m	struct:sqlite3	typeref:struct:sqlite3::sqlite3InitInfo
initMaskSet	src/where.c	285;"	d	file:
initPendingTerms	ext/fts2/fts2.c	/^static int initPendingTerms(fulltext_vtab *v, sqlite_int64 iDocid){$/;"	f	file:
initPendingTerms	ext/fts3/fts3.c	/^static int initPendingTerms(fulltext_vtab *v, sqlite_int64 iDocid){$/;"	f	file:
initStringBuffer	ext/fts1/fts1.c	/^static void initStringBuffer(StringBuffer *sb){$/;"	f	file:
initStringBuffer	ext/fts2/fts2.c	/^static void initStringBuffer(StringBuffer *sb){$/;"	f	file:
initStringBuffer	ext/fts3/fts3.c	/^static void initStringBuffer(StringBuffer *sb){$/;"	f	file:
ino	src/os_unix.c	/^  ino_t ino;       \/* Inode number *\/$/;"	m	struct:lockKey	file:
ino	src/os_unix.c	/^  ino_t ino;   \/* Inode number *\/$/;"	m	struct:openKey	file:
input	parse.y	/^input ::= cmdlist.$/;"	l
input	src/parse.y	/^input ::= cmdlist.$/;"	l
insertCell	src/btree.c	/^static int insertCell($/;"	f	file:
insertConf	src/sqliteInt.h	/^  u8 insertConf;    \/* How to resolve conflicts that occur on INSERT *\/$/;"	m	struct:FKey
insertElement	ext/fts1/fts1_hash.c	/^static void insertElement($/;"	f	file:
insertElement	ext/fts2/fts2_hash.c	/^static void insertElement($/;"	f	file:
insertElement	src/hash.c	/^static void insertElement($/;"	f	file:
insertTerms	ext/fts1/fts1.c	/^static int insertTerms(fulltext_vtab *v, fts1Hash *terms, sqlite_int64 iRowid,$/;"	f	file:
insertTerms	ext/fts2/fts2.c	/^static int insertTerms(fulltext_vtab *v, sqlite_int64 iRowid,$/;"	f	file:
insertTerms	ext/fts3/fts3.c	/^static int insertTerms(fulltext_vtab *v, sqlite_int64 iDocid,$/;"	f	file:
intKey	src/btreeInt.h	/^  u8 intKey;           \/* True if intkey flag is set *\/$/;"	m	struct:MemPage
intTestFunc	ext/fts2/fts2_tokenizer.c	/^static void intTestFunc($/;"	f	file:
intTestFunc	ext/fts3/fts3_tokenizer.c	/^static void intTestFunc($/;"	f	file:
intToKey	src/vdbeInt.h	26;"	d
integerify	tool/spaceanal.tcl	/^proc integerify {real} {$/;"	p
integrity_check	test/tester.tcl	/^proc integrity_check {name} {$/;"	p
integrity_check	test/threadtest2.c	/^int integrity_check(sqlite *db, int id){$/;"	f
interiorBlockNew	ext/fts2/fts2.c	/^static InteriorBlock *interiorBlockNew(int iHeight, sqlite_int64 iChildBlock,$/;"	f	file:
interiorBlockNew	ext/fts3/fts3.c	/^static InteriorBlock *interiorBlockNew(int iHeight, sqlite_int64 iChildBlock,$/;"	f	file:
interiorBlockValidate	ext/fts2/fts2.c	/^static void interiorBlockValidate(InteriorBlock *pBlock){$/;"	f	file:
interiorBlockValidate	ext/fts3/fts3.c	/^static void interiorBlockValidate(InteriorBlock *pBlock){$/;"	f	file:
interiorReaderAtEnd	ext/fts2/fts2.c	/^static int interiorReaderAtEnd(InteriorReader *pReader){$/;"	f	file:
interiorReaderAtEnd	ext/fts3/fts3.c	/^static int interiorReaderAtEnd(InteriorReader *pReader){$/;"	f	file:
interiorReaderCurrentBlockid	ext/fts2/fts2.c	/^static sqlite_int64 interiorReaderCurrentBlockid(InteriorReader *pReader){$/;"	f	file:
interiorReaderCurrentBlockid	ext/fts3/fts3.c	/^static sqlite_int64 interiorReaderCurrentBlockid(InteriorReader *pReader){$/;"	f	file:
interiorReaderDestroy	ext/fts2/fts2.c	/^static void interiorReaderDestroy(InteriorReader *pReader){$/;"	f	file:
interiorReaderDestroy	ext/fts3/fts3.c	/^static void interiorReaderDestroy(InteriorReader *pReader){$/;"	f	file:
interiorReaderInit	ext/fts2/fts2.c	/^static void interiorReaderInit(const char *pData, int nData,$/;"	f	file:
interiorReaderInit	ext/fts3/fts3.c	/^static void interiorReaderInit(const char *pData, int nData,$/;"	f	file:
interiorReaderStep	ext/fts2/fts2.c	/^static void interiorReaderStep(InteriorReader *pReader){$/;"	f	file:
interiorReaderStep	ext/fts3/fts3.c	/^static void interiorReaderStep(InteriorReader *pReader){$/;"	f	file:
interiorReaderTerm	ext/fts2/fts2.c	/^static const char *interiorReaderTerm(InteriorReader *pReader){$/;"	f	file:
interiorReaderTerm	ext/fts3/fts3.c	/^static const char *interiorReaderTerm(InteriorReader *pReader){$/;"	f	file:
interiorReaderTermBytes	ext/fts2/fts2.c	/^static int interiorReaderTermBytes(InteriorReader *pReader){$/;"	f	file:
interiorReaderTermBytes	ext/fts3/fts3.c	/^static int interiorReaderTermBytes(InteriorReader *pReader){$/;"	f	file:
interiorReaderTermCmp	ext/fts2/fts2.c	/^static int interiorReaderTermCmp(InteriorReader *pReader,$/;"	f	file:
interiorReaderTermCmp	ext/fts3/fts3.c	/^static int interiorReaderTermCmp(InteriorReader *pReader,$/;"	f	file:
interiorWriterAppend	ext/fts2/fts2.c	/^static void interiorWriterAppend(InteriorWriter *pWriter,$/;"	f	file:
interiorWriterAppend	ext/fts3/fts3.c	/^static void interiorWriterAppend(InteriorWriter *pWriter,$/;"	f	file:
interiorWriterDestroy	ext/fts2/fts2.c	/^static int interiorWriterDestroy(InteriorWriter *pWriter){$/;"	f	file:
interiorWriterDestroy	ext/fts3/fts3.c	/^static int interiorWriterDestroy(InteriorWriter *pWriter){$/;"	f	file:
interiorWriterInit	ext/fts2/fts2.c	/^static void interiorWriterInit(int iHeight, const char *pTerm, int nTerm,$/;"	f	file:
interiorWriterInit	ext/fts3/fts3.c	/^static void interiorWriterInit(int iHeight, const char *pTerm, int nTerm,$/;"	f	file:
interiorWriterRootInfo	ext/fts2/fts2.c	/^static int interiorWriterRootInfo(fulltext_vtab *v, InteriorWriter *pWriter,$/;"	f	file:
interiorWriterRootInfo	ext/fts3/fts3.c	/^static int interiorWriterRootInfo(fulltext_vtab *v, InteriorWriter *pWriter,$/;"	f	file:
interp	src/tclsqlite.c	/^  Tcl_Interp *interp;        \/* The interpreter used for this database *\/$/;"	m	struct:SqliteDb	file:
interp	src/tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlCollate	file:
interp	src/tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlFunc	file:
interp	src/test1.c	/^  Tcl_Interp *interp;$/;"	m	struct:TestCollationX	file:
interp	src/test8.c	/^  Tcl_Interp *interp;     \/* Tcl interpreter containing debug variables *\/$/;"	m	struct:echo_vtab	file:
interp	src/test8.c	/^  Tcl_Interp *interp;$/;"	m	struct:EchoModule	file:
interp	src/test_tclvar.c	/^  Tcl_Interp *interp;$/;"	m	struct:tclvar_vtab	file:
interp	src/test_thread.c	/^  Tcl_Interp *interp;      \/* Parent interpreter *\/$/;"	m	struct:SqlThread	file:
interp	src/test_thread.c	/^  Tcl_Interp *interp;      \/* The interpreter to execute it in. *\/$/;"	m	struct:EvalEvent	file:
interrupt_handler	src/shell.c	/^static void interrupt_handler(int NotUsed){$/;"	f	file:
interruptx	src/sqlite3ext.h	/^  void  (*interruptx)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
invalidateAllOverflowCache	src/btree.c	/^static void invalidateAllOverflowCache(BtShared *pBt){$/;"	f	file:
invalidateAllOverflowCache	src/btree.c	280;"	d	file:
invalidateCursorsOnModifiedBtrees	src/vdbeaux.c	/^static void invalidateCursorsOnModifiedBtrees(sqlite3 *db){$/;"	f	file:
invalidateOverflowCache	src/btree.c	/^static void invalidateOverflowCache(BtCursor *pCur){$/;"	f	file:
invalidateOverflowCache	src/btree.c	279;"	d	file:
invalidateTempStorage	src/pragma.c	/^static int invalidateTempStorage(Parse *pParse){$/;"	f	file:
ioDelay	src/test_async.c	/^  volatile int ioDelay;             \/* Extra delay between write operations *\/$/;"	m	struct:TestAsyncStaticData	file:
ioError	src/test_async.c	/^  int ioError;                 \/* True if an IO error has occured *\/$/;"	m	struct:TestAsyncStaticData	file:
io_trace_callback	src/test1.c	/^static void io_trace_callback(const char *zFormat, ...){$/;"	f	file:
iotrace	src/shell.c	/^static FILE *iotrace = 0;$/;"	v	file:
iotracePrintf	src/shell.c	/^static void iotracePrintf(const char *zFormat, ...){$/;"	f	file:
iotrace_file	src/test1.c	/^static FILE *iotrace_file = 0;$/;"	v	file:
isAgg	src/sqliteInt.h	/^    u8 isAgg;              \/* True if this is an aggregate like count(*) *\/$/;"	m	struct:ExprList::ExprList_item
isAgg	src/sqliteInt.h	/^  u8 isAgg;              \/* True if this is an aggregate query *\/$/;"	m	struct:Select
isCheck	src/sqliteInt.h	/^  u8 isCheck;          \/* True if resolving names in a CHECK constraint *\/$/;"	m	struct:NameContext
isCommit	src/sqliteInt.h	/^  u8 isCommit;              \/* True once the CREATE TABLE has been committed *\/$/;"	m	struct:Table
isConsonant	ext/fts1/fts1_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isConsonant	ext/fts2/fts2_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isConsonant	ext/fts3/fts3_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isDate	src/date.c	/^static int isDate($/;"	f	file:
isDeferred	src/sqliteInt.h	/^  u8 isDeferred;    \/* True if constraint checking is deferred till COMMIT *\/$/;"	m	struct:FKey
isDelim	ext/fts1/fts1_porter.c	572;"	d	file:
isDelim	ext/fts1/fts1_tokenizer1.c	/^static int isDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
isDelim	ext/fts2/fts2_porter.c	571;"	d	file:
isDelim	ext/fts3/fts3_porter.c	571;"	d	file:
isDistinct	src/sqliteInt.h	/^  u8 isDistinct;         \/* True if the DISTINCT keyword is present *\/$/;"	m	struct:Select
isEphem	src/sqliteInt.h	/^  u8 isEphem;      \/* True if created using OP_OpenEphermeral *\/$/;"	m	struct:Table
isError	src/vdbeInt.h	/^  u8 isError;           \/* Set to true for an error *\/$/;"	m	struct:sqlite3_context
isFtsIdChar	ext/fts3/fts3.c	/^static const char isFtsIdChar[] = {$/;"	v	file:
isHidden	src/sqliteInt.h	/^  u8 isHidden;     \/* True if this column is 'hidden' *\/$/;"	m	struct:Column
isIdChar	ext/fts1/fts1.c	/^static const char isIdChar[] = {$/;"	v	file:
isIdChar	ext/fts1/fts1_porter.c	/^static const char isIdChar[] = {$/;"	v	file:
isIdChar	ext/fts2/fts2.c	/^static const char isIdChar[] = {$/;"	v	file:
isIncrblobHandle	src/btreeInt.h	/^  u8 isIncrblobHandle;      \/* True if this cursor is an incr. io handle *\/$/;"	m	struct:BtCursor
isIndex	src/vdbeInt.h	/^  Bool isIndex;         \/* True if an index containing keys only - no data *\/$/;"	m	struct:Cursor
isInit	src/btreeInt.h	/^  u8 isInit;           \/* True if previously initialized. MUST BE FIRST! *\/$/;"	m	struct:MemPage
isInit	src/random.c	/^  unsigned char isInit;          \/* True if initialized *\/$/;"	m	struct:sqlite3PrngType	file:
isInit	src/test_md5.c	/^  int isInit;$/;"	m	struct:Context	file:
isInterrupted	src/sqliteInt.h	/^    int isInterrupted;          \/* True if sqlite3_interrupt has been called *\/$/;"	m	union:sqlite3::__anon13
isLikeOrGlob	src/where.c	/^static int isLikeOrGlob($/;"	f	file:
isMatchOfColumn	src/where.c	/^static int isMatchOfColumn($/;"	f	file:
isNT	src/os_win.c	/^  static int isNT(void){$/;"	f	file:
isNT	src/os_win.c	137;"	d	file:
isNot	ext/fts1/fts1.c	/^  signed char isNot; \/* this term is preceded by "-" *\/$/;"	m	struct:QueryTerm	file:
isNot	ext/fts2/fts2.c	/^  signed char isNot; \/* this term is preceded by "-" *\/$/;"	m	struct:QueryTerm	file:
isNot	ext/fts3/fts3.c	/^  signed char isNot; \/* this term is preceded by "-" *\/$/;"	m	struct:QueryTerm	file:
isNumber	src/shell.c	/^static int isNumber(const char *z, int *realnum){$/;"	f	file:
isOr	ext/fts1/fts1.c	/^  signed char isOr;  \/* this term is preceded by "OR" *\/$/;"	m	struct:QueryTerm	file:
isOr	ext/fts2/fts2.c	/^  signed char isOr;  \/* this term is preceded by "OR" *\/$/;"	m	struct:QueryTerm	file:
isOr	ext/fts3/fts3.c	/^  signed char isOr;  \/* this term is preceded by "OR" *\/$/;"	m	struct:QueryTerm	file:
isPattern	src/test8.c	/^  int isPattern;$/;"	m	struct:echo_vtab	file:
isPopulated	src/sqliteInt.h	/^    u8 isPopulated;   \/* Temporary table associated with SELECT is populated *\/$/;"	m	struct:SrcList::SrcList_item
isPrefix	ext/fts2/fts2.c	/^  signed char isPrefix; \/* this term is followed by "*" *\/$/;"	m	struct:QueryTerm	file:
isPrefix	ext/fts3/fts3.c	/^  signed char isPrefix; \/* this term is followed by "*" *\/$/;"	m	struct:QueryTerm	file:
isPrimKey	src/sqliteInt.h	/^  u8 isPrimKey;    \/* True if this column is part of the PRIMARY KEY *\/$/;"	m	struct:Column
isResolved	src/sqliteInt.h	/^  u8 isResolved;         \/* True once sqlite3SelectResolve() has run. *\/$/;"	m	struct:Select
isSortingIndex	src/where.c	/^static int isSortingIndex($/;"	f	file:
isTable	src/vdbeInt.h	/^  Bool isTable;         \/* True if a table requiring integer keys *\/$/;"	m	struct:Cursor
isTkn	tool/lemon.c	/^  int isTkn;           \/* True to use tokens.  False for non-terminals *\/$/;"	m	struct:axset	file:
isView	src/delete.c	147;"	d	file:
isView	src/delete.c	148;"	d	file:
isView	src/insert.c	421;"	d	file:
isView	src/insert.c	422;"	d	file:
isView	src/update.c	151;"	d	file:
isView	src/update.c	152;"	d	file:
isVirtual	src/sqliteInt.h	/^  u8 isVirtual;             \/* True if this is a virtual table *\/$/;"	m	struct:Table
isVowel	ext/fts1/fts1_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isVowel	ext/fts2/fts2_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isVowel	ext/fts3/fts3_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isWriteLock	src/build.c	/^  u8 isWriteLock;      \/* True for write lock.  False for a read lock *\/$/;"	m	struct:TableLock	file:
isatty	src/shell.c	60;"	d	file:
ix	src/where.c	/^  int ix[sizeof(Bitmask)*8];    \/* Cursor assigned to each bit *\/$/;"	m	struct:ExprMaskSet	file:
j	src/random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
jfd	src/pager.c	/^  sqlite3_file *fd, *jfd;     \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
jointype	src/sqliteInt.h	/^    u8 jointype;      \/* Type of join between this able and the previous *\/$/;"	m	struct:SrcList::SrcList_item
journalHdr	src/pager.c	/^  i64 journalHdr;             \/* Byte offset to previous journal header *\/$/;"	m	struct:Pager	file:
journalOff	src/pager.c	/^  i64 journalOff;             \/* Current byte offset in the journal file *\/$/;"	m	struct:Pager	file:
journalOpen	src/pager.c	/^  u8 journalOpen;             \/* True if journal file descriptors is valid *\/$/;"	m	struct:Pager	file:
journalStarted	src/pager.c	/^  u8 journalStarted;          \/* True if header of journal is synced *\/$/;"	m	struct:Pager	file:
jrnlBufferSize	src/pager.c	/^static int jrnlBufferSize(Pager *pPager){$/;"	f	file:
jrnlClose	src/journal.c	/^static int jrnlClose(sqlite3_file *pJfd){$/;"	f	file:
jrnlFileSize	src/journal.c	/^static int jrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){$/;"	f	file:
jrnlRead	src/journal.c	/^static int jrnlRead($/;"	f	file:
jrnlSync	src/journal.c	/^static int jrnlSync(sqlite3_file *pJfd, int flags){$/;"	f	file:
jrnlTruncate	src/journal.c	/^static int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){$/;"	f	file:
jrnlWrite	src/journal.c	/^static int jrnlWrite($/;"	f	file:
juliandayFunc	src/date.c	/^static void juliandayFunc($/;"	f	file:
kPendingThreshold	ext/fts2/fts2.c	1855;"	d	file:
kPendingThreshold	ext/fts3/fts3.c	1993;"	d	file:
key	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	m	struct:AttachKey	file:
key	src/os_unix.c	/^  struct lockKey key;  \/* The lookup key *\/$/;"	m	struct:lockInfo	typeref:struct:lockInfo::lockKey	file:
key	src/os_unix.c	/^  struct openKey key;   \/* The lookup key *\/$/;"	m	struct:openCnt	typeref:struct:openCnt::openKey	file:
key	tool/lemon.c	/^  char *key;                   \/* The key *\/$/;"	m	struct:s_x2node	file:
key	tool/lemon.c	/^  struct config *key;                   \/* The key *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::config	file:
keyClass	ext/fts1/fts1_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:fts1Hash
keyClass	ext/fts2/fts2_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:fts2Hash
keyClass	ext/fts3/fts3_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:fts3Hash
keyClass	src/hash.h	/^  char keyClass;          \/* SQLITE_HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:Hash
keyConf	src/sqliteInt.h	/^  u8 keyConf;      \/* What to do in case of uniqueness conflict on iPKey *\/$/;"	m	struct:Table
keyInfoFromExprList	src/select.c	/^static KeyInfo *keyInfoFromExprList(Parse *pParse, ExprList *pList){$/;"	f	file:
keyToInt	src/vdbeInt.h	25;"	d
keywordCode	keywordhash.h	/^static int keywordCode(const char *z, int n){$/;"	f
keywordCompare1	tool/mkkeywordhash.c	/^static int keywordCompare1(const void *a, const void *b){$/;"	f	file:
keywordCompare2	tool/mkkeywordhash.c	/^static int keywordCompare2(const void *a, const void *b){$/;"	f	file:
keywordCompare3	tool/mkkeywordhash.c	/^static int keywordCompare3(const void *a, const void *b){$/;"	f	file:
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= .$/;"	l
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= COLUMNKW.$/;"	l
kwcolumn_opt	src/parse.y	/^kwcolumn_opt ::= .$/;"	l
kwcolumn_opt	src/parse.y	/^kwcolumn_opt ::= COLUMNKW.$/;"	l
label	tool/lemon.c	/^  char *label;$/;"	m	struct:s_options	file:
lambda	tool/lemon.c	/^  Boolean lambda;          \/* True if NT and can generate an empty string *\/$/;"	m	struct:symbol	file:
last	ext/fts2/fts2.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
last	ext/fts3/fts3.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
lastRowid	src/sqliteInt.h	/^  i64 lastRowid;                \/* ROWID of most recent insert (see above) *\/$/;"	m	struct:sqlite3
lastRowid	src/vdbeInt.h	/^  i64 lastRowid;        \/* Last rowid from a Next or NextIdx operation *\/$/;"	m	struct:Cursor
lastRowid	src/vdbeInt.h	/^  i64 lastRowid;    \/* Last insert rowid (sqlite3.lastRowid) *\/$/;"	m	struct:Context
last_insert_rowid	src/func.c	/^static void last_insert_rowid($/;"	f	file:
last_insert_rowid	src/sqlite3ext.h	/^  sqlite_int64  (*last_insert_rowid)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
lastrule	tool/lemon.c	/^  struct rule *lastrule;     \/* Pointer to the most recently parsed rule *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
leaf	src/btreeInt.h	/^  u8 leaf;             \/* True if leaf flag is set *\/$/;"	m	struct:MemPage
leafData	src/btreeInt.h	/^  u8 leafData;         \/* True if tables stores data on leaves only *\/$/;"	m	struct:MemPage
leafNodeValidate	ext/fts2/fts2.c	/^static void leafNodeValidate(const char *pData, int nData){$/;"	f	file:
leafNodeValidate	ext/fts3/fts3.c	/^static void leafNodeValidate(const char *pData, int nData){$/;"	f	file:
leafReader	ext/fts2/fts2.c	/^  LeafReader leafReader;    \/* reader for the current leaf. *\/$/;"	m	struct:LeavesReader	file:
leafReader	ext/fts3/fts3.c	/^  LeafReader leafReader;    \/* reader for the current leaf. *\/$/;"	m	struct:LeavesReader	file:
leafReaderAtEnd	ext/fts2/fts2.c	/^static int leafReaderAtEnd(LeafReader *pReader){$/;"	f	file:
leafReaderAtEnd	ext/fts3/fts3.c	/^static int leafReaderAtEnd(LeafReader *pReader){$/;"	f	file:
leafReaderData	ext/fts2/fts2.c	/^static const char *leafReaderData(LeafReader *pReader){$/;"	f	file:
leafReaderData	ext/fts3/fts3.c	/^static const char *leafReaderData(LeafReader *pReader){$/;"	f	file:
leafReaderDataBytes	ext/fts2/fts2.c	/^static int leafReaderDataBytes(LeafReader *pReader){$/;"	f	file:
leafReaderDataBytes	ext/fts3/fts3.c	/^static int leafReaderDataBytes(LeafReader *pReader){$/;"	f	file:
leafReaderDestroy	ext/fts2/fts2.c	/^static void leafReaderDestroy(LeafReader *pReader){$/;"	f	file:
leafReaderDestroy	ext/fts3/fts3.c	/^static void leafReaderDestroy(LeafReader *pReader){$/;"	f	file:
leafReaderInit	ext/fts2/fts2.c	/^static void leafReaderInit(const char *pData, int nData,$/;"	f	file:
leafReaderInit	ext/fts3/fts3.c	/^static void leafReaderInit(const char *pData, int nData,$/;"	f	file:
leafReaderStep	ext/fts2/fts2.c	/^static void leafReaderStep(LeafReader *pReader){$/;"	f	file:
leafReaderStep	ext/fts3/fts3.c	/^static void leafReaderStep(LeafReader *pReader){$/;"	f	file:
leafReaderTerm	ext/fts2/fts2.c	/^static const char *leafReaderTerm(LeafReader *pReader){$/;"	f	file:
leafReaderTerm	ext/fts3/fts3.c	/^static const char *leafReaderTerm(LeafReader *pReader){$/;"	f	file:
leafReaderTermBytes	ext/fts2/fts2.c	/^static int leafReaderTermBytes(LeafReader *pReader){$/;"	f	file:
leafReaderTermBytes	ext/fts3/fts3.c	/^static int leafReaderTermBytes(LeafReader *pReader){$/;"	f	file:
leafReaderTermCmp	ext/fts2/fts2.c	/^static int leafReaderTermCmp(LeafReader *pReader,$/;"	f	file:
leafReaderTermCmp	ext/fts3/fts3.c	/^static int leafReaderTermCmp(LeafReader *pReader,$/;"	f	file:
leafWriterDestroy	ext/fts2/fts2.c	/^static void leafWriterDestroy(LeafWriter *pWriter){$/;"	f	file:
leafWriterDestroy	ext/fts3/fts3.c	/^static void leafWriterDestroy(LeafWriter *pWriter){$/;"	f	file:
leafWriterEncodeTerm	ext/fts2/fts2.c	/^static int leafWriterEncodeTerm(LeafWriter *pWriter,$/;"	f	file:
leafWriterEncodeTerm	ext/fts3/fts3.c	/^static int leafWriterEncodeTerm(LeafWriter *pWriter,$/;"	f	file:
leafWriterFinalize	ext/fts2/fts2.c	/^static int leafWriterFinalize(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterFinalize	ext/fts3/fts3.c	/^static int leafWriterFinalize(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterFlush	ext/fts2/fts2.c	/^static int leafWriterFlush(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterFlush	ext/fts3/fts3.c	/^static int leafWriterFlush(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterInit	ext/fts2/fts2.c	/^static void leafWriterInit(int iLevel, int idx, LeafWriter *pWriter){$/;"	f	file:
leafWriterInit	ext/fts3/fts3.c	/^static void leafWriterInit(int iLevel, int idx, LeafWriter *pWriter){$/;"	f	file:
leafWriterInlineFlush	ext/fts2/fts2.c	/^static int leafWriterInlineFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterInlineFlush	ext/fts3/fts3.c	/^static int leafWriterInlineFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterInternalFlush	ext/fts2/fts2.c	/^static int leafWriterInternalFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterInternalFlush	ext/fts3/fts3.c	/^static int leafWriterInternalFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterRootInfo	ext/fts2/fts2.c	/^static int leafWriterRootInfo(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterRootInfo	ext/fts3/fts3.c	/^static int leafWriterRootInfo(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStep	ext/fts2/fts2.c	/^static int leafWriterStep(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStep	ext/fts3/fts3.c	/^static int leafWriterStep(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStepMerge	ext/fts2/fts2.c	/^static int leafWriterStepMerge(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStepMerge	ext/fts3/fts3.c	/^static int leafWriterStepMerge(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leaveMutex	src/os_unix.c	/^static void leaveMutex(){$/;"	f	file:
leavesReaderAtEnd	ext/fts2/fts2.c	/^static int leavesReaderAtEnd(LeavesReader *pReader){$/;"	f	file:
leavesReaderAtEnd	ext/fts3/fts3.c	/^static int leavesReaderAtEnd(LeavesReader *pReader){$/;"	f	file:
leavesReaderCmp	ext/fts2/fts2.c	/^static int leavesReaderCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReaderCmp	ext/fts3/fts3.c	/^static int leavesReaderCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReaderData	ext/fts2/fts2.c	/^static const char *leavesReaderData(LeavesReader *pReader){$/;"	f	file:
leavesReaderData	ext/fts3/fts3.c	/^static const char *leavesReaderData(LeavesReader *pReader){$/;"	f	file:
leavesReaderDataBytes	ext/fts2/fts2.c	/^static int leavesReaderDataBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderDataBytes	ext/fts3/fts3.c	/^static int leavesReaderDataBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderDestroy	ext/fts2/fts2.c	/^static void leavesReaderDestroy(LeavesReader *pReader){$/;"	f	file:
leavesReaderDestroy	ext/fts3/fts3.c	/^static void leavesReaderDestroy(LeavesReader *pReader){$/;"	f	file:
leavesReaderInit	ext/fts2/fts2.c	/^static int leavesReaderInit(fulltext_vtab *v,$/;"	f	file:
leavesReaderInit	ext/fts3/fts3.c	/^static int leavesReaderInit(fulltext_vtab *v,$/;"	f	file:
leavesReaderReorder	ext/fts2/fts2.c	/^static void leavesReaderReorder(LeavesReader *pLr, int nLr){$/;"	f	file:
leavesReaderReorder	ext/fts3/fts3.c	/^static void leavesReaderReorder(LeavesReader *pLr, int nLr){$/;"	f	file:
leavesReaderReset	ext/fts2/fts2.c	/^static int leavesReaderReset(LeavesReader *pReader){$/;"	f	file:
leavesReaderReset	ext/fts3/fts3.c	/^static int leavesReaderReset(LeavesReader *pReader){$/;"	f	file:
leavesReaderStep	ext/fts2/fts2.c	/^static int leavesReaderStep(fulltext_vtab *v, LeavesReader *pReader){$/;"	f	file:
leavesReaderStep	ext/fts3/fts3.c	/^static int leavesReaderStep(fulltext_vtab *v, LeavesReader *pReader){$/;"	f	file:
leavesReaderTerm	ext/fts2/fts2.c	/^static const char *leavesReaderTerm(LeavesReader *pReader){$/;"	f	file:
leavesReaderTerm	ext/fts3/fts3.c	/^static const char *leavesReaderTerm(LeavesReader *pReader){$/;"	f	file:
leavesReaderTermBytes	ext/fts2/fts2.c	/^static int leavesReaderTermBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderTermBytes	ext/fts3/fts3.c	/^static int leavesReaderTermBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderTermCmp	ext/fts2/fts2.c	/^static int leavesReaderTermCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReaderTermCmp	ext/fts3/fts3.c	/^static int leavesReaderTermCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReadersInit	ext/fts2/fts2.c	/^static int leavesReadersInit(fulltext_vtab *v, int iLevel,$/;"	f	file:
leavesReadersInit	ext/fts3/fts3.c	/^static int leavesReadersInit(fulltext_vtab *v, int iLevel,$/;"	f	file:
leavesReadersMerge	ext/fts2/fts2.c	/^static int leavesReadersMerge(fulltext_vtab *v,$/;"	f	file:
leavesReadersMerge	ext/fts3/fts3.c	/^static int leavesReadersMerge(fulltext_vtab *v,$/;"	f	file:
leftColumn	src/where.c	/^  i16 leftColumn;         \/* Column number of X in "X <op> <expr>" *\/$/;"	m	struct:WhereTerm	file:
leftCursor	src/where.c	/^  i16 leftCursor;         \/* Cursor number of X in "X <op> <expr>" *\/$/;"	m	struct:WhereTerm	file:
legacyCountFinalize	src/test1.c	/^static void legacyCountFinalize(sqlite3_context *context){$/;"	f	file:
legacyCountStep	src/test1.c	/^static void legacyCountStep($/;"	f	file:
lemon	tool/lemon.c	/^struct lemon {$/;"	s	file:
len	ext/fts1/fts1.c	/^  int len;      \/* length, not including null terminator *\/$/;"	m	struct:StringBuffer	file:
len	tool/mkkeywordhash.c	/^  int len;             \/* Length of this keyword, not counting final \\000 *\/$/;"	m	struct:Keyword	file:
length	src/os_unix.c	/^  unsigned long long length;        \/* nbr of bytes to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
lengthFunc	src/func.c	/^static void lengthFunc($/;"	f	file:
lhs	lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	struct:__anon4	file:
lhs	parse.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	struct:__anon27	file:
lhs	tool/lemon.c	/^  struct symbol *lhs;        \/* Left-hand side of current rule *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
lhs	tool/lemon.c	/^  struct symbol *lhs;      \/* Left-hand side of the rule *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
lhs	tool/lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	struct:__anon11	file:
lhsStart	tool/lemon.c	/^  int lhsStart;            \/* True if left-hand side is the start symbol *\/$/;"	m	struct:rule	file:
lhsalias	tool/lemon.c	/^  char *lhsalias;            \/* Alias for the LHS *\/$/;"	m	struct:pstate	file:
lhsalias	tool/lemon.c	/^  char *lhsalias;          \/* Alias for the LHS (NULL if none) *\/$/;"	m	struct:rule	file:
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libversion	src/sqlite3ext.h	/^  const char * (*libversion)(void);$/;"	m	struct:sqlite3_api_routines
libversion_number	src/sqlite3ext.h	/^  int  (*libversion_number)(void);$/;"	m	struct:sqlite3_api_routines
likeFunc	src/func.c	/^static void likeFunc($/;"	f	file:
likeInfoAlt	src/func.c	/^static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };$/;"	v	typeref:struct:compareInfo	file:
likeInfoNorm	src/func.c	/^static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };$/;"	v	typeref:struct:compareInfo	file:
likely	src/sqliteInt.h	26;"	d
likely	src/sqliteInt.h	29;"	d
line	tool/lemon.c	/^  int line;                \/* Line number at which code begins *\/$/;"	m	struct:rule	file:
list	src/mem3.c	/^    } list;$/;"	m	union:Mem3Block::__anon19	typeref:struct:Mem3Block::__anon19::__anon21	file:
listAdd	src/pager.c	/^static void listAdd(PagerLruList *pList, PagerLruLink *pLink, PgHdr *pPg){$/;"	f	file:
listRemove	src/pager.c	/^static void listRemove(PagerLruList *pList, PagerLruLink *pLink, PgHdr *pPg){$/;"	f	file:
loadAnalysis	src/analyze.c	/^static void loadAnalysis(Parse *pParse, int iDb){$/;"	f	file:
loadAndGetChildrenContaining	ext/fts2/fts2.c	/^static int loadAndGetChildrenContaining($/;"	f	file:
loadAndGetChildrenContaining	ext/fts3/fts3.c	/^static int loadAndGetChildrenContaining($/;"	f	file:
loadExt	src/func.c	/^static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
loadSegment	ext/fts2/fts2.c	/^static int loadSegment(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegment	ext/fts3/fts3.c	/^static int loadSegment(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentInt	ext/fts2/fts2.c	/^static int loadSegmentInt(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentInt	ext/fts3/fts3.c	/^static int loadSegmentInt(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentLeaf	ext/fts2/fts2.c	/^static int loadSegmentLeaf(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentLeaf	ext/fts3/fts3.c	/^static int loadSegmentLeaf(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentLeaves	ext/fts2/fts2.c	/^static int loadSegmentLeaves(fulltext_vtab *v,$/;"	f	file:
loadSegmentLeaves	ext/fts3/fts3.c	/^static int loadSegmentLeaves(fulltext_vtab *v,$/;"	f	file:
loadSegmentLeavesInt	ext/fts2/fts2.c	/^static int loadSegmentLeavesInt(fulltext_vtab *v, LeavesReader *pReader,$/;"	f	file:
loadSegmentLeavesInt	ext/fts3/fts3.c	/^static int loadSegmentLeavesInt(fulltext_vtab *v, LeavesReader *pReader,$/;"	f	file:
local	src/os_win.c	/^  winceLock local;        \/* Locks obtained by this instance of winFile *\/$/;"	m	struct:winFile	file:
local_getline	src/shell.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_getline	src/tclsqlite.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_ioerr	src/os_common.h	/^static void local_ioerr(){$/;"	f
localtime	src/os_win.c	/^struct tm *__cdecl localtime(const time_t *t)$/;"	f
localtimeOffset	src/date.c	/^static double localtimeOffset(DateTime *p){$/;"	f	file:
lock	src/os_unix.c	/^  struct flock lock;     \/* The locking operation *\/$/;"	m	struct:threadTestData	typeref:struct:threadTestData::flock	file:
lock	src/test_async.c	/^  AsyncFileLock lock;$/;"	m	struct:AsyncFileData	file:
lock	test/threadtest1.c	/^pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
lockBtree	src/btree.c	/^static int lockBtree(BtShared *pBt){$/;"	f	file:
lockBtreeWithRetry	src/btree.c	/^static int lockBtreeWithRetry(Btree *pRef){$/;"	f	file:
lockHash	src/os_unix.c	/^static Hash lockHash = {SQLITE_HASH_BINARY, 0, 0, 0, 0, 0};$/;"	v	file:
lockInfo	src/os_unix.c	/^struct lockInfo {$/;"	s	file:
lockKey	src/os_unix.c	/^struct lockKey {$/;"	s	file:
lockMutex	src/test_async.c	/^  pthread_mutex_t lockMutex;   \/* For access to aLock hash table *\/$/;"	m	struct:TestAsyncStaticData	file:
lockMutexHolder	src/test_async.c	/^  pthread_t lockMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
lockPath	src/os_unix.c	/^  char *lockPath;$/;"	m	struct:dotlockLockingContext	file:
lockTable	src/btree.c	/^static int lockTable(Btree *p, Pgno iTable, u8 eLock){$/;"	f	file:
lockTable	src/btree.c	84;"	d	file:
lockTrace	src/os_unix.c	/^static int lockTrace(int fd, int op, struct flock *p){$/;"	f	file:
locked	src/btreeInt.h	/^  u8 locked;         \/* True if db currently has pBt locked *\/$/;"	m	struct:Btree
lockingContext	src/os_unix.c	/^  void *lockingContext;     \/* Locking style specific state *\/$/;"	m	struct:unixFile	file:
locktype	src/os_os2.c	/^  unsigned char locktype;   \/* Type of lock currently held on this file *\/$/;"	m	struct:os2File	file:
locktype	src/os_unix.c	/^  int locktype;        \/* One of SHARED_LOCK, RESERVED_LOCK etc. *\/$/;"	m	struct:lockInfo	file:
locktype	src/os_unix.c	/^  unsigned char locktype;   \/* The type of lock held on this fd *\/$/;"	m	struct:unixFile	file:
locktype	src/os_win.c	/^  unsigned char locktype; \/* Type of lock currently held on this file *\/$/;"	m	struct:winFile	file:
locktypeName	src/os_unix.c	/^static const char *locktypeName(int locktype){$/;"	f	file:
longestSuffix	tool/mkkeywordhash.c	/^  int longestSuffix;   \/* Longest suffix that is a prefix on another word *\/$/;"	m	struct:Keyword	file:
lookahead	tool/lemon.c	/^    int lookahead;             \/* Value of the lookahead token *\/$/;"	m	struct:acttab::__anon10	file:
lookupName	src/expr.c	/^static int lookupName($/;"	f	file:
lowerFunc	src/func.c	/^static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
lp	parse.y	/^lp ::= LP(X).                       {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
lp	src/parse.y	/^lp ::= LP(X).                       {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
lru	src/pager.c	/^  PagerLruList lru;           \/* LRU list of free pages *\/$/;"	m	struct:Pager	file:
lru	src/vdbeInt.h	/^  int lru;              \/* Counter used for LRU cache replacement *\/$/;"	m	struct:Vdbe
lruListAdd	src/pager.c	/^static void lruListAdd(PgHdr *pPg){$/;"	f	file:
lruListRemove	src/pager.c	/^static void lruListRemove(PgHdr *pPg){$/;"	f	file:
lruListSetFirstSynced	src/pager.c	/^static void lruListSetFirstSynced(Pager *pPager){$/;"	f	file:
m	src/date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
m_eq_1	ext/fts1/fts1_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_eq_1	ext/fts2/fts2_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_eq_1	ext/fts3/fts3_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_gt_0	ext/fts1/fts1_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_0	ext/fts2/fts2_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_0	ext/fts3/fts3_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_1	ext/fts1/fts1_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
m_gt_1	ext/fts2/fts2_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
m_gt_1	ext/fts3/fts3_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
magic	src/sqliteInt.h	/^  int magic;                    \/* Magic number for detect library misuse *\/$/;"	m	struct:sqlite3
magic	src/vdbeInt.h	/^  int magic;              \/* Magic number for sanity checking *\/$/;"	m	struct:Vdbe
main	src/shell.c	/^int main(int argc, char **argv){$/;"	f
main	test/threadtest1.c	/^int main(int argc, char **argv){$/;"	f
main	test/threadtest2.c	/^int main(int argc, char **argv){$/;"	f
main	tool/diffdb.c	/^int main(int argc, char **argv){$/;"	f
main	tool/lemon.c	/^int main(argc,argv)$/;"	f
main	tool/mkkeywordhash.c	/^int main(int argc, char **argv){$/;"	f
main	tool/omittest.tcl	/^proc main {argv} {$/;"	p
main	tool/showdb.c	/^int main(int argc, char **argv){$/;"	f
main	tool/showjournal.c	/^int main(int argc, char **argv){$/;"	f
mainPrompt	src/shell.c	/^static char mainPrompt[20];     \/* First line prompt. default: "sqlite> "*\/$/;"	v	file:
main_init	src/shell.c	/^static void main_init(struct callback_data *data) {$/;"	f	file:
major	lempar.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
major	parse.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
major	tool/lempar.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
makeClean	src/pager.c	/^static void makeClean(PgHdr *pPg){$/;"	f	file:
makeDirty	src/pager.c	/^static void makeDirty(PgHdr *pPg){$/;"	f	file:
malloc	src/sqlite3ext.h	/^  void *(*malloc)(int);$/;"	m	struct:sqlite3_api_routines
mallocFailed	src/sqliteInt.h	/^  u8   mallocFailed;   \/* Becomes true if any memory allocation fails *\/$/;"	m	struct:StrAccum
mallocFailed	src/sqliteInt.h	/^  u8 mallocFailed;              \/* True if we have seen a malloc failure *\/$/;"	m	struct:sqlite3
malloc_and_zero	ext/fts1/fts1_hash.c	/^static void *malloc_and_zero(int n){$/;"	f	file:
malloc_and_zero	ext/fts2/fts2_hash.c	/^static void *malloc_and_zero(int n){$/;"	f	file:
mask	parse.c	/^  struct {int value; int mask;} yy405;$/;"	m	struct:__anon25::__anon26	file:
mask	tool/mkkeywordhash.c	/^  int mask;            \/* Code this keyword if non-zero *\/$/;"	m	struct:Keyword	file:
matchAll	src/func.c	/^  u8 matchAll;$/;"	m	struct:compareInfo	file:
matchOne	src/func.c	/^  u8 matchOne;$/;"	m	struct:compareInfo	file:
matchOrderByTermToExprList	src/select.c	/^static int matchOrderByTermToExprList($/;"	f	file:
matchSet	src/func.c	/^  u8 matchSet;$/;"	m	struct:compareInfo	file:
maxEmbedFrac	src/btreeInt.h	/^  u8 maxEmbedFrac;      \/* Maximum payload as % of total page size *\/$/;"	m	struct:BtShared
maxLeaf	src/btreeInt.h	/^  int maxLeaf;          \/* Maximum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
maxLocal	src/btreeInt.h	/^  int maxLocal;         \/* Maximum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
maxLocal	src/btreeInt.h	/^  u16 maxLocal;        \/* Copy of BtShared.maxLocal or BtShared.maxLeaf *\/$/;"	m	struct:MemPage
maxStmt	src/tclsqlite.c	/^  int maxStmt;               \/* The next maximum number of stmtList *\/$/;"	m	struct:SqliteDb	file:
mbcsToUnicode	src/os_win.c	/^static WCHAR *mbcsToUnicode(const char *zFilename){$/;"	f	file:
mbcsToUtf8	src/os_win.c	/^static char *mbcsToUtf8(const char *zFilename){$/;"	f	file:
md5_cmd	src/test_md5.c	/^static int md5_cmd(void*cd, Tcl_Interp *interp, int argc, const char **argv){$/;"	f	file:
md5file_cmd	src/test_md5.c	/^static int md5file_cmd(void*cd, Tcl_Interp*interp, int argc, const char **argv){$/;"	f	file:
md5finalize	src/test_md5.c	/^static void md5finalize(sqlite3_context *context){$/;"	f	file:
md5step	src/test_md5.c	/^static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
mem	src/mem1.c	/^} mem;$/;"	v	typeref:struct:__anon12	file:
mem	src/mem2.c	/^} mem;$/;"	v	typeref:struct:__anon16	file:
mem	src/mem3.c	/^} mem;$/;"	v	typeref:struct:__anon22	file:
mem	src/mem4.c	/^} mem;$/;"	v	typeref:struct:__anon18	file:
memDb	src/pager.c	/^  u8 memDb;                   \/* True to inhibit all file I\/O *\/$/;"	m	struct:Pager	file:
memTracePrint	src/vdbe.c	/^static void memTracePrint(FILE *out, Mem *p){$/;"	f	file:
memory_error	tool/lemon.c	/^void memory_error(){$/;"	f
memory_highwater	src/sqlite3ext.h	/^  sqlite3_int64 (*memory_highwater)(int);$/;"	m	struct:sqlite3_api_routines
memory_used	src/sqlite3ext.h	/^  sqlite3_int64 (*memory_used)(void);$/;"	m	struct:sqlite3_api_routines
memsys3Checkout	src/mem3.c	/^static void *memsys3Checkout(u32 i, int nBlock){$/;"	f	file:
memsys3Enter	src/mem3.c	/^static void memsys3Enter(void){$/;"	f	file:
memsys3Free	src/mem3.c	/^void memsys3Free(void *pOld){$/;"	f
memsys3FromMaster	src/mem3.c	/^static void *memsys3FromMaster(int nBlock){$/;"	f	file:
memsys3Link	src/mem3.c	/^static void memsys3Link(u32 i){$/;"	f	file:
memsys3LinkIntoList	src/mem3.c	/^static void memsys3LinkIntoList(u32 i, u32 *pRoot){$/;"	f	file:
memsys3Malloc	src/mem3.c	/^static void *memsys3Malloc(int nByte){$/;"	f	file:
memsys3Merge	src/mem3.c	/^static void memsys3Merge(u32 *pRoot){$/;"	f	file:
memsys3OutOfMemory	src/mem3.c	/^static void memsys3OutOfMemory(int nByte){$/;"	f	file:
memsys3Size	src/mem3.c	/^static int memsys3Size(void *p){$/;"	f	file:
memsys3Unlink	src/mem3.c	/^static void memsys3Unlink(u32 i){$/;"	f	file:
memsys3UnlinkFromList	src/mem3.c	/^static void memsys3UnlinkFromList(u32 i, u32 *pRoot){$/;"	f	file:
memsys4Enter	src/mem4.c	/^static void memsys4Enter(void){$/;"	f	file:
memsys4Free	src/mem4.c	/^static void memsys4Free(void *pPrior){$/;"	f	file:
memsys4Malloc	src/mem4.c	/^static void *memsys4Malloc(int nBytes){$/;"	f	file:
memsys4Size	src/mem4.c	/^static int memsys4Size(void *pPrior){$/;"	f	file:
merge	tool/lemon.c	/^static char *merge($/;"	f	file:
mergePosList	ext/fts1/fts1.c	/^static void mergePosList($/;"	f	file:
merge_pagelist	src/pager.c	/^static PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB){$/;"	f	file:
message	tool/lemon.c	/^  char *message;$/;"	m	struct:s_options	file:
minEmbedFrac	src/btreeInt.h	/^  u8 minEmbedFrac;      \/* Minimum payload as % of total page size *\/$/;"	m	struct:BtShared
minLeaf	src/btreeInt.h	/^  int minLeaf;          \/* Minimum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
minLeafFrac	src/btreeInt.h	/^  u8 minLeafFrac;       \/* Minimum leaf payload as % of total page size *\/$/;"	m	struct:BtShared
minLocal	src/btreeInt.h	/^  int minLocal;         \/* Minimum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
minLocal	src/btreeInt.h	/^  u16 minLocal;        \/* Copy of BtShared.minLocal or BtShared.minLeaf *\/$/;"	m	struct:MemPage
minMaxFinalize	src/func.c	/^static void minMaxFinalize(sqlite3_context *context){$/;"	f	file:
minMaxQuery	src/select.c	/^static int minMaxQuery(Parse *pParse, Select *p){$/;"	f	file:
minWriteFileFormat	src/vdbeInt.h	/^  u8 minWriteFileFormat;  \/* Minimum file format for writable database files *\/$/;"	m	struct:Vdbe
minimum_size_type	tool/lemon.c	/^static const char *minimum_size_type(int lwr, int upr){$/;"	f	file:
minmaxFunc	src/func.c	/^static void minmaxFunc($/;"	f	file:
minmaxStep	src/func.c	/^static void minmaxStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
minor	lempar.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
minor	parse.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
minor	tool/lempar.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
mmapAlloc	src/mem4.c	/^static void *mmapAlloc(int nBytes){$/;"	f	file:
mmapFree	src/mem4.c	/^static int mmapFree(void *p){$/;"	f	file:
mmapHeap	src/mem4.c	/^  char *mmapHeap;   \/* first byte of the heap *\/ $/;"	m	struct:__anon18	file:
mmapUnmap	src/mem4.c	/^static void mmapUnmap(void){$/;"	f	file:
mnAction	tool/lemon.c	/^  int mnAction;                \/* Action associated with mnLookahead *\/$/;"	m	struct:acttab	file:
mnLookahead	tool/lemon.c	/^  int mnLookahead;             \/* Minimum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mnMaster	src/mem3.c	/^  u32 mnMaster;$/;"	m	struct:__anon22	file:
mnPage	src/mem4.c	/^  int mnPage;$/;"	m	struct:__anon18	file:
mode	src/shell.c	/^  int mode;              \/* An output mode setting *\/$/;"	m	struct:callback_data	file:
mode	src/shell.c	/^  int mode;$/;"	m	struct:previous_mode_data	file:
modeDescr	src/shell.c	/^static const char *modeDescr[MODE_NUM_OF] = {$/;"	v	file:
modifyPagePointer	src/btree.c	/^static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){$/;"	f	file:
moduleDestroy	src/test8.c	/^static void moduleDestroy(void *p){$/;"	f	file:
moveToChild	src/btree.c	/^static int moveToChild(BtCursor *pCur, u32 newPgno){$/;"	f	file:
moveToLeftmost	src/btree.c	/^static int moveToLeftmost(BtCursor *pCur){$/;"	f	file:
moveToRightmost	src/btree.c	/^static int moveToRightmost(BtCursor *pCur){$/;"	f	file:
moveToRoot	src/btree.c	/^static int moveToRoot(BtCursor *pCur){$/;"	f	file:
movetoTarget	src/vdbeInt.h	/^  i64 movetoTarget;     \/* Argument to the deferred sqlite3BtreeMoveto() *\/$/;"	m	struct:Cursor
mprintf	src/sqlite3ext.h	/^  char * (*mprintf)(const char*,...);$/;"	m	struct:sqlite3_api_routines
msort	tool/lemon.c	/^static char *msort($/;"	f	file:
multiSelect	src/select.c	/^static int multiSelect($/;"	f	file:
multiSelectCollSeq	src/select.c	/^static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){$/;"	f	file:
mutex	src/btreeInt.h	/^  sqlite3_mutex *mutex; \/* Non-recursive mutex required to access this struct *\/$/;"	m	struct:BtShared
mutex	src/mem1.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon12	file:
mutex	src/mem2.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon16	file:
mutex	src/mem3.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon22	file:
mutex	src/mem4.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon18	file:
mutex	src/mutex_os2.c	/^  HMTX mutex;       \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	src/mutex_unix.c	/^  pthread_mutex_t mutex;     \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	src/mutex_w32.c	/^  CRITICAL_SECTION mutex;    \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	src/sqliteInt.h	/^  sqlite3_mutex *mutex;         \/* Connection mutex *\/$/;"	m	struct:sqlite3
mutexIsNT	src/mutex_w32.c	/^  static int mutexIsNT(void){$/;"	f	file:
mutexIsNT	src/mutex_w32.c	46;"	d	file:
mutexName	src/mutex_os2.c	/^  PSZ  mutexName;   \/* Mutex name controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex_alloc	src/sqlite3ext.h	/^  sqlite3_mutex *(*mutex_alloc)(int);$/;"	m	struct:sqlite3_api_routines
mutex_enter	src/sqlite3ext.h	/^  void (*mutex_enter)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_free	src/sqlite3ext.h	/^  void (*mutex_free)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_leave	src/sqlite3ext.h	/^  void (*mutex_leave)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_try	src/sqlite3ext.h	/^  int (*mutex_try)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mxErr	src/btreeInt.h	/^  int mxErr;        \/* Stop accumulating errors when this reaches zero *\/$/;"	m	struct:IntegrityCk
mxLookahead	tool/lemon.c	/^  int mxLookahead;             \/* Maximum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mxPage	src/pager.c	/^  int mxPage;                 \/* Maximum number of pages to hold in cache *\/$/;"	m	struct:Pager	file:
mxPage	tool/showdb.c	/^static int mxPage = 0;$/;"	v	file:
mxPage	tool/showjournal.c	/^static int mxPage = 0;$/;"	v	file:
mxPathname	sqlite3.h	/^  int mxPathname;          \/* Maximum file pathname length *\/$/;"	m	struct:sqlite3_vfs
mxPgno	src/pager.c	/^  Pgno mxPgno;                \/* Maximum allowed size of the database *\/$/;"	m	struct:Pager	file:
mxUsed	src/mem1.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon12	file:
mxUsed	src/mem2.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon16	file:
mxUsed	src/mem4.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon18	file:
mxUsedMMap	src/mem4.c	/^  sqlite3_int64 mxUsedMMap;$/;"	m	struct:__anon18	file:
n	ext/fts1/fts1.c	/^  short int n;         \/* Length of the token text in bytes. *\/$/;"	m	struct:Token	file:
n	ext/fts2/fts2.c	/^  short int n;         \/* Length of the token text in bytes. *\/$/;"	m	struct:Token	file:
n	ext/fts3/fts3.c	/^  short int n;         \/* Length of the token text in bytes. *\/$/;"	m	struct:FtsToken	file:
n	src/func.c	/^  i64 n;$/;"	m	struct:CountCtx	file:
n	src/sqliteInt.h	/^  unsigned n    : 31;     \/* Number of characters in this token *\/$/;"	m	struct:Token
n	src/test1.c	/^  int n;$/;"	m	struct:t1CountCtx	file:
n	src/vdbeInt.h	/^  int n;              \/* Number of characters in string value, excluding '\\0' *\/$/;"	m	struct:Mem
n	src/where.c	/^  int n;                        \/* Number of assigned cursor values *\/$/;"	m	struct:ExprMaskSet	file:
nAccumulator	src/sqliteInt.h	/^  int nAccumulator;       \/* Number of columns that show through to the output.$/;"	m	struct:AggInfo
nAction	tool/lemon.c	/^  int nAction;                 \/* Number of used slots in aAction[] *\/$/;"	m	struct:acttab	file:
nAction	tool/lemon.c	/^  int nAction;         \/* Number of actions *\/$/;"	m	struct:axset	file:
nActionAlloc	tool/lemon.c	/^  int nActionAlloc;            \/* Slots allocated for aAction[] *\/$/;"	m	struct:acttab	file:
nAlloc	ext/fts1/fts1.c	/^  int nAlloc;     \/* Space allocated for aMatch[] *\/$/;"	m	struct:Snippet	file:
nAlloc	ext/fts2/fts2.c	/^  int nAlloc;     \/* Space allocated for aMatch[] *\/$/;"	m	struct:Snippet	file:
nAlloc	ext/fts3/fts3.c	/^  int nAlloc;     \/* Space allocated for aMatch[] *\/$/;"	m	struct:Snippet	file:
nAlloc	src/sqliteInt.h	/^  i16 nAlloc;      \/* Number of entries allocated in a[] below *\/$/;"	m	struct:SrcList
nAlloc	src/sqliteInt.h	/^  int  nAlloc;     \/* Amount of space allocated in zText *\/$/;"	m	struct:StrAccum
nAlloc	src/sqliteInt.h	/^  int nAlloc;            \/* Number of entries allocated below *\/$/;"	m	struct:ExprList
nAlloc	src/sqliteInt.h	/^  int nAlloc;      \/* Number of entries allocated for a[] below *\/$/;"	m	struct:IdList
nAlloc	src/table.c	/^  int nAlloc;$/;"	m	struct:TabResult	file:
nAlloc	src/test1.c	/^  int nAlloc;  \/* Space allocated *\/$/;"	m	struct:dstr	file:
nAlloc	src/test_onefile.c	/^  int nAlloc;$/;"	m	struct:tmp_file	file:
nAlloc	test/threadtest1.c	/^  int nAlloc;         \/* Number of slots allocated for azElem[] *\/$/;"	m	struct:QueryResult	file:
nAllocated	ext/fts1/fts1_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nAllocated	ext/fts2/fts2_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nAllocated	ext/fts3/fts3_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nArg	src/sqliteInt.h	/^  i16 nArg;            \/* Number of arguments.  -1 means unlimited *\/$/;"	m	struct:FuncDef
nAux	src/vdbeInt.h	/^  int nAux;                     \/* Number of entries allocated for apAux[] *\/$/;"	m	struct:VdbeFunc
nBacktrace	src/mem2.c	/^  char nBacktrace;                    \/* Number of backtraces on this alloc *\/$/;"	m	struct:MemBlockHdr	file:
nBacktrace	src/mem2.c	/^  int nBacktrace;$/;"	m	struct:__anon16	file:
nBacktraceSlots	src/mem2.c	/^  char nBacktraceSlots;               \/* Available backtrace slots *\/$/;"	m	struct:MemBlockHdr	file:
nBenign	src/fault.c	/^  int nBenign;      \/* Number of benign failures seen since last config *\/$/;"	m	struct:FaultInjector	file:
nBlob	src/test_onefile.c	/^  int nBlob;                  \/* Total size of allocated blob *\/$/;"	m	struct:fs_real_file	file:
nBuf	src/journal.c	/^  int nBuf;                       \/* Size of zBuf[] in bytes *\/$/;"	m	struct:JournalFile	file:
nBuf	src/test6.c	/^  int nBuf;                    \/* Number of bytes written *\/$/;"	m	struct:WriteBuffer	file:
nBuffer	ext/fts2/fts2_icu.c	/^  int nBuffer;$/;"	m	struct:IcuCursor	file:
nBuffer	ext/fts3/fts3_icu.c	/^  int nBuffer;$/;"	m	struct:IcuCursor	file:
nBusy	src/sqliteInt.h	/^  int nBusy;                 \/* Incremented with each busy call *\/$/;"	m	struct:BusyHandler
nByte	ext/fts1/fts1.c	/^    short int nByte;     \/* Number of bytes in the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
nByte	ext/fts2/fts2.c	/^    short int nByte;     \/* Number of bytes in the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
nByte	ext/fts3/fts3.c	/^    short int nByte;     \/* Number of bytes in the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
nByte	src/test_async.c	/^  int nByte;          \/* See above *\/$/;"	m	struct:AsyncWrite	file:
nByte	src/test_server.c	/^  int nByte;                   \/* Size of the zIn parameter for prepare() *\/$/;"	m	struct:SqlMessage	file:
nByte	src/vdbeblob.c	/^  int nByte;              \/* Size of open blob, in bytes *\/$/;"	m	struct:Incrblob	file:
nBytes	ext/fts1/fts1_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytes	ext/fts2/fts2_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytes	ext/fts3/fts3_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nCallback	src/vdbeInt.h	/^  int nCallback;          \/* Number of callbacks invoked so far *\/$/;"	m	struct:Vdbe
nCapacity	ext/fts2/fts2.c	/^  int nCapacity;        \/* Size of pData buffer. *\/$/;"	m	struct:DataBuffer	file:
nCapacity	ext/fts3/fts3.c	/^  int nCapacity;        \/* Size of pData buffer. *\/$/;"	m	struct:DataBuffer	file:
nCell	src/btreeInt.h	/^  u16 nCell;           \/* Number of cells on this page, local and ovfl *\/$/;"	m	struct:MemPage
nChange	src/sqliteInt.h	/^  int nChange;                  \/* Value returned by sqlite3_changes() *\/$/;"	m	struct:sqlite3
nChange	src/vdbeInt.h	/^  int nChange;            \/* Number of db changes made since last reset *\/$/;"	m	struct:Vdbe
nChange	src/vdbeInt.h	/^  int nChange;      \/* Statement changes (Vdbe.nChanges)     *\/$/;"	m	struct:Context
nChar	ext/fts2/fts2_icu.c	/^  int nChar;                  \/* Number of UChar elements in pInput *\/$/;"	m	struct:IcuCursor	file:
nChar	ext/fts3/fts3_icu.c	/^  int nChar;                  \/* Number of UChar elements in pInput *\/$/;"	m	struct:IcuCursor	file:
nChar	src/sqliteInt.h	/^  int  nChar;      \/* Length of the string so far *\/$/;"	m	struct:StrAccum
nChild	src/where.c	/^  u8 nChild;              \/* Number of children that must disable us *\/$/;"	m	struct:WhereTerm	file:
nCol	src/sqliteInt.h	/^  int nCol;         \/* Number of columns in this key *\/$/;"	m	struct:FKey
nCol	src/sqliteInt.h	/^  int nCol;        \/* Number of columns in this table *\/$/;"	m	struct:Table
nCol	src/test8.c	/^  int nCol;               \/* Number of columns in the real table *\/$/;"	m	struct:echo_vtab	file:
nColumn	ext/fts1/fts1.c	/^  int nColumn;                     \/* number of columns in virtual table *\/$/;"	m	struct:fulltext_vtab	file:
nColumn	ext/fts1/fts1.c	/^  int nColumn;             \/* Number of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
nColumn	ext/fts2/fts2.c	/^  int nColumn;                     \/* number of columns in virtual table *\/$/;"	m	struct:fulltext_vtab	file:
nColumn	ext/fts2/fts2.c	/^  int nColumn;             \/* Number of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
nColumn	ext/fts3/fts3.c	/^  int nColumn;                     \/* number of columns in virtual table *\/$/;"	m	struct:fulltext_vtab	file:
nColumn	ext/fts3/fts3.c	/^  int nColumn;             \/* Number of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
nColumn	src/sqliteInt.h	/^  int nColumn;            \/* Number of used entries in aCol[] *\/$/;"	m	struct:AggInfo
nColumn	src/sqliteInt.h	/^  int nColumn;     \/* Number of columns in the table used by this index *\/$/;"	m	struct:Index
nColumn	src/table.c	/^  int nColumn;$/;"	m	struct:TabResult	file:
nColumnAlloc	src/sqliteInt.h	/^  int nColumnAlloc;       \/* Number of slots allocated for aCol[] *\/$/;"	m	struct:AggInfo
nConstraint	sqlite3.h	/^  int nConstraint;           \/* Number of entries in aConstraint *\/$/;"	m	struct:sqlite3_index_info
nCursor	src/vdbeInt.h	/^  int nCursor;        \/* Number of slots in apCsr[] *\/$/;"	m	struct:Vdbe
nData	ext/fts1/fts1.c	/^  int nData;$/;"	m	struct:DocList	file:
nData	ext/fts2/fts2.c	/^  int nData;            \/* End of data loaded into pData. *\/$/;"	m	struct:DataBuffer	file:
nData	ext/fts2/fts2.c	/^  int nData;$/;"	m	struct:DLReader	file:
nData	ext/fts2/fts2.c	/^  int nData;$/;"	m	struct:InteriorReader	file:
nData	ext/fts2/fts2.c	/^  int nData;$/;"	m	struct:LeafReader	file:
nData	ext/fts2/fts2.c	/^  int nData;$/;"	m	struct:PLReader	file:
nData	ext/fts3/fts3.c	/^  int nData;            \/* End of data loaded into pData. *\/$/;"	m	struct:DataBuffer	file:
nData	ext/fts3/fts3.c	/^  int nData;$/;"	m	struct:DLReader	file:
nData	ext/fts3/fts3.c	/^  int nData;$/;"	m	struct:InteriorReader	file:
nData	ext/fts3/fts3.c	/^  int nData;$/;"	m	struct:LeafReader	file:
nData	ext/fts3/fts3.c	/^  int nData;$/;"	m	struct:PLReader	file:
nData	src/btreeInt.h	/^  u32 nData;     \/* Number of bytes of data *\/$/;"	m	struct:CellInfo
nData	src/table.c	/^  int nData;$/;"	m	struct:TabResult	file:
nData	src/test6.c	/^  int nData;                           \/* Size of buffer allocated at zData *\/$/;"	m	struct:CrashFile	file:
nData	src/vdbeInt.h	/^  int nData;            \/* Number of bytes in pData *\/$/;"	m	struct:Cursor
nDatabase	src/test_onefile.c	/^  int nDatabase;              \/* Current size of database region *\/$/;"	m	struct:fs_real_file	file:
nDb	src/sqliteInt.h	/^  int nDb;                      \/* Number of backends currently in use *\/$/;"	m	struct:sqlite3
nDefine	tool/lemon.c	/^static int nDefine = 0;      \/* Number of -D options on the command line *\/$/;"	v	file:
nDepth	src/sqliteInt.h	/^  int nDepth;          \/* Depth of subquery recursion. 1 for no recursion *\/$/;"	m	struct:NameContext
nElem	test/threadtest1.c	/^  int nElem;          \/* Number of used entries in azElem[] *\/$/;"	m	struct:QueryResult	file:
nElement	ext/fts2/fts2.c	/^  int nElement;$/;"	m	struct:DLReader	file:
nElement	ext/fts3/fts3.c	/^  int nElement;$/;"	m	struct:DLReader	file:
nEntry	src/vdbeInt.h	/^  int nEntry;         \/* Total number of entries *\/$/;"	m	struct:Fifo
nEq	src/sqliteInt.h	/^  int nEq;              \/* Number of == or IN constraints on this loop *\/$/;"	m	struct:WhereLevel
nErr	src/btreeInt.h	/^  int nErr;         \/* Number of messages written to zErrMsg so far *\/$/;"	m	struct:IntegrityCk
nErr	src/sqliteInt.h	/^  int nErr;            \/* Number of errors encountered while resolving names *\/$/;"	m	struct:NameContext
nErr	src/sqliteInt.h	/^  int nErr;            \/* Number of errors seen *\/$/;"	m	struct:Parse
nExpr	src/sqliteInt.h	/^  int nExpr;             \/* Number of expressions on the list *\/$/;"	m	struct:ExprList
nExt	src/loadext.c	/^  int nExt;        \/* Number of entries in aExt[] *\/          $/;"	m	struct:__anon24	file:
nExtension	src/sqliteInt.h	/^  int nExtension;               \/* Number of loaded extensions *\/$/;"	m	struct:sqlite3
nExtra	src/pager.c	/^  int nExtra;                 \/* Add this many bytes to each in-memory page *\/$/;"	m	struct:Pager	file:
nFail	src/fault.c	/^  int nFail;        \/* Number of failures seen since last config *\/$/;"	m	struct:FaultInjector	file:
nField	src/sqliteInt.h	/^  int nField;         \/* Number of entries in aColl[] *\/$/;"	m	struct:KeyInfo
nField	src/vdbeInt.h	/^  int nField;           \/* Number of fields in the header *\/$/;"	m	struct:Cursor
nFile	src/test_async.c	/^  int nFile;                   \/* Number of open files (from sqlite pov) *\/$/;"	m	struct:TestAsyncStaticData	file:
nFree	src/btreeInt.h	/^  u16 nFree;           \/* Number of free bytes on the page *\/$/;"	m	struct:MemPage
nFunc	src/sqliteInt.h	/^  int nFunc;              \/* Number of entries in aFunc[] *\/$/;"	m	struct:AggInfo
nFuncAlloc	src/sqliteInt.h	/^  int nFuncAlloc;         \/* Number of slots allocated for aFunc[] *\/$/;"	m	struct:AggInfo
nHash	src/pager.c	/^  int nHash;                  \/* Size of the pager hash table *\/$/;"	m	struct:Pager	file:
nHeader	src/btreeInt.h	/^  u16 nHeader;   \/* Size of the cell content header in bytes *\/$/;"	m	struct:CellInfo
nHeight	src/sqliteInt.h	/^  int nHeight;            \/* Expression tree height of current sub-select *\/$/;"	m	struct:Parse
nHeight	src/sqliteInt.h	/^  int nHeight;           \/* Height of the tree headed by this node *\/$/;"	m	struct:Expr
nHit	src/pager.c	/^  int nHit, nMiss;            \/* Cache hits and missing *\/$/;"	m	struct:Pager	file:
nId	src/sqliteInt.h	/^  int nId;         \/* Number of identifiers on the list *\/$/;"	m	struct:IdList
nIn	src/sqliteInt.h	/^  int nIn;              \/* Number of IN operators constraining this loop *\/$/;"	m	struct:WhereLevel
nInput	ext/fts1/fts1_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nInput	ext/fts2/fts2_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nInput	ext/fts3/fts3_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nJournal	src/test_onefile.c	/^  int nJournal;               \/* Current size of journal region *\/$/;"	m	struct:fs_real_file	file:
nKey	ext/fts1/fts1_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts1HashElem
nKey	ext/fts2/fts2_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts2HashElem
nKey	ext/fts3/fts3_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts3HashElem
nKey	src/btreeInt.h	/^  i64 nKey;        \/* Size of pKey, or last integer key *\/$/;"	m	struct:BtCursor
nKey	src/btreeInt.h	/^  i64 nKey;      \/* The key for INTKEY tables, or number of bytes in key *\/$/;"	m	struct:CellInfo
nKey	src/hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
nKeyword	tool/mkkeywordhash.c	/^static int nKeyword = (sizeof(aKeywordTable)\/sizeof(aKeywordTable[0]));$/;"	v	file:
nLabel	src/vdbeInt.h	/^  int nLabel;         \/* Number of labels used *\/$/;"	m	struct:Vdbe
nLabelAlloc	src/vdbeInt.h	/^  int nLabelAlloc;    \/* Number of slots allocated in aLabel[] *\/$/;"	m	struct:Vdbe
nLevel	src/sqliteInt.h	/^  int nLevel;          \/* Number of nested loop *\/$/;"	m	struct:WhereInfo
nLocal	src/btreeInt.h	/^  u16 nLocal;    \/* Amount of payload held locally *\/$/;"	m	struct:CellInfo
nLock	src/os_unix.c	/^  int nLock;            \/* Number of outstanding locks *\/$/;"	m	struct:openCnt	file:
nLookahead	tool/lemon.c	/^  int nLookahead;              \/* Used slots in aLookahead[] *\/$/;"	m	struct:acttab	file:
nLookaheadAlloc	tool/lemon.c	/^  int nLookaheadAlloc;         \/* Slots allocated in aLookahead[] *\/$/;"	m	struct:acttab	file:
nMatch	ext/fts1/fts1.c	/^  int nMatch;     \/* Total number of matches *\/$/;"	m	struct:Snippet	file:
nMatch	ext/fts2/fts2.c	/^  int nMatch;     \/* Total number of matches *\/$/;"	m	struct:Snippet	file:
nMatch	ext/fts3/fts3.c	/^  int nMatch;     \/* Total number of matches *\/$/;"	m	struct:Snippet	file:
nMem	src/sqliteInt.h	/^  int nMem;            \/* Number of memory cells used so far *\/$/;"	m	struct:Parse
nMem	src/vdbeInt.h	/^  int nMem;               \/* Number of memory locations currently allocated *\/$/;"	m	struct:Vdbe
nMiss	src/pager.c	/^  int nHit, nMiss;            \/* Cache hits and missing *\/$/;"	m	struct:Pager	file:
nModuleArg	src/sqliteInt.h	/^  int nModuleArg;           \/* Number of arguments to the module *\/$/;"	m	struct:Table
nMutex	src/btree.h	/^  int nMutex;$/;"	m	struct:BtreeMutexArray
nName	src/test_async.c	/^  int nName;                 \/* Number of characters in zName *\/$/;"	m	struct:AsyncFileData	file:
nNear	ext/fts3/fts3.c	/^  signed char nNear; \/* term followed by a NEAR operator with span=(nNear-1) *\/$/;"	m	struct:QueryTerm	file:
nNtAct	tool/lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nOffset	ext/fts1/fts1.c	/^  int nOffset;    \/* strlen(zOffset) *\/$/;"	m	struct:Snippet	file:
nOffset	ext/fts2/fts2.c	/^  int nOffset;    \/* strlen(zOffset) *\/$/;"	m	struct:Snippet	file:
nOffset	ext/fts3/fts3.c	/^  int nOffset;    \/* strlen(zOffset) *\/$/;"	m	struct:Snippet	file:
nOp	src/vdbeInt.h	/^  int nOp;            \/* Number of instructions in the program *\/$/;"	m	struct:Vdbe
nOpAlloc	src/vdbeInt.h	/^  int nOpAlloc;       \/* Number of slots allocated for aOp[] *\/$/;"	m	struct:Vdbe
nOrderBy	sqlite3.h	/^  int nOrderBy;              \/* Number of terms in the ORDER BY clause *\/$/;"	m	struct:sqlite3_index_info
nOverflow	src/btreeInt.h	/^  u8 nOverflow;        \/* Number of overflow cell bodies in aCell[] *\/$/;"	m	struct:MemPage
nPage	src/btreeInt.h	/^  int nPage;        \/* Number of pages in the database *\/$/;"	m	struct:IntegrityCk
nPage	src/mem4.c	/^  int nPage;$/;"	m	struct:__anon18	file:
nPage	src/pager.c	/^  int nPage;                  \/* Total number of in-memory pages *\/$/;"	m	struct:Pager	file:
nPayload	src/btreeInt.h	/^  u32 nPayload;  \/* Total amount of payload *\/$/;"	m	struct:CellInfo
nPending	src/os_unix.c	/^  int nPending;         \/* Number of pending close() operations *\/$/;"	m	struct:openCnt	file:
nPendingData	ext/fts2/fts2.c	/^  int nPendingData;$/;"	m	struct:fulltext_vtab	file:
nPendingData	ext/fts3/fts3.c	/^  int nPendingData;$/;"	m	struct:fulltext_vtab	file:
nPhrase	ext/fts1/fts1.c	/^  short int nPhrase; \/* How many following terms are part of the same phrase *\/$/;"	m	struct:QueryTerm	file:
nPhrase	ext/fts2/fts2.c	/^  short int nPhrase; \/* How many following terms are part of the same phrase *\/$/;"	m	struct:QueryTerm	file:
nPhrase	ext/fts3/fts3.c	/^  short int nPhrase; \/* How many following terms are part of the same phrase *\/$/;"	m	struct:QueryTerm	file:
nProgressOps	src/sqliteInt.h	/^  int nProgressOps;             \/* Number of opcodes for progress callback *\/$/;"	m	struct:sqlite3
nQPlan	src/where.c	/^static int nQPlan = 0;              \/* Next free slow in _query_plan[] *\/$/;"	v	file:
nRangeReg	src/sqliteInt.h	/^  int nRangeReg;       \/* Size of the temporary register block *\/$/;"	m	struct:Parse
nRead	src/pager.c	/^  int nRead, nWrite;          \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
nReaders	src/os_win.c	/^  int nReaders;       \/* Number of reader locks obtained *\/$/;"	m	struct:winceLock	file:
nRec	src/pager.c	/^  int nRec;                   \/* Number of pages written to the journal *\/$/;"	m	struct:Pager	file:
nRef	sqlite3.h	/^  int nRef;                       \/* Used internally *\/$/;"	m	struct:sqlite3_vtab
nRef	src/btreeInt.h	/^  int nRef;             \/* Number of references to this structure *\/$/;"	m	struct:BtShared
nRef	src/mutex_os2.c	/^  int  nRef;        \/* Number of references *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	src/mutex_unix.c	/^  int nRef;                  \/* Number of entrances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	src/mutex_w32.c	/^  int nRef;                  \/* Number of enterances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	src/os_unix.c	/^  int nRef;             \/* Number of pointers to this structure *\/$/;"	m	struct:openCnt	file:
nRef	src/os_unix.c	/^  int nRef;            \/* Number of pointers to this structure *\/$/;"	m	struct:lockInfo	file:
nRef	src/pager.c	/^  int nRef;                   \/* Number of in-memory pages with PgHdr.nRef>0 *\/$/;"	m	struct:Pager	file:
nRef	src/pager.c	/^  short int nRef;                \/* Number of users of this page *\/$/;"	m	struct:PgHdr	file:
nRef	src/sqliteInt.h	/^  int nRef;            \/* Number of names resolved by this context *\/$/;"	m	struct:NameContext
nRef	src/sqliteInt.h	/^  int nRef;          \/* Number of pointers to this Table *\/$/;"	m	struct:Table
nRef	src/test_onefile.c	/^  int nRef;                   \/* Number of pointers to this structure *\/$/;"	m	struct:fs_real_file	file:
nRefSqlite3	src/test3.c	/^static int nRefSqlite3 = 0;$/;"	v	file:
nRepeat	src/fault.c	/^  int nRepeat;      \/* Number of times to repeat the failure *\/$/;"	m	struct:FaultInjector	file:
nResColumn	src/vdbeInt.h	/^  int nResColumn;         \/* Number of columns in one row of the result set *\/$/;"	m	struct:Vdbe
nResult	src/table.c	/^  int nResult;$/;"	m	struct:TabResult	file:
nRow	src/table.c	/^  int nRow;$/;"	m	struct:TabResult	file:
nSet	src/sqliteInt.h	/^  int nSet;            \/* Number of sets used so far *\/$/;"	m	struct:Parse
nSize	src/btreeInt.h	/^  u16 nSize;     \/* Size of the cell content on the main b-tree page *\/$/;"	m	struct:CellInfo
nSize	src/test_onefile.c	/^  int nSize;$/;"	m	struct:tmp_file	file:
nSlot	src/vdbeInt.h	/^  int nSlot;         \/* Number of entries aSlot[] *\/$/;"	m	struct:FifoPage
nSlot	src/where.c	/^  int nSlot;               \/* Number of entries in a[] *\/$/;"	m	struct:WhereClause	file:
nSnippet	ext/fts1/fts1.c	/^  int nSnippet;   \/* strlen(zSnippet) *\/$/;"	m	struct:Snippet	file:
nSnippet	ext/fts2/fts2.c	/^  int nSnippet;   \/* strlen(zSnippet) *\/$/;"	m	struct:Snippet	file:
nSnippet	ext/fts3/fts3.c	/^  int nSnippet;   \/* strlen(zSnippet) *\/$/;"	m	struct:Snippet	file:
nSortingColumn	src/sqliteInt.h	/^  int nSortingColumn;     \/* Number of columns in the sorting index *\/$/;"	m	struct:AggInfo
nSql	src/tclsqlite.c	/^  int nSql;                \/* chars in zSql[] *\/$/;"	m	struct:SqlPreparedStmt	file:
nSql	src/vdbeInt.h	/^  int nSql;             \/* Number of bytes in zSql *\/$/;"	m	struct:Vdbe
nSrc	src/sqliteInt.h	/^  i16 nSrc;        \/* Number of tables or subqueries in the FROM clause *\/$/;"	m	struct:SrcList
nStmt	src/tclsqlite.c	/^  int nStmt;                 \/* Number of statements in stmtList *\/$/;"	m	struct:SqliteDb	file:
nTab	src/sqliteInt.h	/^  int nTab;            \/* Number of previously allocated VDBE cursors *\/$/;"	m	struct:Parse
nTable	src/sqliteInt.h	/^  int nTable;                   \/* Number of tables in the database *\/$/;"	m	struct:sqlite3
nTableLock	src/sqliteInt.h	/^  int nTableLock;        \/* Number of locks in aTableLock *\/$/;"	m	struct:Parse
nTempInUse	src/sqliteInt.h	/^  u8 nTempInUse;       \/* Number of aTempReg[] currently checked out *\/$/;"	m	struct:Parse
nTempReg	src/sqliteInt.h	/^  u8 nTempReg;         \/* Number of temporary registers in aTempReg[] *\/$/;"	m	struct:Parse
nTerm	ext/fts1/fts1.c	/^  int nTerm;         \/* Number of bytes in pTerm[] *\/$/;"	m	struct:QueryTerm	file:
nTerm	ext/fts2/fts2.c	/^  int nTerm;         \/* Number of bytes in pTerm[] *\/$/;"	m	struct:QueryTerm	file:
nTerm	ext/fts2/fts2.c	/^  int nTerm;$/;"	m	struct:TermData	file:
nTerm	ext/fts3/fts3.c	/^  int nTerm;         \/* Number of bytes in pTerm[] *\/$/;"	m	struct:QueryTerm	file:
nTerm	ext/fts3/fts3.c	/^  int nTerm;$/;"	m	struct:TermData	file:
nTerm	src/where.c	/^  int nTerm;               \/* Number of terms *\/$/;"	m	struct:WhereClause	file:
nTermDistinct	ext/fts2/fts2.c	/^  int nTermDistinct;$/;"	m	struct:LeafWriter	file:
nTermDistinct	ext/fts3/fts3.c	/^  int nTermDistinct;$/;"	m	struct:LeafWriter	file:
nTerms	ext/fts1/fts1.c	/^  int nTerms;           \/* Number of terms in the query *\/$/;"	m	struct:Query	file:
nTerms	ext/fts2/fts2.c	/^  int nTerms;           \/* Number of terms in the query *\/$/;"	m	struct:Query	file:
nTerms	ext/fts3/fts3.c	/^  int nTerms;           \/* Number of terms in the query *\/$/;"	m	struct:Query	file:
nTitle	src/mem2.c	/^  int nTitle;        \/* Bytes of zTitle to save.  Includes '\\0' and padding *\/$/;"	m	struct:__anon16	file:
nTitle	src/mem2.c	/^  short nTitle;                       \/* Bytes of title; includes '\\0' *\/$/;"	m	struct:MemBlockHdr	file:
nTknAct	tool/lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nTokenAllocated	ext/fts1/fts1_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenAllocated	ext/fts2/fts2_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenAllocated	ext/fts3/fts3_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTotalChange	src/sqliteInt.h	/^  int nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/$/;"	m	struct:sqlite3
nTransaction	src/btreeInt.h	/^  int nTransaction;     \/* Number of open transactions (read + write) *\/$/;"	m	struct:BtShared
nTrunc	src/btreeInt.h	/^  Pgno nTrunc;          \/* Non-zero if the db will be truncated (incr vacuum) *\/$/;"	m	struct:BtShared
nUsed	src/test1.c	/^  int nUsed;   \/* Space used *\/$/;"	m	struct:dstr	file:
nVTrans	src/sqliteInt.h	/^  int nVTrans;                  \/* Allocated size of aVTrans *\/$/;"	m	struct:sqlite3
nVar	src/sqliteInt.h	/^  int nVar;            \/* Number of '?' variables seen in the SQL so far *\/$/;"	m	struct:Parse
nVar	src/vdbeInt.h	/^  int nVar;           \/* Number of entries in aVar[] *\/$/;"	m	struct:Vdbe
nVarExpr	src/sqliteInt.h	/^  int nVarExpr;        \/* Number of used slots in apVarExpr[] *\/$/;"	m	struct:Parse
nVarExprAlloc	src/sqliteInt.h	/^  int nVarExprAlloc;   \/* Number of allocated slots in apVarExpr[] *\/$/;"	m	struct:Parse
nWrite	src/pager.c	/^  int nRead, nWrite;          \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
name	src/sqliteInt.h	/^  char *name;             \/* The name of the trigger                        *\/$/;"	m	struct:Trigger
name	tool/lemon.c	/^  char *name;              \/* Name of the generated parser *\/$/;"	m	struct:lemon	file:
name	tool/lemon.c	/^  char *name;              \/* Name of the symbol *\/$/;"	m	struct:symbol	file:
nameClash	src/sqliteInt.h	/^  u8 nameClash;        \/* A permanent table name clashes with temp table name *\/$/;"	m	struct:Parse
nameResolverStep	src/expr.c	/^static int nameResolverStep(void *pArg, Expr *pExpr){$/;"	f	file:
nameToken	src/sqliteInt.h	/^  Token nameToken;        \/* Token containing zName. Use during parsing only *\/$/;"	m	struct:Trigger
name_to_enc	src/test5.c	/^static u8 name_to_enc(Tcl_Interp *interp, Tcl_Obj *pObj){$/;"	f	file:
nappend	ext/fts1/fts1.c	/^static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){$/;"	f	file:
nappend	ext/fts2/fts2.c	/^static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){$/;"	f	file:
nappend	ext/fts3/fts3.c	/^static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){$/;"	f	file:
nconflict	tool/lemon.c	/^  int nconflict;           \/* Number of parsing conflicts *\/$/;"	m	struct:lemon	file:
needCollSeq	src/sqliteInt.h	/^  u8 needCollSeq;      \/* True if sqlite3GetFuncCollSeq() might be called *\/$/;"	m	struct:FuncDef
needCsvQuote	src/shell.c	/^static const char needCsvQuote[] = {$/;"	v	file:
needRead	src/pager.c	/^  u8 needRead;                   \/* Read content if PagerWrite() is called *\/$/;"	m	struct:PgHdr	file:
needSync	src/pager.c	/^  u8 needSync;                   \/* Sync journal before writing this page *\/$/;"	m	struct:PgHdr	file:
needSync	src/pager.c	/^  u8 needSync;                \/* True if an fsync() is needed on the journal *\/$/;"	m	struct:Pager	file:
needToFreeIdxStr	sqlite3.h	/^  int needToFreeIdxStr;      \/* Free idxStr using sqlite3_free() if true *\/$/;"	m	struct:sqlite3_index_info
nested	src/sqliteInt.h	/^  u8 nested;           \/* Number of nested calls to the parser\/code generator *\/$/;"	m	struct:Parse
newColMask	src/sqliteInt.h	/^  u32 newColMask;$/;"	m	struct:TriggerStack
newDatabase	src/btree.c	/^static int newDatabase(BtShared *pBt){$/;"	f	file:
newIdx	src/sqliteInt.h	/^  int newIdx;          \/* Index of vdbe cursor to "new" temp table *\/$/;"	m	struct:TriggerStack
newTnum	src/sqliteInt.h	/^    int newTnum;                \/* Rootpage of table being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
newconfig	tool/lemon.c	/^PRIVATE struct config *newconfig(){$/;"	f
next	ext/fts1/fts1_hash.h	/^  fts1HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts1HashElem
next	ext/fts2/fts2.c	/^  struct InteriorBlock *next;$/;"	m	struct:InteriorBlock	typeref:struct:InteriorBlock::InteriorBlock	file:
next	ext/fts2/fts2_hash.h	/^  fts2HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts2HashElem
next	ext/fts3/fts3.c	/^  struct InteriorBlock *next;$/;"	m	struct:InteriorBlock	typeref:struct:InteriorBlock::InteriorBlock	file:
next	ext/fts3/fts3_hash.h	/^  fts3HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts3HashElem
next	src/hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
next	src/mem3.c	/^      u32 next;       \/* Index in mem.aPool[] of next free chunk *\/$/;"	m	struct:Mem3Block::__anon19::__anon21	file:
next	tool/lemon.c	/^  struct action *next;     \/* Next action for this state *\/$/;"	m	struct:action	typeref:struct:action::action	file:
next	tool/lemon.c	/^  struct config *next;     \/* Next configuration in the state *\/$/;"	m	struct:config	typeref:struct:config::config	file:
next	tool/lemon.c	/^  struct plink *next;      \/* The next propagate link *\/$/;"	m	struct:plink	typeref:struct:plink::plink	file:
next	tool/lemon.c	/^  struct rule *next;       \/* Next rule in the global list *\/$/;"	m	struct:rule	typeref:struct:rule::rule	file:
next	tool/lemon.c	/^  struct s_x1node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x1node	typeref:struct:s_x1node::s_x1node	file:
next	tool/lemon.c	/^  struct s_x2node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::s_x2node	file:
next	tool/lemon.c	/^  struct s_x3node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::s_x3node	file:
next	tool/lemon.c	/^  struct s_x4node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::s_x4node	file:
next2	src/test_tclvar.c	/^static int next2(Tcl_Interp *interp, tclvar_cursor *pCur, Tcl_Obj *pObj){$/;"	f	file:
nextAutovac	src/sqliteInt.h	/^  signed char nextAutovac;      \/* Autovac setting after VACUUM if >=0 *\/$/;"	m	struct:sqlite3
nextColumn	ext/fts1/fts1.c	/^  int nextColumn;       \/* Next word parsed must be in this column *\/$/;"	m	struct:Query	file:
nextColumn	ext/fts2/fts2.c	/^  int nextColumn;       \/* Next word parsed must be in this column *\/$/;"	m	struct:Query	file:
nextColumn	ext/fts3/fts3.c	/^  int nextColumn;       \/* Next word parsed must be in this column *\/$/;"	m	struct:Query	file:
nextDocid	ext/fts1/fts1.c	/^static sqlite_int64 nextDocid(DocListReader *pIn){$/;"	f	file:
nextIsNear	ext/fts3/fts3.c	/^  int nextIsNear;       \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextIsOr	ext/fts1/fts1.c	/^  int nextIsOr;         \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextIsOr	ext/fts2/fts2.c	/^  int nextIsOr;         \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextIsOr	ext/fts3/fts3.c	/^  int nextIsOr;         \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextRowid	src/vdbeInt.h	/^  i64 nextRowid;        \/* Next rowid returned by OP_NewRowid *\/$/;"	m	struct:Cursor
nextRowidValid	src/vdbeInt.h	/^  Bool nextRowidValid;  \/* True if the nextRowid field is valid *\/$/;"	m	struct:Cursor
nextlhs	tool/lemon.c	/^  struct rule *nextlhs;    \/* Next rule with the same LHS *\/$/;"	m	struct:rule	typeref:struct:rule::rule	file:
noCase	src/func.c	/^  u8 noCase;$/;"	m	struct:compareInfo	file:
noLockingStyle	src/os_unix.c	/^        noLockingStyle,              \/* useful for read-only file system *\/$/;"	e	enum:__anon15	file:
noReadlock	src/pager.c	/^  u8 noReadlock;              \/* Do not bother to obtain readlocks *\/$/;"	m	struct:Pager	file:
noSync	src/pager.c	/^  u8 noSync;                  \/* Do not sync the journal if true *\/$/;"	m	struct:Pager	file:
nocaseCollatingFunc	src/main.c	/^static int nocaseCollatingFunc($/;"	f	file:
nolockLockingContext	src/os_unix.c	/^typedef void nolockLockingContext;$/;"	t	file:
nolockUnixCheckReservedLock	src/os_unix.c	/^static int nolockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
nolockUnixClose	src/os_unix.c	/^static int nolockUnixClose(sqlite3_file *id) {$/;"	f	file:
nolockUnixLock	src/os_unix.c	/^static int nolockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
nolockUnixUnlock	src/os_unix.c	/^static int nolockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
not	parse.c	/^  int not;         \/* True if the NOT keyword is present *\/$/;"	m	struct:LikeOp	file:
notNull	src/sqliteInt.h	/^  u8 notNull;      \/* True if there is a NOT NULL constraint *\/$/;"	m	struct:Column
notUsed1	src/sqliteInt.h	/^    double notUsed1;            \/* Spacer *\/$/;"	m	union:sqlite3::__anon13
nowUsed	src/mem1.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon12	file:
nowUsed	src/mem2.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon16	file:
nowUsed	src/mem4.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon18	file:
nowUsedMMap	src/mem4.c	/^  sqlite3_int64 nowUsedMMap;$/;"	m	struct:__anon18	file:
nrhs	lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	struct:__anon4	file:
nrhs	parse.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	struct:__anon27	file:
nrhs	tool/lemon.c	/^  int nrhs;                  \/* Number of right-hand side symbols seen *\/$/;"	m	struct:pstate	file:
nrhs	tool/lemon.c	/^  int nrhs;                \/* Number of RHS symbols *\/$/;"	m	struct:rule	file:
nrhs	tool/lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	struct:__anon11	file:
nrule	tool/lemon.c	/^  int nrule;               \/* Number of rules *\/$/;"	m	struct:lemon	file:
nstate	tool/lemon.c	/^  int nstate;              \/* Number of states *\/$/;"	m	struct:lemon	file:
nsubsym	tool/lemon.c	/^  int nsubsym;             \/* Number of constituent symbols in the MULTI *\/$/;"	m	struct:symbol	file:
nsymbol	tool/lemon.c	/^  int nsymbol;             \/* Number of terminal and nonterminal symbols *\/$/;"	m	struct:lemon	file:
nterminal	tool/lemon.c	/^  int nterminal;           \/* Number of terminal symbols *\/$/;"	m	struct:lemon	file:
nullRow	src/vdbeInt.h	/^  Bool nullRow;         \/* True if pointing to a row with no data *\/$/;"	m	struct:Cursor
nullifFunc	src/func.c	/^static void nullifFunc($/;"	f	file:
nullvalue	src/shell.c	/^  char nullvalue[20];    \/* The text to print when a NULL comes back from$/;"	m	struct:callback_data	file:
number_name	tool/speedtest.tcl	/^proc number_name {n} {$/;"	p
number_name	tool/speedtest2.tcl	/^proc number_name {n} {$/;"	p
nxt	src/sqliteInt.h	/^  int nxt;              \/* Jump here to start the next IN combination *\/$/;"	m	struct:WhereLevel
offset	src/os_unix.c	/^  unsigned long long offset;        \/* offset to first byte to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
offset	tool/mkkeywordhash.c	/^  int offset;          \/* Offset to start of name string *\/$/;"	m	struct:Keyword	file:
offsetof	src/sqliteInt.h	230;"	d
okVar	src/vdbeInt.h	/^  int okVar;          \/* True if azVar[] has been initialized *\/$/;"	m	struct:Vdbe
oldColMask	src/sqliteInt.h	/^  u32 oldColMask;$/;"	m	struct:TriggerStack
oldIdx	src/sqliteInt.h	/^  int oldIdx;          \/* Index of vdbe cursor to "old" temp table *\/$/;"	m	struct:TriggerStack
omit	sqlite3.h	/^    unsigned char omit;      \/* Do not code a test for this constraint *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint_usage
onError	src/sqliteInt.h	/^  u8 onError;      \/* OE_Abort, OE_Ignore, OE_Replace, or OE_None *\/$/;"	m	struct:Index
one_input_line	src/shell.c	/^static char *one_input_line(const char *zPrior, FILE *in){$/;"	f	file:
op	sqlite3.h	/^     unsigned char op;         \/* Constraint operator *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint
op	src/sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
op	src/sqliteInt.h	/^  int op;              \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT *\/$/;"	m	struct:TriggerStep
op	src/sqliteInt.h	/^  u8 op;                  \/* One of TK_DELETE, TK_UPDATE, TK_INSERT         *\/$/;"	m	struct:Trigger
op	src/sqliteInt.h	/^  u8 op;                 \/* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT *\/$/;"	m	struct:Select
op	src/sqliteInt.h	/^  u8 op;                 \/* Operation performed by this node *\/$/;"	m	struct:Expr
op	src/test_async.c	/^  int op;                      \/* One of ASYNC_xxx etc. *\/$/;"	m	struct:AsyncWrite	file:
op	src/test_server.c	/^  int op;                      \/* Opcode for the message *\/$/;"	m	struct:SqlMessage	file:
op	tool/lemon.c	/^static struct s_options *op;$/;"	v	typeref:struct:s_options	file:
opcode	src/vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOp
opcode	src/vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOpList
opcodeProperty	src/vdbe.c	/^static unsigned char opcodeProperty[] = OPFLG_INITIALIZER;$/;"	v	file:
open	src/sqlite3ext.h	/^  int  (*open)(const char*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
open16	src/sqlite3ext.h	/^  int  (*open16)(const void*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
openCnt	src/os_unix.c	/^struct openCnt {$/;"	s	file:
openDatabase	src/main.c	/^static int openDatabase($/;"	f	file:
openDirectory	src/os_unix.c	/^static int openDirectory(const char *zFilename, int *pFd){$/;"	f	file:
openFlags	src/sqliteInt.h	/^  int openFlags;                \/* Flags passed to sqlite3_vfs.xOpen() *\/$/;"	m	struct:sqlite3
openHash	src/os_unix.c	/^static Hash openHash = {SQLITE_HASH_BINARY, 0, 0, 0, 0, 0};$/;"	v	file:
openKey	src/os_unix.c	/^struct openKey {$/;"	s	file:
openStatTable	src/analyze.c	/^static void openStatTable($/;"	f	file:
open_db	src/shell.c	/^static void open_db(struct callback_data *p){$/;"	f	file:
open_v2	src/sqlite3ext.h	/^  int (*open_v2)(const char*,sqlite3**,int,const char*);$/;"	m	struct:sqlite3_api_routines
openedStatement	src/vdbeInt.h	/^  int openedStatement;  \/* True if this VM has opened a statement journal *\/$/;"	m	struct:Vdbe
operatorMask	src/where.c	/^static int operatorMask(int op){$/;"	f	file:
opnum	src/test4.c	/^  int opnum;             \/* Operation number *\/$/;"	m	struct:Thread	file:
opnum	src/test7.c	/^  volatile int opnum;      \/* Operation number *\/$/;"	m	struct:Thread	file:
orTermHasOkDuplicate	src/where.c	/^static int orTermHasOkDuplicate(WhereClause *pOr, WhereTerm *pOrTerm){$/;"	f	file:
orTermIsOptCandidate	src/where.c	/^static int orTermIsOptCandidate(WhereTerm *pOrTerm, int iCursor, int iColumn){$/;"	f	file:
orconf	src/sqliteInt.h	/^  int orconf;          \/* Current orconf policy *\/$/;"	m	struct:TriggerStack
orconf	src/sqliteInt.h	/^  int orconf;          \/* OE_Rollback etc. *\/$/;"	m	struct:TriggerStep
orderByConsumed	sqlite3.h	/^  int orderByConsumed;       \/* True if output is already ordered *\/$/;"	m	struct:sqlite3_index_info
orderedDLReaderCmp	ext/fts2/fts2.c	/^static int orderedDLReaderCmp(OrderedDLReader *r1, OrderedDLReader *r2){$/;"	f	file:
orderedDLReaderCmp	ext/fts3/fts3.c	/^static int orderedDLReaderCmp(OrderedDLReader *r1, OrderedDLReader *r2){$/;"	f	file:
orderedDLReaderReorder	ext/fts2/fts2.c	/^static void orderedDLReaderReorder(OrderedDLReader *p, int n){$/;"	f	file:
orderedDLReaderReorder	ext/fts3/fts3.c	/^static void orderedDLReaderReorder(OrderedDLReader *p, int n){$/;"	f	file:
origDbSize	src/pager.c	/^  int origDbSize;             \/* dbSize before the current change *\/$/;"	m	struct:Pager	file:
os2Access	src/os_os2.c	/^static int os2Access($/;"	f	file:
os2CheckReservedLock	src/os_os2.c	/^int os2CheckReservedLock( sqlite3_file *id ){$/;"	f
os2Close	src/os_os2.c	/^int os2Close( sqlite3_file *id ){$/;"	f
os2CurrentTime	src/os_os2.c	/^int os2CurrentTime( sqlite3_vfs *pVfs, double *prNow ){$/;"	f
os2Delete	src/os_os2.c	/^int os2Delete($/;"	f
os2DeviceCharacteristics	src/os_os2.c	/^static int os2DeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
os2DlClose	src/os_os2.c	/^void os2DlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
os2DlClose	src/os_os2.c	857;"	d	file:
os2DlError	src/os_os2.c	/^static void os2DlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
os2DlError	src/os_os2.c	855;"	d	file:
os2DlOpen	src/os_os2.c	/^static void *os2DlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
os2DlOpen	src/os_os2.c	854;"	d	file:
os2DlSym	src/os_os2.c	/^void *os2DlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
os2DlSym	src/os_os2.c	856;"	d	file:
os2File	src/os_os2.c	/^struct os2File {$/;"	s	file:
os2File	src/os_os2.c	/^typedef struct os2File os2File;$/;"	t	typeref:struct:os2File	file:
os2FileControl	src/os_os2.c	/^static int os2FileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
os2FileSize	src/os_os2.c	/^int os2FileSize( sqlite3_file *id, sqlite3_int64 *pSize ){$/;"	f
os2FullPathname	src/os_os2.c	/^static int os2FullPathname($/;"	f	file:
os2GetTempname	src/os_os2.c	/^static int os2GetTempname( sqlite3_vfs *pVfs, int nBuf, char *zBuf ){$/;"	f	file:
os2IoMethod	src/os_os2.c	/^static const sqlite3_io_methods os2IoMethod = {$/;"	v	file:
os2Lock	src/os_os2.c	/^int os2Lock( sqlite3_file *id, int locktype ){$/;"	f
os2Open	src/os_os2.c	/^static int os2Open($/;"	f	file:
os2Randomness	src/os_os2.c	/^static int os2Randomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf ){$/;"	f	file:
os2Read	src/os_os2.c	/^int os2Read($/;"	f
os2SectorSize	src/os_os2.c	/^static int os2SectorSize(sqlite3_file *id){$/;"	f	file:
os2Sleep	src/os_os2.c	/^static int os2Sleep( sqlite3_vfs *pVfs, int microsec ){$/;"	f	file:
os2Sync	src/os_os2.c	/^int os2Sync( sqlite3_file *id, int flags ){$/;"	f
os2Truncate	src/os_os2.c	/^int os2Truncate( sqlite3_file *id, i64 nByte ){$/;"	f
os2Unlock	src/os_os2.c	/^int os2Unlock( sqlite3_file *id, int locktype ){$/;"	f
os2Write	src/os_os2.c	/^int os2Write($/;"	f
osUnlock	src/pager.c	/^static int osUnlock(sqlite3_file *pFd, int eLock){$/;"	f	file:
out	src/shell.c	/^  FILE *out;             \/* Write results here *\/$/;"	m	struct:callback_data	file:
out_of_memory	tool/showdb.c	/^static void out_of_memory(void){$/;"	f	file:
out_of_memory	tool/showjournal.c	/^static void out_of_memory(void){$/;"	f	file:
outfile	src/shell.c	/^  char outfile[FILENAME_MAX]; \/* Filename for *out *\/$/;"	m	struct:callback_data	file:
outname	tool/lemon.c	/^  char *outname;           \/* Name of the current output file *\/$/;"	m	struct:lemon	file:
output_c_string	src/shell.c	/^static void output_c_string(FILE *out, const char *z){$/;"	f	file:
output_csv	src/shell.c	/^static void output_csv(struct callback_data *p, const char *z, int bSep){$/;"	f	file:
output_html_string	src/shell.c	/^static void output_html_string(FILE *out, const char *z){$/;"	f	file:
output_quoted_string	src/shell.c	/^static void output_quoted_string(FILE *out, const char *z){$/;"	f	file:
overflow	src/func.c	/^  u8 overflow;      \/* True if integer overflow seen *\/$/;"	m	struct:SumCtx	file:
overflow	tool/lemon.c	/^  char *overflow;          \/* Code to execute on a stack overflow *\/$/;"	m	struct:lemon	file:
overflowln	tool/lemon.c	/^  int  overflowln;         \/* Line number for start of overflow code *\/$/;"	m	struct:lemon	file:
overload_function	src/sqlite3ext.h	/^  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);$/;"	m	struct:sqlite3_api_routines
overloadedGlobFunction	src/test8.c	/^static void overloadedGlobFunction($/;"	f	file:
owner	src/mutex_os2.c	/^  TID  owner;       \/* Thread holding this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
owner	src/mutex_unix.c	/^  pthread_t owner;           \/* Thread that is within this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
owner	src/mutex_w32.c	/^  DWORD owner;               \/* Thread holding this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
p	ext/fts1/fts1.c	/^  char *p;            \/* Pointer to next unread byte in the doclist *\/$/;"	m	struct:DocListReader	file:
p	src/vdbe.h	/^    void *p;               \/* Generic pointer *\/$/;"	m	union:VdbeOp::__anon23
p1	src/sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p1	src/vdbe.h	/^  int p1;             \/* First operand *\/$/;"	m	struct:VdbeOp
p1	src/vdbe.h	/^  signed char p1;     \/* First operand *\/$/;"	m	struct:VdbeOpList
p2	src/sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p2	src/vdbe.h	/^  int p2;             \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOp
p2	src/vdbe.h	/^  signed char p2;     \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOpList
p3	src/vdbe.h	/^  int p3;             \/* The third parameter *\/$/;"	m	struct:VdbeOp
p3	src/vdbe.h	/^  signed char p3;     \/* Third parameter *\/$/;"	m	struct:VdbeOpList
p4	src/vdbe.h	/^  } p4;$/;"	m	struct:VdbeOp	typeref:union:VdbeOp::__anon23
p4type	src/vdbe.h	/^  signed char p4type; \/* One of the P4_xxx constants for p4 *\/$/;"	m	struct:VdbeOp
p5	src/vdbe.h	/^  u8 p5;              \/* Fifth parameter is an unsigned character *\/$/;"	m	struct:VdbeOp
pAggInfo	src/sqliteInt.h	/^  AggInfo *pAggInfo;     \/* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION *\/$/;"	m	struct:Expr
pAggInfo	src/sqliteInt.h	/^  AggInfo *pAggInfo;   \/* Information about aggregates at this level *\/$/;"	m	struct:NameContext
pAll	src/pager.c	/^  PgHdr *pAll;                \/* List of all pages *\/$/;"	m	struct:Pager	file:
pAppData	sqlite3.h	/^  void *pAppData;          \/* Pointer to application-specific data *\/$/;"	m	struct:sqlite3_vfs
pArg	src/btreeInt.h	/^  void *pArg;               \/* First arg to xCompare() *\/$/;"	m	struct:BtCursor
pArg	src/sqliteInt.h	/^  void *pArg;                \/* First arg to busy callback *\/$/;"	m	struct:BusyHandler
pAuthArg	src/sqliteInt.h	/^  void *pAuthArg;               \/* 1st argument to the access auth function *\/$/;"	m	struct:sqlite3
pAux	src/sqliteInt.h	/^  void *pAux;                          \/* pAux passed to create_module() *\/$/;"	m	struct:Module
pAux	src/sqliteInt.h	/^  void *pAux;               \/* Auxiliary data.  Usually NULL *\/$/;"	m	struct:Db
pAux	src/vdbeInt.h	/^    void *pAux;                   \/* Aux data for the i-th argument *\/$/;"	m	struct:VdbeFunc::AuxData
pBaseRead	src/test_async.c	/^  sqlite3_file *pBaseRead;   \/* Read handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBaseWrite	src/test_async.c	/^  sqlite3_file *pBaseWrite;  \/* Write handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBestIdx	src/sqliteInt.h	/^  sqlite3_index_info *pBestIdx;  \/* Index information for this level *\/$/;"	m	struct:WhereLevel
pBlob	src/tclsqlite.c	/^  sqlite3_blob *pBlob;      \/* sqlite3 blob handle *\/$/;"	m	struct:IncrblobChannel	file:
pBt	src/btreeInt.h	/^  BtShared *pBt;            \/* The BtShared this cursor points to *\/$/;"	m	struct:BtCursor
pBt	src/btreeInt.h	/^  BtShared *pBt;       \/* Pointer to BtShared that this page is part of *\/$/;"	m	struct:MemPage
pBt	src/btreeInt.h	/^  BtShared *pBt;     \/* Sharable content of this btree *\/$/;"	m	struct:Btree
pBt	src/btreeInt.h	/^  BtShared *pBt;    \/* The tree being checked out *\/$/;"	m	struct:IntegrityCk
pBt	src/sqliteInt.h	/^  Btree *pBt;          \/* The B*Tree structure for this database file *\/$/;"	m	struct:Db
pBt	src/vdbeInt.h	/^  Btree *pBt;           \/* Separate file holding temporary table *\/$/;"	m	struct:Cursor
pBtree	src/btreeInt.h	/^  Btree *pBtree;            \/* The Btree to which this cursor belongs *\/$/;"	m	struct:BtCursor
pBtree	src/btreeInt.h	/^  Btree *pBtree;        \/* Btree handle holding this lock *\/$/;"	m	struct:BtLock
pBusyHandler	src/pager.c	/^  BusyHandler *pBusyHandler;  \/* Pointer to sqlite.busyHandler *\/$/;"	m	struct:Pager	file:
pCell	src/btreeInt.h	/^    u8 *pCell;          \/* Pointers to the body of the overflow cell *\/$/;"	m	struct:MemPage::_OvflCell
pCell	src/btreeInt.h	/^  u8 *pCell;     \/* Pointer to the start of cell content *\/$/;"	m	struct:CellInfo
pCheck	src/sqliteInt.h	/^  Expr *pCheck;      \/* The AND of all CHECK constraints *\/$/;"	m	struct:Table
pCmp	src/test1.c	/^  Tcl_Obj *pCmp;$/;"	m	struct:TestCollationX	file:
pCodecArg	src/pager.c	/^  void *pCodecArg;            \/* First argument to xCodec() *\/$/;"	m	struct:Pager	file:
pColl	src/sqliteInt.h	/^  CollSeq *pColl;        \/* The collation type of the column or 0 *\/$/;"	m	struct:Expr
pColl	src/vdbe.h	/^    CollSeq *pColl;        \/* Used when p4type is P4_COLLSEQ *\/$/;"	m	union:VdbeOp::__anon23
pColl	src/vdbeInt.h	/^  CollSeq *pColl;       \/* Collating sequence *\/$/;"	m	struct:sqlite3_context
pCollNeededArg	src/sqliteInt.h	/^  void *pCollNeededArg;$/;"	m	struct:sqlite3
pCollate	src/tclsqlite.c	/^  SqlCollate *pCollate;      \/* List of SQL collation functions *\/$/;"	m	struct:SqliteDb	file:
pCollateNeeded	src/tclsqlite.c	/^  Tcl_Obj *pCollateNeeded;   \/* Collation needed script *\/$/;"	m	struct:SqliteDb	file:
pCollector	ext/fts2/fts2.c	/^  DLCollector *pCollector;$/;"	m	struct:TermData	file:
pCollector	ext/fts3/fts3.c	/^  DLCollector *pCollector;$/;"	m	struct:TermData	file:
pColumnList	src/test_schema.c	/^  sqlite3_stmt *pColumnList;$/;"	m	struct:schema_cursor	file:
pColumns	src/sqliteInt.h	/^  IdList *pColumns;       \/* If this is an UPDATE OF <column-list> trigger,$/;"	m	struct:Trigger
pCommitArg	src/sqliteInt.h	/^  void *pCommitArg;                 \/* Argument to xCommitCallback() *\/   $/;"	m	struct:sqlite3
pCsr	src/vdbeblob.c	/^  BtCursor *pCsr;         \/* Cursor pointing at blob row *\/$/;"	m	struct:Incrblob	file:
pCursor	src/btreeInt.h	/^  BtCursor *pCursor;    \/* A list of all open cursors *\/$/;"	m	struct:BtShared
pCursor	src/vdbeInt.h	/^  BtCursor *pCursor;    \/* The cursor structure of the backend *\/$/;"	m	struct:Cursor
pData	ext/fts1/fts1.c	/^  char *pData;$/;"	m	struct:DocList	file:
pData	ext/fts2/fts2.c	/^  char *pData;          \/* Pointer to malloc'ed buffer. *\/$/;"	m	struct:DataBuffer	file:
pData	ext/fts2/fts2.c	/^  const char *pData;        \/* data for current term. *\/$/;"	m	struct:LeafReader	file:
pData	ext/fts2/fts2.c	/^  const char *pData;$/;"	m	struct:DLReader	file:
pData	ext/fts2/fts2.c	/^  const char *pData;$/;"	m	struct:InteriorReader	file:
pData	ext/fts2/fts2.c	/^  const char *pData;$/;"	m	struct:PLReader	file:
pData	ext/fts3/fts3.c	/^  char *pData;          \/* Pointer to malloc'ed buffer. *\/$/;"	m	struct:DataBuffer	file:
pData	ext/fts3/fts3.c	/^  const char *pData;        \/* data for current term. *\/$/;"	m	struct:LeafReader	file:
pData	ext/fts3/fts3.c	/^  const char *pData;$/;"	m	struct:DLReader	file:
pData	ext/fts3/fts3.c	/^  const char *pData;$/;"	m	struct:InteriorReader	file:
pData	ext/fts3/fts3.c	/^  const char *pData;$/;"	m	struct:PLReader	file:
pData	src/pager.c	/^  void *pData;                   \/* Page data *\/$/;"	m	struct:PgHdr	file:
pData	src/test_async.c	/^  AsyncFileData *pData;$/;"	m	struct:AsyncFile	file:
pData	src/vdbeInt.h	/^  char *pData;          \/* Data for a NEW or OLD pseudo-table *\/$/;"	m	struct:Cursor
pDb	src/tclsqlite.c	/^  SqliteDb *pDb;            \/* Associated database connection *\/$/;"	m	struct:IncrblobChannel	file:
pDb	src/test_server.c	/^  sqlite3 *pDb;                \/* The SQLite connection *\/$/;"	m	struct:SqlMessage	file:
pDbList	src/test_schema.c	/^  sqlite3_stmt *pDbList;$/;"	m	struct:schema_cursor	file:
pDbPage	src/btreeInt.h	/^  DbPage *pDbPage;     \/* Pager page handle *\/$/;"	m	struct:MemPage
pDef	src/vdbeInt.h	/^    FuncDef *pDef;      \/* Used only when flags==MEM_Agg *\/$/;"	m	union:Mem::__anon17
pDel	src/test1.c	/^  Tcl_Obj *pDel;$/;"	m	struct:TestCollationX	file:
pDflt	src/sqliteInt.h	/^  Expr *pDflt;     \/* Default value of this column *\/$/;"	m	struct:Column
pDfltColl	src/sqliteInt.h	/^  CollSeq *pDfltColl;           \/* The default collating sequence (BINARY) *\/$/;"	m	struct:sqlite3
pDirty	src/pager.c	/^  PgHdr *pDirty, *pPrevDirty;    \/* Dirty pages *\/$/;"	m	struct:PgHdr	file:
pDirty	src/pager.c	/^  PgHdr *pDirty;              \/* List of all dirty pages *\/$/;"	m	struct:Pager	file:
pDoclist	ext/fts1/fts1.c	/^  DocList *pDoclist;  \/* The document list we are stepping through *\/$/;"	m	struct:DocListReader	file:
pEList	src/sqliteInt.h	/^  ExprList *pEList;      \/* The fields of the result *\/$/;"	m	struct:Select
pEList	src/sqliteInt.h	/^  ExprList *pEList;    \/* Optional list of named expressions *\/$/;"	m	struct:NameContext
pErr	src/sqliteInt.h	/^  sqlite3_value *pErr;          \/* Most recent error message *\/$/;"	m	struct:sqlite3
pExclusive	src/btreeInt.h	/^  Btree *pExclusive;    \/* Btree with an EXCLUSIVE lock on the whole db *\/$/;"	m	struct:BtShared
pExpr	src/sqliteInt.h	/^    Expr *pExpr;             \/* Expression encoding the function *\/$/;"	m	struct:AggInfo::AggInfo_func
pExpr	src/sqliteInt.h	/^    Expr *pExpr;             \/* The original expression *\/$/;"	m	struct:AggInfo::AggInfo_col
pExpr	src/sqliteInt.h	/^    Expr *pExpr;           \/* The list of expressions *\/$/;"	m	struct:ExprList::ExprList_item
pExpr	src/where.c	/^  Expr *pExpr;            \/* Pointer to the subexpression *\/$/;"	m	struct:WhereTerm	file:
pExprList	src/sqliteInt.h	/^  ExprList *pExprList; \/* Valid for UPDATE statements and sometimes $/;"	m	struct:TriggerStep
pFKey	src/sqliteInt.h	/^  FKey *pFKey;       \/* Linked list of all foreign keys in this table *\/$/;"	m	struct:Table
pFetch	src/sqliteInt.h	/^  sqlite3_stmt *pFetch;         \/* Used by SSE to fetch stored statements *\/$/;"	m	struct:sqlite3
pFile	src/test6.c	/^  CrashFile *pFile;            \/* File this write() applies to *\/$/;"	m	struct:WriteBuffer	file:
pFile	src/test_async.c	/^  sqlite3_file *pFile;$/;"	m	struct:AsyncLock	file:
pFile	src/test_onefile.c	/^  sqlite3_file *pFile;$/;"	m	struct:fs_real_file	file:
pFileData	src/test_async.c	/^  AsyncFileData *pFileData;    \/* File to write data to or sync *\/$/;"	m	struct:AsyncWrite	file:
pFileList	src/test_onefile.c	/^  fs_real_file *pFileList;$/;"	m	struct:fs_vfs_t	file:
pFirst	src/mem2.c	/^  struct MemBlockHdr *pFirst;$/;"	m	struct:__anon16	typeref:struct:__anon16::MemBlockHdr	file:
pFirst	src/pager.c	/^  PgHdr *pFirst;         \/* First page in LRU list *\/$/;"	m	struct:PagerLruList	file:
pFirst	src/vdbeInt.h	/^  FifoPage *pFirst;   \/* First page on the list *\/$/;"	m	struct:Fifo
pFirstSynced	src/pager.c	/^  PgHdr *pFirstSynced;   \/* First page in list with PgHdr.needSync==0 *\/$/;"	m	struct:PagerLruList	file:
pFrom	src/sqliteInt.h	/^  Table *pFrom;     \/* The table that constains the REFERENCES clause *\/$/;"	m	struct:FKey
pFts	ext/fts1/fts1.c	/^  fulltext_vtab *pFts;  \/* The full text index *\/$/;"	m	struct:Query	file:
pFts	ext/fts2/fts2.c	/^  fulltext_vtab *pFts;  \/* The full text index *\/$/;"	m	struct:Query	file:
pFts	ext/fts3/fts3.c	/^  fulltext_vtab *pFts;  \/* The full text index *\/$/;"	m	struct:Query	file:
pFulltextStatements	ext/fts1/fts1.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFulltextStatements	ext/fts2/fts2.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFulltextStatements	ext/fts3/fts3.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFunc	src/sqliteInt.h	/^    FuncDef *pFunc;          \/* The aggregate function implementation *\/$/;"	m	struct:AggInfo::AggInfo_func
pFunc	src/tclsqlite.c	/^  SqlFunc *pFunc;            \/* List of SQL functions *\/$/;"	m	struct:SqliteDb	file:
pFunc	src/vdbe.h	/^    FuncDef *pFunc;        \/* Used when p4type is P4_FUNCDEF *\/$/;"	m	union:VdbeOp::__anon23
pFunc	src/vdbeInt.h	/^  FuncDef *pFunc;               \/* The definition of the function *\/$/;"	m	struct:VdbeFunc
pFunc	src/vdbeInt.h	/^  FuncDef *pFunc;       \/* Pointer to function information.  MUST BE FIRST *\/$/;"	m	struct:sqlite3_context
pGroupBy	src/sqliteInt.h	/^  ExprList *pGroupBy;     \/* The group by clause *\/$/;"	m	struct:AggInfo
pGroupBy	src/sqliteInt.h	/^  ExprList *pGroupBy;    \/* The GROUP BY clause *\/$/;"	m	struct:Select
pHaving	src/sqliteInt.h	/^  Expr *pHaving;         \/* The HAVING clause *\/$/;"	m	struct:Select
pI64	src/vdbe.h	/^    i64 *pI64;             \/* Used when p4type is P4_INT64 *\/$/;"	m	union:VdbeOp::__anon23
pIdList	src/sqliteInt.h	/^  IdList *pIdList;     \/* Valid for INSERT statements only *\/$/;"	m	struct:TriggerStep
pIdx	src/sqliteInt.h	/^  Index *pIdx;          \/* Index used.  NULL if no index *\/$/;"	m	struct:WhereLevel
pIdxInfo	src/sqliteInt.h	/^  sqlite3_index_info *pIdxInfo;  \/* Index info for n-th source table *\/$/;"	m	struct:WhereLevel
pIncrKey	src/vdbeInt.h	/^  u8 *pIncrKey;         \/* Pointer to pKeyInfo->incrKey *\/$/;"	m	struct:Cursor
pIncrblob	src/tclsqlite.c	/^  IncrblobChannel *pIncrblob;\/* Linked list of open incrblob channels *\/$/;"	m	struct:SqliteDb	file:
pIndex	src/sqliteInt.h	/^  Index *pIndex;   \/* List of SQL indexes on this table. *\/$/;"	m	struct:Table
pInput	ext/fts1/fts1_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInput	ext/fts2/fts2_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInput	ext/fts3/fts3_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pIter	ext/fts2/fts2_icu.c	/^  UBreakIterator *pIter;      \/* ICU break-iterator object *\/$/;"	m	struct:IcuCursor	file:
pIter	ext/fts3/fts3_icu.c	/^  UBreakIterator *pIter;      \/* ICU break-iterator object *\/$/;"	m	struct:IcuCursor	file:
pKey	ext/fts1/fts1_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts1HashElem
pKey	ext/fts2/fts2_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts2HashElem
pKey	ext/fts3/fts3_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts3HashElem
pKey	src/btreeInt.h	/^  void *pKey;      \/* Saved key that was cursor's last known position *\/$/;"	m	struct:BtCursor
pKey	src/hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
pKeyInfo	src/vdbe.h	/^    KeyInfo *pKeyInfo;     \/* Used when p4type is P4_KEYINFO *\/$/;"	m	union:VdbeOp::__anon23
pKeyInfo	src/vdbeInt.h	/^  KeyInfo *pKeyInfo;    \/* Info about index keys needed by index cursors *\/$/;"	m	struct:Cursor
pLast	src/mem2.c	/^  struct MemBlockHdr *pLast;$/;"	m	struct:__anon16	typeref:struct:__anon16::MemBlockHdr	file:
pLast	src/pager.c	/^  PgHdr *pLast;          \/* Last page in LRU list (the most recently used) *\/$/;"	m	struct:PagerLruList	file:
pLast	src/sqliteInt.h	/^  TriggerStep *pLast;  \/* Last element in link-list. Valid for 1st elem only *\/$/;"	m	struct:TriggerStep
pLast	src/vdbeInt.h	/^  FifoPage *pLast;    \/* Last page on the list *\/$/;"	m	struct:Fifo
pLeafSelectStmts	ext/fts2/fts2.c	/^  sqlite3_stmt *pLeafSelectStmts[MERGE_COUNT];$/;"	m	struct:fulltext_vtab	file:
pLeafSelectStmts	ext/fts3/fts3.c	/^  sqlite3_stmt *pLeafSelectStmts[MERGE_COUNT];$/;"	m	struct:fulltext_vtab	file:
pLeft	src/sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pLimit	parse.c	/^  Expr *pLimit;    \/* The LIMIT expression.  NULL if there is no limit *\/$/;"	m	struct:LimitVal	file:
pLimit	src/sqliteInt.h	/^  Expr *pLimit;          \/* LIMIT expression. NULL means not used. *\/$/;"	m	struct:Select
pList	src/sqliteInt.h	/^  ExprList *pList;       \/* A list of expressions used as function arguments$/;"	m	struct:Expr
pList	src/test_async.c	/^  AsyncFileLock *pList;$/;"	m	struct:AsyncLock	file:
pList1	src/test_tclvar.c	/^  Tcl_Obj *pList1;     \/* Result of [info vars ?pattern?] *\/$/;"	m	struct:tclvar_cursor	file:
pList2	src/test_tclvar.c	/^  Tcl_Obj *pList2;     \/* Result of [array names [lindex $pList1 $i1]] *\/$/;"	m	struct:tclvar_cursor	file:
pLock	src/btreeInt.h	/^  BtLock *pLock;        \/* List of locks held on this shared-btree struct *\/$/;"	m	struct:BtShared
pLock	src/os_unix.c	/^  struct lockInfo *pLock;   \/* Info about locks on this inode *\/$/;"	m	struct:unixFile	typeref:struct:unixFile::lockInfo	file:
pMaskSet	src/where.c	/^  ExprMaskSet *pMaskSet;   \/* Mapping of table indices to bitmasks *\/$/;"	m	struct:WhereClause	file:
pMem	src/vdbe.h	/^    Mem *pMem;             \/* Used when p4type is P4_MEM *\/$/;"	m	union:VdbeOp::__anon23
pMem	src/vdbeInt.h	/^  Mem *pMem;            \/* Memory cell used to store aggregate context *\/$/;"	m	struct:sqlite3_context
pMethod	src/journal.c	/^  sqlite3_io_methods *pMethod;    \/* I\/O methods on journal files *\/$/;"	m	struct:JournalFile	file:
pMethod	src/os_os2.c	/^  const sqlite3_io_methods *pMethod;  \/* Always the first entry *\/$/;"	m	struct:os2File	file:
pMethod	src/os_unix.c	/^  sqlite3_io_methods const *pMethod;  \/* Always the first entry *\/$/;"	m	struct:unixFile	file:
pMethod	src/os_win.c	/^  const sqlite3_io_methods *pMethod;\/* Must be first *\/$/;"	m	struct:winFile	file:
pMethod	src/test6.c	/^  const sqlite3_io_methods *pMethod;   \/* Must be first *\/$/;"	m	struct:CrashFile	file:
pMethod	src/test_async.c	/^  sqlite3_io_methods *pMethod;$/;"	m	struct:AsyncFile	file:
pMethods	sqlite3.h	/^  const struct sqlite3_io_methods *pMethods;  \/* Methods for an open file *\/$/;"	m	struct:sqlite3_file	typeref:struct:sqlite3_file::sqlite3_io_methods
pMod	src/sqliteInt.h	/^  Module *pMod;             \/* Pointer to the implementation of the module *\/$/;"	m	struct:Table
pModule	ext/fts1/fts1_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	ext/fts2/fts2_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	ext/fts3/fts3_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	sqlite3.h	/^  const sqlite3_module *pModule;  \/* The module for this virtual table *\/$/;"	m	struct:sqlite3_vtab
pModule	src/sqliteInt.h	/^  const sqlite3_module *pModule;       \/* Callback pointers *\/$/;"	m	struct:Module
pModule	src/vdbeInt.h	/^  const sqlite3_module *pModule;     \/* Module for cursor pVtabCursor *\/$/;"	m	struct:Cursor
pNC	src/expr.c	/^  NameContext *pNC;    \/* Namespace of first enclosing query *\/$/;"	m	struct:QueryCoder	file:
pName	src/sqliteInt.h	/^  const Token *pName; \/* Name of the container - used for error messages *\/$/;"	m	struct:DbFixer
pNewTable	src/sqliteInt.h	/^  Table *pNewTable;    \/* A table being constructed by CREATE TABLE *\/$/;"	m	struct:Parse
pNewTrigger	src/sqliteInt.h	/^  Trigger *pNewTrigger;     \/* Trigger under construct by a CREATE TRIGGER *\/$/;"	m	struct:Parse
pNext	sqlite3.h	/^  sqlite3_vfs *pNext;      \/* Next registered VFS *\/$/;"	m	struct:sqlite3_vfs
pNext	src/btreeInt.h	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor
pNext	src/btreeInt.h	/^  BtLock *pNext;        \/* Next in BtShared.pLock list *\/$/;"	m	struct:BtLock
pNext	src/btreeInt.h	/^  BtShared *pNext;      \/* Next on a list of sharable BtShared structs *\/$/;"	m	struct:BtShared
pNext	src/btreeInt.h	/^  Btree *pNext;      \/* List of other sharable Btrees from the same db *\/$/;"	m	struct:Btree
pNext	src/mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::MemBlockHdr	file:
pNext	src/pager.c	/^  Pager *pNext;               \/* Doubly linked list of pagers on which *\/$/;"	m	struct:Pager	file:
pNext	src/pager.c	/^  PgHdr *pNext;$/;"	m	struct:PagerLruLink	file:
pNext	src/sqliteInt.h	/^  FuncDef *pNext;      \/* Next function with same name *\/$/;"	m	struct:FuncDef
pNext	src/sqliteInt.h	/^  Index *pNext;    \/* The next index associated with the same table *\/$/;"	m	struct:Index
pNext	src/sqliteInt.h	/^  NameContext *pNext;  \/* Next outer name context.  NULL for outermost *\/$/;"	m	struct:NameContext
pNext	src/sqliteInt.h	/^  Select *pNext;         \/* Next select to the left in a compound *\/$/;"	m	struct:Select
pNext	src/sqliteInt.h	/^  Trigger *pNext;         \/* Next trigger associated with the table *\/$/;"	m	struct:Trigger
pNext	src/sqliteInt.h	/^  TriggerStack *pNext; \/* Next trigger down on the trigger stack *\/$/;"	m	struct:TriggerStack
pNext	src/sqliteInt.h	/^  TriggerStep *pNext;  \/* Next in the link-list *\/$/;"	m	struct:TriggerStep
pNext	src/tclsqlite.c	/^  IncrblobChannel *pNext;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pNext	src/tclsqlite.c	/^  SqlCollate *pNext;    \/* Next function on the list of them all *\/$/;"	m	struct:SqlCollate	file:
pNext	src/tclsqlite.c	/^  SqlFunc *pNext;       \/* Next function on the list of them all *\/$/;"	m	struct:SqlFunc	file:
pNext	src/tclsqlite.c	/^  SqlPreparedStmt *pNext;  \/* Next in linked list *\/$/;"	m	struct:SqlPreparedStmt	file:
pNext	src/test6.c	/^  WriteBuffer *pNext;          \/* Next in CrashGlobal.pWriteList *\/$/;"	m	struct:WriteBuffer	file:
pNext	src/test_async.c	/^  AsyncFileLock *pNext;$/;"	m	struct:AsyncFileLock	file:
pNext	src/test_async.c	/^  AsyncWrite *pNext;  \/* Next write operation (to any file) *\/$/;"	m	struct:AsyncWrite	file:
pNext	src/test_onefile.c	/^  fs_real_file *pNext;$/;"	m	struct:fs_real_file	file:
pNext	src/test_server.c	/^  SqlMessage *pNext;           \/* Next message in the queue *\/$/;"	m	struct:SqlMessage	file:
pNext	src/vdbeInt.h	/^  FifoPage *pNext;   \/* Next page in the fifo *\/$/;"	m	struct:FifoPage
pNext	src/vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pNextAll	src/pager.c	/^  PgHdr *pNextAll;               \/* A list of all pages *\/$/;"	m	struct:PgHdr	file:
pNextFrom	src/sqliteInt.h	/^  FKey *pNextFrom;  \/* Next foreign key in pFrom *\/$/;"	m	struct:FKey
pNextHash	src/pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pNextStmt	src/pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHistory	file:
pNextTo	src/sqliteInt.h	/^  FKey *pNextTo;    \/* Next foreign key that points to zTo *\/$/;"	m	struct:FKey
pOffset	parse.c	/^  Expr *pOffset;   \/* The OFFSET expression.  NULL if there is none *\/$/;"	m	struct:LimitVal	file:
pOffset	src/sqliteInt.h	/^  Expr *pOffset;         \/* OFFSET expression. NULL means not used. *\/$/;"	m	struct:Select
pOn	src/sqliteInt.h	/^    Expr *pOn;        \/* The ON clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pOpen	src/os_unix.c	/^  struct openCnt *pOpen;    \/* Info about all open fd's on this inode *\/$/;"	m	struct:unixFile	typeref:struct:unixFile::openCnt	file:
pOrderBy	src/sqliteInt.h	/^  ExprList *pOrderBy;    \/* The ORDER BY clause *\/$/;"	m	struct:Select
pOrig	src/pager.c	/^  u8 *pOrig;     \/* Original page text.  Restore to this on a full rollback *\/$/;"	m	struct:PgHistory	file:
pOrig	src/test6.c	/^  sqlite3_vfs *pOrig;                   \/* Wrapped vfs structure *\/$/;"	m	struct:crashAppData	file:
pPage	src/btreeInt.h	/^  MemPage *pPage;           \/* Page that contains the entry *\/$/;"	m	struct:BtCursor
pPage1	src/btreeInt.h	/^  MemPage *pPage1;      \/* First page of the database *\/$/;"	m	struct:BtShared
pPager	src/btreeInt.h	/^  Pager *pPager;        \/* The page cache *\/$/;"	m	struct:BtShared
pPager	src/btreeInt.h	/^  Pager *pPager;    \/* The associated pager.  Also accessible by pBt->pPager *\/$/;"	m	struct:IntegrityCk
pPager	src/pager.c	/^  Pager *pPager;                 \/* The pager to which this page belongs *\/$/;"	m	struct:PgHdr	file:
pParent	src/btreeInt.h	/^  MemPage *pParent;    \/* The parent of this page.  NULL for root *\/$/;"	m	struct:MemPage
pParent	src/test_onefile.c	/^  sqlite3_vfs *pParent;$/;"	m	struct:fs_vfs_t	file:
pParse	src/expr.c	/^  Parse *pParse;       \/* The parsing context *\/$/;"	m	struct:QueryCoder	file:
pParse	src/sqliteInt.h	/^  Parse *pParse;              \/* The Parse structure *\/$/;"	m	struct:AuthContext
pParse	src/sqliteInt.h	/^  Parse *pParse;       \/* The parser *\/$/;"	m	struct:NameContext
pParse	src/sqliteInt.h	/^  Parse *pParse;      \/* The parsing context.  Error messages written here *\/$/;"	m	struct:DbFixer
pParse	src/sqliteInt.h	/^  Parse *pParse;$/;"	m	struct:WhereInfo
pParse	src/where.c	/^  Parse *pParse;           \/* The parser context *\/$/;"	m	struct:WhereClause	file:
pPrev	src/btreeInt.h	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor
pPrev	src/btreeInt.h	/^  Btree *pPrev;      \/* Back pointer of the same list *\/$/;"	m	struct:Btree
pPrev	src/mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::	file:
pPrev	src/pager.c	/^  Pager *pPrev;               \/* sqlite3_release_memory() will work *\/$/;"	m	struct:Pager	file:
pPrev	src/pager.c	/^  PgHdr *pPrev;$/;"	m	struct:PagerLruLink	file:
pPrev	src/tclsqlite.c	/^  IncrblobChannel *pPrev;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pPrev	src/tclsqlite.c	/^  SqlPreparedStmt *pPrev;  \/* Previous on the list *\/$/;"	m	struct:SqlPreparedStmt	file:
pPrev	src/test_server.c	/^  SqlMessage *pPrev;           \/* Previous message in the queue *\/$/;"	m	struct:SqlMessage	file:
pPrev	src/vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pPrevDirty	src/pager.c	/^  PgHdr *pDirty, *pPrevDirty;    \/* Dirty pages *\/$/;"	m	struct:PgHdr	file:
pPrevHash	src/pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pPrevStmt	src/pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHistory	file:
pPrior	src/sqliteInt.h	/^  Select *pPrior;        \/* Prior select in a compound select statement *\/$/;"	m	struct:Select
pProfileArg	src/sqliteInt.h	/^  void *pProfileArg;                        \/* Argument to profile function *\/$/;"	m	struct:sqlite3
pProgressArg	src/sqliteInt.h	/^  void *pProgressArg;           \/* Argument to the progress callback *\/$/;"	m	struct:sqlite3
pQueueFirst	src/test_async.c	/^  AsyncWrite *pQueueFirst;     \/* Next write operation to be processed *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueHead	src/test_server.c	/^  SqlMessage *pQueueHead;       \/* Head of the message queue *\/$/;"	m	struct:ServerState	file:
pQueueLast	src/test_async.c	/^  AsyncWrite *pQueueLast;      \/* Last write operation on the list *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueTail	src/test_server.c	/^  SqlMessage *pQueueTail;       \/* Tail of the message queue *\/$/;"	m	struct:ServerState	file:
pReader	ext/fts2/fts2.c	/^  DLReader *pReader;$/;"	m	struct:OrderedDLReader	file:
pReader	ext/fts3/fts3.c	/^  DLReader *pReader;$/;"	m	struct:OrderedDLReader	file:
pReal	src/journal.c	/^  sqlite3_file *pReal;            \/* The "real" underlying file descriptor *\/$/;"	m	struct:JournalFile	file:
pReal	src/test_devsym.c	/^  sqlite3_file *pReal;$/;"	m	struct:devsym_file	file:
pReal	src/test_onefile.c	/^  fs_real_file *pReal;$/;"	m	struct:fs_file	file:
pReal	src/vdbe.h	/^    double *pReal;         \/* Used when p4type is P4_REAL *\/$/;"	m	union:VdbeOp::__anon23
pRealFile	src/test6.c	/^  sqlite3_file *pRealFile;             \/* Underlying "real" file handle *\/$/;"	m	struct:CrashFile	file:
pResultSet	src/vdbeInt.h	/^  Mem *pResultSet;        \/* Pointer to an array of results *\/$/;"	m	struct:Vdbe
pRight	src/sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pRightmost	src/sqliteInt.h	/^  Select *pRightmost;    \/* Right-most select in a compound select statement *\/$/;"	m	struct:Select
pRollbackArg	src/sqliteInt.h	/^  void *pRollbackArg;               \/* Argument to xRollbackCallback() *\/   $/;"	m	struct:sqlite3
pRollbackHook	src/tclsqlite.c	/^  Tcl_Obj *pRollbackHook;    \/* Rollback hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pSchema	src/btreeInt.h	/^  void *pSchema;        \/* Pointer to space allocated by sqlite3BtreeSchema() *\/$/;"	m	struct:BtShared
pSchema	src/sqliteInt.h	/^  Schema *pSchema;          \/* Schema that contains this table *\/$/;"	m	struct:Table
pSchema	src/sqliteInt.h	/^  Schema *pSchema;        \/* Schema containing the trigger *\/$/;"	m	struct:Trigger
pSchema	src/sqliteInt.h	/^  Schema *pSchema;     \/* Pointer to database schema (possibly shared) *\/$/;"	m	struct:Db
pSchema	src/sqliteInt.h	/^  Schema *pSchema; \/* Schema containing this index *\/$/;"	m	struct:Index
pScript	src/tclsqlite.c	/^  Tcl_Obj *pScript;     \/* The Tcl_Obj representation of the script *\/$/;"	m	struct:SqlFunc	file:
pSelect	src/sqliteInt.h	/^    Select *pSelect;  \/* A SELECT statement used in place of a table name *\/$/;"	m	struct:SrcList::SrcList_item
pSelect	src/sqliteInt.h	/^  Select *pSelect;       \/* When the expression is a sub-select.  Also the$/;"	m	struct:Expr
pSelect	src/sqliteInt.h	/^  Select *pSelect;     \/* Valid for SELECT and sometimes $/;"	m	struct:TriggerStep
pSelect	src/sqliteInt.h	/^  Select *pSelect; \/* NULL for tables.  Points to definition if a view. *\/$/;"	m	struct:Table
pSeqTab	src/sqliteInt.h	/^  Table *pSeqTab;      \/* The sqlite_sequence table used by AUTOINCREMENT *\/$/;"	m	struct:Schema
pSrc	src/sqliteInt.h	/^  SrcList *pSrc;         \/* The FROM clause *\/$/;"	m	struct:Select
pSrcList	src/sqliteInt.h	/^  SrcList *pSrcList;   \/* One or more tables used to resolve names *\/$/;"	m	struct:NameContext
pStmt	ext/fts1/fts1.c	/^  sqlite3_stmt *pStmt;             \/* Prepared statement in use by the cursor *\/$/;"	m	struct:fulltext_cursor	file:
pStmt	ext/fts2/fts2.c	/^  sqlite3_stmt *pStmt;             \/* Prepared statement in use by the cursor *\/$/;"	m	struct:fulltext_cursor	file:
pStmt	ext/fts2/fts2.c	/^  sqlite3_stmt *pStmt;      \/* Statement we're streaming leaves from. *\/$/;"	m	struct:LeavesReader	file:
pStmt	ext/fts3/fts3.c	/^  sqlite3_stmt *pStmt;             \/* Prepared statement in use by the cursor *\/$/;"	m	struct:fulltext_cursor	file:
pStmt	ext/fts3/fts3.c	/^  sqlite3_stmt *pStmt;      \/* Statement we're streaming leaves from. *\/$/;"	m	struct:LeavesReader	file:
pStmt	src/pager.c	/^  PgHdr *pStmt;               \/* List of pages in the statement subjournal *\/$/;"	m	struct:Pager	file:
pStmt	src/pager.c	/^  u8 *pStmt;     \/* Text as it was at the beginning of the current statement *\/$/;"	m	struct:PgHistory	file:
pStmt	src/tclsqlite.c	/^  sqlite3_stmt *pStmt;     \/* The prepared statement *\/$/;"	m	struct:SqlPreparedStmt	file:
pStmt	src/test4.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	src/test7.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	src/test8.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:echo_cursor	file:
pStmt	src/test_server.c	/^  sqlite3_stmt *pStmt;         \/* A specific statement *\/$/;"	m	struct:SqlMessage	file:
pStmt	src/vdbeblob.c	/^  sqlite3_stmt *pStmt;    \/* Statement holding cursor open *\/$/;"	m	struct:Incrblob	file:
pTab	src/sqliteInt.h	/^    Table *pTab;             \/* Source table *\/$/;"	m	struct:AggInfo::AggInfo_col
pTab	src/sqliteInt.h	/^    Table *pTab;      \/* An SQL table corresponding to zName *\/$/;"	m	struct:SrcList::SrcList_item
pTab	src/sqliteInt.h	/^  Table *pTab;           \/* Table for OP_Column expressions. *\/$/;"	m	struct:Expr
pTab	src/sqliteInt.h	/^  Table *pTab;         \/* Table that triggers are currently being coded on *\/$/;"	m	struct:TriggerStack
pTabList	src/sqliteInt.h	/^  SrcList *pTabList;   \/* List of tables in the join *\/$/;"	m	struct:WhereInfo
pTabSchema	src/sqliteInt.h	/^  Schema *pTabSchema;     \/* Schema containing the table *\/$/;"	m	struct:Trigger
pTable	src/sqliteInt.h	/^  Table *pTable;   \/* The SQL table being indexed *\/$/;"	m	struct:Index
pTableList	src/test_schema.c	/^  sqlite3_stmt *pTableList;$/;"	m	struct:schema_cursor	file:
pTerm	ext/fts1/fts1.c	/^  char *pTerm;       \/* text of the term.  '\\000' terminated.  malloced *\/$/;"	m	struct:QueryTerm	file:
pTerm	ext/fts2/fts2.c	/^  char *pTerm;       \/* text of the term.  '\\000' terminated.  malloced *\/$/;"	m	struct:QueryTerm	file:
pTerm	ext/fts2/fts2.c	/^  const char *pTerm;$/;"	m	struct:TermData	file:
pTerm	ext/fts3/fts3.c	/^  char *pTerm;       \/* text of the term.  '\\000' terminated.  malloced *\/$/;"	m	struct:QueryTerm	file:
pTerm	ext/fts3/fts3.c	/^  const char *pTerm;$/;"	m	struct:TermData	file:
pTerms	ext/fts1/fts1.c	/^  QueryTerm *pTerms;    \/* Array of terms.  Space obtained from malloc() *\/$/;"	m	struct:Query	file:
pTerms	ext/fts2/fts2.c	/^  QueryTerm *pTerms;    \/* Array of terms.  Space obtained from malloc() *\/$/;"	m	struct:Query	file:
pTerms	ext/fts3/fts3.c	/^  QueryTerm *pTerms;    \/* Array of terms.  Space obtained from malloc() *\/$/;"	m	struct:Query	file:
pTestCollateInterp	src/test1.c	/^static Tcl_Interp* pTestCollateInterp;$/;"	v	file:
pTmpSpace	src/pager.c	/^  char *pTmpSpace;            \/* Pager.pageSize bytes of space for tmp use *\/$/;"	m	struct:Pager	file:
pToken	ext/fts1/fts1_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pToken	ext/fts2/fts2_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pToken	ext/fts3/fts3_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pTokenizer	ext/fts1/fts1.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	ext/fts1/fts1_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	ext/fts2/fts2.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	ext/fts2/fts2_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	ext/fts3/fts3.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	ext/fts3/fts3_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTraceArg	src/sqliteInt.h	/^  void *pTraceArg;                          \/* Argument to the trace function *\/$/;"	m	struct:sqlite3
pTrig	src/sqliteInt.h	/^  Trigger *pTrig;      \/* The trigger that this step is a part of *\/$/;"	m	struct:TriggerStep
pTrigger	src/sqliteInt.h	/^  Trigger *pTrigger;   \/* The trigger currently being coded *\/$/;"	m	struct:TriggerStack
pTrigger	src/sqliteInt.h	/^  Trigger *pTrigger; \/* List of SQL triggers on this table *\/$/;"	m	struct:Table
pUpdateArg	src/sqliteInt.h	/^  void *pUpdateArg;$/;"	m	struct:sqlite3
pUpdateHook	src/tclsqlite.c	/^  Tcl_Obj *pUpdateHook;      \/* Update hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pUser	src/sqliteInt.h	/^  void *pUser;          \/* First argument to xCmp() *\/$/;"	m	struct:CollSeq
pUserData	src/sqliteInt.h	/^  void *pUserData;     \/* User data parameter *\/$/;"	m	struct:FuncDef
pUsing	src/sqliteInt.h	/^    IdList *pUsing;   \/* The USING clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pVTab	src/sqliteInt.h	/^  Table *pVTab;                 \/* vtab with active Connect\/Create method *\/$/;"	m	struct:sqlite3
pVdbe	src/sqliteInt.h	/^  Vdbe *pVdbe;         \/* An engine for executing database bytecode *\/$/;"	m	struct:Parse
pVdbe	src/sqliteInt.h	/^  struct Vdbe *pVdbe;           \/* List of active virtual machines *\/$/;"	m	struct:sqlite3	typeref:struct:sqlite3::Vdbe
pVdbeFunc	src/vdbe.h	/^    VdbeFunc *pVdbeFunc;   \/* Used when p4type is P4_VDBEFUNC *\/$/;"	m	union:VdbeOp::__anon23
pVdbeFunc	src/vdbeInt.h	/^  VdbeFunc *pVdbeFunc;  \/* Auxilary data, if created. *\/$/;"	m	struct:sqlite3_context
pVfs	src/journal.c	/^  sqlite3_vfs *pVfs;              \/* The "real" underlying VFS *\/$/;"	m	struct:JournalFile	file:
pVfs	src/pager.c	/^  sqlite3_vfs *pVfs;          \/* OS functions to use for IO *\/$/;"	m	struct:Pager	file:
pVfs	src/sqliteInt.h	/^  sqlite3_vfs *pVfs;            \/* OS Interface *\/$/;"	m	struct:sqlite3
pVfs	src/test_devsym.c	/^  sqlite3_vfs *pVfs;$/;"	m	struct:DevsymGlobal	file:
pVirtualLock	src/sqliteInt.h	/^  Table *pVirtualLock;       \/* Require virtual table lock on this table *\/$/;"	m	struct:Parse
pVtab	sqlite3.h	/^  sqlite3_vtab *pVtab;      \/* Virtual table of this cursor *\/$/;"	m	struct:sqlite3_vtab_cursor
pVtab	src/sqliteInt.h	/^  sqlite3_vtab *pVtab;      \/* Pointer to the module instance *\/$/;"	m	struct:Table
pVtab	src/vdbe.h	/^    sqlite3_vtab *pVtab;   \/* Used when p4type is P4_VTAB *\/$/;"	m	union:VdbeOp::__anon23
pVtabCursor	src/vdbeInt.h	/^  sqlite3_vtab_cursor *pVtabCursor;  \/* The cursor for a virtual table *\/$/;"	m	struct:Cursor
pWC	src/where.c	/^  WhereClause *pWC;       \/* The clause this term is part of *\/$/;"	m	struct:WhereTerm	file:
pWhen	src/sqliteInt.h	/^  Expr *pWhen;            \/* The WHEN clause of the expresion (may be NULL) *\/$/;"	m	struct:Trigger
pWhere	src/sqliteInt.h	/^  Expr *pWhere;          \/* The WHERE clause *\/$/;"	m	struct:Select
pWhere	src/sqliteInt.h	/^  Expr *pWhere;        \/* Valid for DELETE, UPDATE steps *\/$/;"	m	struct:TriggerStep
pWriteList	src/test6.c	/^  WriteBuffer *pWriteList;     \/* Head of write-list *\/$/;"	m	struct:CrashGlobal	file:
pWriteListEnd	src/test6.c	/^  WriteBuffer *pWriteListEnd;  \/* End of write-list *\/$/;"	m	struct:CrashGlobal	file:
pageDestructor	src/btree.c	/^static void pageDestructor(DbPage *pData, int pageSize){$/;"	f	file:
pageHash	src/pager.c	/^  u32 pageHash;$/;"	m	struct:PgHdr	file:
pageInStatement	src/pager.c	/^static int pageInStatement(PgHdr *pPg){$/;"	f	file:
pageReinit	src/btree.c	/^static void pageReinit(DbPage *pData, int pageSize){$/;"	f	file:
pageSize	src/btreeInt.h	/^  u16 pageSize;         \/* Total number of bytes on a page *\/$/;"	m	struct:BtShared
pageSize	src/pager.c	/^  int pageSize;               \/* Number of bytes in a page *\/$/;"	m	struct:Pager	file:
pageSizeFixed	src/btreeInt.h	/^  u8 pageSizeFixed;     \/* True if the page size can no longer be changed *\/$/;"	m	struct:BtShared
page_add_to_stmt_list	src/pager.c	/^static void page_add_to_stmt_list(PgHdr *pPg){$/;"	f	file:
page_get	src/test2.c	/^static int page_get($/;"	f	file:
page_info	tool/fragck.tcl	/^proc page_info {csr up} {$/;"	p
page_lookup	src/test2.c	/^static int page_lookup($/;"	f	file:
page_number	src/test2.c	/^static int page_number($/;"	f	file:
page_read	src/test2.c	/^static int page_read($/;"	f	file:
page_ref	src/pager.c	/^  static void page_ref(PgHdr *pPg){$/;"	f	file:
page_ref	src/pager.c	2735;"	d	file:
page_unref	src/test2.c	/^static int page_unref($/;"	f	file:
page_write	src/test2.c	/^static int page_write($/;"	f	file:
pager3_refinfo_enable	src/pager.c	/^  int pager3_refinfo_enable = 0;$/;"	v
pager3_refinfo_enable	src/pager.h	/^  int pager3_refinfo_enable;$/;"	v
pagerAcquire	src/pager.c	/^static int pagerAcquire($/;"	f	file:
pagerAllocatePage	src/pager.c	/^static int pagerAllocatePage(Pager *pPager, PgHdr **ppPg){$/;"	f	file:
pagerEnter	src/pager.c	/^  static void pagerEnter(Pager *p){$/;"	f	file:
pagerEnter	src/pager.c	531;"	d	file:
pagerLeave	src/pager.c	/^  static void pagerLeave(Pager *p){$/;"	f	file:
pagerLeave	src/pager.c	532;"	d	file:
pagerSharedLock	src/pager.c	/^static int pagerSharedLock(Pager *pPager){$/;"	f	file:
pagerStmtBegin	src/pager.c	/^static int pagerStmtBegin(Pager *pPager){$/;"	f	file:
pagerUnlockAndRollback	src/pager.c	/^static void pagerUnlockAndRollback(Pager *p){$/;"	f	file:
pager_cksum	src/pager.c	/^static u32 pager_cksum(Pager *pPager, const u8 *aData){$/;"	f	file:
pager_close	src/test2.c	/^static int pager_close($/;"	f	file:
pager_commit	src/test2.c	/^static int pager_commit($/;"	f	file:
pager_datahash	src/pager.c	/^static u32 pager_datahash(int nByte, unsigned char *pData){$/;"	f	file:
pager_datahash	src/pager.c	883;"	d	file:
pager_delmaster	src/pager.c	/^static int pager_delmaster(Pager *pPager, const char *zMaster){$/;"	f	file:
pager_end_transaction	src/pager.c	/^static int pager_end_transaction(Pager *pPager){$/;"	f	file:
pager_error	src/pager.c	/^static int pager_error(Pager *pPager, int rc){$/;"	f	file:
pager_get_all_dirty_pages	src/pager.c	/^static PgHdr *pager_get_all_dirty_pages(Pager *pPager){$/;"	f	file:
pager_get_content	src/pager.c	/^static int pager_get_content(PgHdr *pPg){$/;"	f	file:
pager_incr_changecounter	src/pager.c	/^static int pager_incr_changecounter(Pager *pPager, int isDirect){$/;"	f	file:
pager_lookup	src/pager.c	/^static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){$/;"	f	file:
pager_open	src/test2.c	/^static int pager_open($/;"	f	file:
pager_open_journal	src/pager.c	/^static int pager_open_journal(Pager *pPager){$/;"	f	file:
pager_pagecount	src/test2.c	/^static int pager_pagecount($/;"	f	file:
pager_pagehash	src/pager.c	/^static u32 pager_pagehash(PgHdr *pPage){$/;"	f	file:
pager_pagehash	src/pager.c	884;"	d	file:
pager_playback	src/pager.c	/^static int pager_playback(Pager *pPager, int isHot){$/;"	f	file:
pager_playback_one_page	src/pager.c	/^static int pager_playback_one_page($/;"	f	file:
pager_recycle	src/pager.c	/^static int pager_recycle(Pager *pPager, PgHdr **ppPg){$/;"	f	file:
pager_refinfo	src/pager.c	/^  static void pager_refinfo(PgHdr *p){$/;"	f	file:
pager_reset	src/pager.c	/^static void pager_reset(Pager *pPager){$/;"	f	file:
pager_resize_hash_table	src/pager.c	/^static void pager_resize_hash_table(Pager *pPager, int N){$/;"	f	file:
pager_rollback	src/test2.c	/^static int pager_rollback($/;"	f	file:
pager_stats	src/test2.c	/^static int pager_stats($/;"	f	file:
pager_stmt_begin	src/test2.c	/^static int pager_stmt_begin($/;"	f	file:
pager_stmt_commit	src/test2.c	/^static int pager_stmt_commit($/;"	f	file:
pager_stmt_playback	src/pager.c	/^static int pager_stmt_playback(Pager *pPager){$/;"	f	file:
pager_stmt_rollback	src/test2.c	/^static int pager_stmt_rollback($/;"	f	file:
pager_truncate	src/pager.c	/^static int pager_truncate(Pager *pPager, int nPage){$/;"	f	file:
pager_truncate	src/test2.c	/^static int pager_truncate($/;"	f	file:
pager_truncate_cache	src/pager.c	/^static void pager_truncate_cache(Pager *pPager){$/;"	f	file:
pager_unlock	src/pager.c	/^static void pager_unlock(Pager *pPager){$/;"	f	file:
pager_wait_on_lock	src/pager.c	/^static int pager_wait_on_lock(Pager *pPager, int locktype){$/;"	f	file:
pager_write	src/pager.c	/^static int pager_write(PgHdr *pPg){$/;"	f	file:
pager_write_pagelist	src/pager.c	/^static int pager_write_pagelist(PgHdr *pList){$/;"	f	file:
pagesize	tool/showdb.c	/^static int pagesize = 1024;$/;"	v	file:
pagesize	tool/showjournal.c	/^static int pagesize = 1024;$/;"	v	file:
parent	src/test_thread.c	/^  Tcl_ThreadId parent;     \/* Thread id of parent thread *\/$/;"	m	struct:SqlThread	file:
parentWriter	ext/fts2/fts2.c	/^  InteriorWriter parentWriter;    \/* if we overflow *\/$/;"	m	struct:LeafWriter	file:
parentWriter	ext/fts2/fts2.c	/^  struct InteriorWriter *parentWriter;$/;"	m	struct:InteriorWriter	typeref:struct:InteriorWriter::InteriorWriter	file:
parentWriter	ext/fts3/fts3.c	/^  InteriorWriter parentWriter;    \/* if we overflow *\/$/;"	m	struct:LeafWriter	file:
parentWriter	ext/fts3/fts3.c	/^  struct InteriorWriter *parentWriter;$/;"	m	struct:InteriorWriter	typeref:struct:InteriorWriter::InteriorWriter	file:
parseCell	src/btree.c	608;"	d	file:
parseDateOrTime	src/date.c	/^static int parseDateOrTime($/;"	f	file:
parseError	src/sqliteInt.h	/^  u8 parseError;       \/* True after a parsing error.  Ticket #1794 *\/$/;"	m	struct:Parse
parseHhMmSs	src/date.c	/^static int parseHhMmSs(const char *zDate, DateTime *p){$/;"	f	file:
parseModifier	src/date.c	/^static int parseModifier(const char *zMod, DateTime *p){$/;"	f	file:
parseQuery	ext/fts1/fts1.c	/^static int parseQuery($/;"	f	file:
parseQuery	ext/fts2/fts2.c	/^static int parseQuery($/;"	f	file:
parseQuery	ext/fts3/fts3.c	/^static int parseQuery($/;"	f	file:
parseSpec	ext/fts1/fts1.c	/^static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv,$/;"	f	file:
parseSpec	ext/fts2/fts2.c	/^static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv,$/;"	f	file:
parseSpec	ext/fts3/fts3.c	/^static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv,$/;"	f	file:
parseTimezone	src/date.c	/^static int parseTimezone(const char *zDate, DateTime *p){$/;"	f	file:
parseYyyyMmDd	src/date.c	/^static int parseYyyyMmDd(const char *zDate, DateTime *p){$/;"	f	file:
parse_client_id	src/test7.c	/^static int parse_client_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
parse_thread_id	src/test4.c	/^static int parse_thread_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
parseonetoken	tool/lemon.c	/^static void parseonetoken(psp)$/;"	f	file:
pathToDel	src/os_os2.c	/^  char* pathToDel;          \/* Name of file to delete on close *\/$/;"	m	struct:os2File	file:
pathsearch	tool/lemon.c	/^PRIVATE char *pathsearch(argv0,name,modemask)$/;"	f
patternCompare	src/func.c	/^static int patternCompare($/;"	f	file:
payloadSize	src/vdbeInt.h	/^  int payloadSize;      \/* Total number of bytes in the record *\/$/;"	m	struct:Cursor
pc	src/vdbeInt.h	/^  int pc;                 \/* The program counter *\/$/;"	m	struct:Vdbe
peekDocid	ext/fts1/fts1.c	/^static sqlite_int64 peekDocid(DocListReader *pReader){$/;"	f	file:
pendingTerms	ext/fts2/fts2.c	/^  fts2Hash pendingTerms;$/;"	m	struct:fulltext_vtab	file:
pendingTerms	ext/fts3/fts3.c	/^  fts3Hash pendingTerms;$/;"	m	struct:fulltext_vtab	file:
perLine	tool/showdb.c	/^static int perLine = 32;$/;"	v	file:
percent	tool/spaceanal.tcl	/^proc percent {num denom {of {}}} {$/;"	p
pgno	src/btreeInt.h	/^  Pgno pgno;           \/* Page number for this page *\/$/;"	m	struct:MemPage
pgno	src/pager.c	/^  Pgno pgno;                     \/* The page number for this page *\/$/;"	m	struct:PgHdr	file:
pgnoRoot	src/btreeInt.h	/^  Pgno pgnoRoot;            \/* The root page of this tree *\/$/;"	m	struct:BtCursor
plink	tool/lemon.c	/^struct plink {$/;"	s	file:
plink_freelist	tool/lemon.c	/^static struct plink *plink_freelist = 0;$/;"	v	typeref:struct:plink	file:
plrAtEnd	ext/fts2/fts2.c	/^static int plrAtEnd(PLReader *pReader){$/;"	f	file:
plrAtEnd	ext/fts3/fts3.c	/^static int plrAtEnd(PLReader *pReader){$/;"	f	file:
plrColumn	ext/fts2/fts2.c	/^static int plrColumn(PLReader *pReader){$/;"	f	file:
plrColumn	ext/fts3/fts3.c	/^static int plrColumn(PLReader *pReader){$/;"	f	file:
plrCompare	ext/fts3/fts3.c	/^static int plrCompare(PLReader *pLeft, PLReader *pRight){$/;"	f	file:
plrDestroy	ext/fts2/fts2.c	/^static void plrDestroy(PLReader *pReader){$/;"	f	file:
plrDestroy	ext/fts3/fts3.c	/^static void plrDestroy(PLReader *pReader){$/;"	f	file:
plrEndOffset	ext/fts2/fts2.c	/^static int plrEndOffset(PLReader *pReader){$/;"	f	file:
plrEndOffset	ext/fts3/fts3.c	/^static int plrEndOffset(PLReader *pReader){$/;"	f	file:
plrInit	ext/fts2/fts2.c	/^static void plrInit(PLReader *pReader, DLReader *pDLReader){$/;"	f	file:
plrInit	ext/fts3/fts3.c	/^static void plrInit(PLReader *pReader, DLReader *pDLReader){$/;"	f	file:
plrPosition	ext/fts2/fts2.c	/^static int plrPosition(PLReader *pReader){$/;"	f	file:
plrPosition	ext/fts3/fts3.c	/^static int plrPosition(PLReader *pReader){$/;"	f	file:
plrStartOffset	ext/fts2/fts2.c	/^static int plrStartOffset(PLReader *pReader){$/;"	f	file:
plrStartOffset	ext/fts3/fts3.c	/^static int plrStartOffset(PLReader *pReader){$/;"	f	file:
plrStep	ext/fts2/fts2.c	/^static void plrStep(PLReader *pReader){$/;"	f	file:
plrStep	ext/fts3/fts3.c	/^static void plrStep(PLReader *pReader){$/;"	f	file:
plus_opt	parse.y	/^plus_opt ::= .$/;"	l
plus_opt	parse.y	/^plus_opt ::= PLUS.$/;"	l
plus_opt	src/parse.y	/^plus_opt ::= .$/;"	l
plus_opt	src/parse.y	/^plus_opt ::= PLUS.$/;"	l
plw	ext/fts2/fts2.c	/^  PLWriter plw;$/;"	m	struct:DLCollector	file:
plw	ext/fts3/fts3.c	/^  PLWriter plw;$/;"	m	struct:DLCollector	file:
plwAdd	ext/fts2/fts2.c	/^static void plwAdd(PLWriter *pWriter, int iColumn, int iPos,$/;"	f	file:
plwAdd	ext/fts3/fts3.c	/^static void plwAdd(PLWriter *pWriter, int iColumn, int iPos,$/;"	f	file:
plwCopy	ext/fts2/fts2.c	/^static void plwCopy(PLWriter *pWriter, PLReader *pReader){$/;"	f	file:
plwCopy	ext/fts3/fts3.c	/^static void plwCopy(PLWriter *pWriter, PLReader *pReader){$/;"	f	file:
plwDestroy	ext/fts2/fts2.c	/^static void plwDestroy(PLWriter *pWriter){$/;"	f	file:
plwDestroy	ext/fts3/fts3.c	/^static void plwDestroy(PLWriter *pWriter){$/;"	f	file:
plwInit	ext/fts2/fts2.c	/^static void plwInit(PLWriter *pWriter, DLWriter *dlw, sqlite_int64 iDocid){$/;"	f	file:
plwInit	ext/fts3/fts3.c	/^static void plwInit(PLWriter *pWriter, DLWriter *dlw, sqlite_int64 iDocid){$/;"	f	file:
plwTerminate	ext/fts2/fts2.c	/^static void plwTerminate(PLWriter *pWriter){$/;"	f	file:
plwTerminate	ext/fts3/fts3.c	/^static void plwTerminate(PLWriter *pWriter){$/;"	f	file:
pointerToText	src/test_malloc.c	/^static void pointerToText(void *p, char *z){$/;"	f	file:
porterClose	ext/fts1/fts1_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterClose	ext/fts2/fts2_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterClose	ext/fts3/fts3_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterCreate	ext/fts1/fts1_porter.c	/^static int porterCreate($/;"	f	file:
porterCreate	ext/fts2/fts2_porter.c	/^static int porterCreate($/;"	f	file:
porterCreate	ext/fts3/fts3_porter.c	/^static int porterCreate($/;"	f	file:
porterDestroy	ext/fts1/fts1_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterDestroy	ext/fts2/fts2_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterDestroy	ext/fts3/fts3_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterIdChar	ext/fts2/fts2_porter.c	/^static const char porterIdChar[] = {$/;"	v	file:
porterIdChar	ext/fts3/fts3_porter.c	/^static const char porterIdChar[] = {$/;"	v	file:
porterNext	ext/fts1/fts1_porter.c	/^static int porterNext($/;"	f	file:
porterNext	ext/fts2/fts2_porter.c	/^static int porterNext($/;"	f	file:
porterNext	ext/fts3/fts3_porter.c	/^static int porterNext($/;"	f	file:
porterOpen	ext/fts1/fts1_porter.c	/^static int porterOpen($/;"	f	file:
porterOpen	ext/fts2/fts2_porter.c	/^static int porterOpen($/;"	f	file:
porterOpen	ext/fts3/fts3_porter.c	/^static int porterOpen($/;"	f	file:
porterTokenizerModule	ext/fts1/fts1_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porterTokenizerModule	ext/fts1/fts1_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule;$/;"	v	file:
porterTokenizerModule	ext/fts2/fts2_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porterTokenizerModule	ext/fts2/fts2_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule;$/;"	v	file:
porterTokenizerModule	ext/fts3/fts3_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porterTokenizerModule	ext/fts3/fts3_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule;$/;"	v	file:
porter_stemmer	ext/fts1/fts1_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_stemmer	ext/fts2/fts2_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_stemmer	ext/fts3/fts3_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_tokenizer	ext/fts1/fts1_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	ext/fts1/fts1_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer	ext/fts2/fts2_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	ext/fts2/fts2_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer	ext/fts3/fts3_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	ext/fts3/fts3_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer_cursor	ext/fts1/fts1_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	ext/fts1/fts1_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
porter_tokenizer_cursor	ext/fts2/fts2_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	ext/fts2/fts2_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
porter_tokenizer_cursor	ext/fts3/fts3_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	ext/fts3/fts3_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
posListCmp	ext/fts2/fts2.c	/^static int posListCmp(PLReader *pLeft, PLReader *pRight){$/;"	f	file:
posListCmp	ext/fts3/fts3.c	/^static int posListCmp(PLReader *pLeft, PLReader *pRight){$/;"	f	file:
posListPhraseMerge	ext/fts2/fts2.c	/^static void posListPhraseMerge(DLReader *pLeft, DLReader *pRight,$/;"	f	file:
posListPhraseMerge	ext/fts3/fts3.c	/^static void posListPhraseMerge($/;"	f	file:
posListUnion	ext/fts2/fts2.c	/^static void posListUnion(DLReader *pLeft, DLReader *pRight, DLWriter *pOut){$/;"	f	file:
posListUnion	ext/fts3/fts3.c	/^static void posListUnion(DLReader *pLeft, DLReader *pRight, DLWriter *pOut){$/;"	f	file:
posixLockingStyle	src/os_unix.c	/^        posixLockingStyle = 0,       \/* standard posix-advisory locks *\/$/;"	e	enum:__anon15	file:
postToParent	src/test_thread.c	/^static void postToParent(SqlThread *p, Tcl_Obj *pScript){$/;"	f	file:
ppThis	src/test_onefile.c	/^  fs_real_file **ppThis;$/;"	m	struct:fs_real_file	file:
prec	tool/lemon.c	/^  int prec;                \/* Precedence if defined (-1 otherwise) *\/$/;"	m	struct:symbol	file:
preccounter	tool/lemon.c	/^  int preccounter;           \/* Assign this precedence to decl arguments *\/$/;"	m	struct:pstate	file:
precsym	tool/lemon.c	/^  struct symbol *precsym;  \/* Precedence symbol for this rule *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
prefix	src/printf.c	/^  etByte prefix;           \/* Offset into aPrefix[] of the prefix string *\/$/;"	m	struct:et_info	file:
prefix	tool/mkkeywordhash.c	/^  int prefix;          \/* Number of characters in prefix *\/$/;"	m	struct:Keyword	file:
prefixIsEqual	src/sqliteInt.h	/^  u8 prefixIsEqual;   \/* Treat a prefix as equal *\/$/;"	m	struct:KeyInfo
prepSelectStmt	src/select.c	/^static int prepSelectStmt(Parse *pParse, Select *p){$/;"	f	file:
prepStack	src/test1.c	/^static void prepStack(void){$/;"	f	file:
prepare	src/sqlite3ext.h	/^  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
prepare16	src/sqlite3ext.h	/^  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepare16_v2	src/sqlite3ext.h	/^  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepare_v2	src/sqlite3ext.h	/^  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
preprocess_input	tool/lemon.c	/^static void preprocess_input(char *z){$/;"	f	file:
prereqAll	src/where.c	/^  Bitmask prereqAll;      \/* Bitmask of tables referenced by p *\/$/;"	m	struct:WhereTerm	file:
prereqRight	src/where.c	/^  Bitmask prereqRight;    \/* Bitmask of tables used by pRight *\/$/;"	m	struct:WhereTerm	file:
prev	ext/fts1/fts1_hash.h	/^  fts1HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts1HashElem
prev	ext/fts2/fts2_hash.h	/^  fts2HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts2HashElem
prev	ext/fts3/fts3_hash.h	/^  fts3HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts3HashElem
prev	src/hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
prev	src/mem3.c	/^      u32 prev;       \/* Index in mem.aPool[] of previous free chunk *\/$/;"	m	struct:Mem3Block::__anon19::__anon21	file:
prev	src/vdbeInt.h	/^  HashElem *prev;        \/* Previously accessed hash elemen *\/$/;"	m	struct:Set
prevSize	src/mem3.c	/^      u32 prevSize;   \/* Size of previous chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon19::__anon20	file:
previous_mode_data	src/shell.c	/^struct previous_mode_data {$/;"	s	file:
prevrule	tool/lemon.c	/^  struct rule *prevrule;     \/* Previous rule parsed *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
printDoclist	ext/fts1/fts1.c	/^static void printDoclist(DocList *p){$/;"	f	file:
print_page	tool/showdb.c	/^static print_page(int iPg){$/;"	f	file:
print_page	tool/showjournal.c	/^static print_page(int iPg){$/;"	f	file:
print_stack_union	tool/lemon.c	/^void print_stack_union(out,lemp,plineno,mhflag)$/;"	f
printstack	tool/memleak3.tcl	/^proc printstack {stack} {$/;"	p
priorNewRowid	src/sqliteInt.h	/^  i64 priorNewRowid;            \/* Last randomly generated ROWID *\/$/;"	m	struct:sqlite3
processCompoundOrderBy	src/select.c	/^static int processCompoundOrderBy($/;"	f	file:
processDevSymArgs	src/test6.c	/^static int processDevSymArgs($/;"	f	file:
processOrderGroupBy	src/select.c	/^static int processOrderGroupBy($/;"	f	file:
process_input	src/shell.c	/^static int process_input(struct callback_data *p, FILE *in){$/;"	f	file:
process_input	tool/memleak3.tcl	/^proc process_input {input_file array_name} {$/;"	p
process_options	tool/omittest.tcl	/^proc process_options {argv} {$/;"	p
process_sqliterc	src/shell.c	/^static void process_sqliterc($/;"	f	file:
profile	src/sqlite3ext.h	/^  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);$/;"	m	struct:sqlite3_api_routines
progress_handler	src/sqlite3ext.h	/^  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
pseudoTable	src/vdbeInt.h	/^  Bool pseudoTable;     \/* This is a NEW or OLD pseudo-tables of a trigger *\/$/;"	m	struct:Cursor
pstate	tool/lemon.c	/^struct pstate {$/;"	s	file:
pthread_cond_wait	src/test_async.c	570;"	d	file:
pthread_create	configure	/^pthread_create ();$/;"	f
pthread_mutex_lock	src/test_async.c	567;"	d	file:
pthread_mutex_trylock	src/test_async.c	569;"	d	file:
pthread_mutex_unlock	src/test_async.c	568;"	d	file:
ptrChngFunction	src/test1.c	/^static void ptrChngFunction($/;"	f	file:
ptrmapGet	src/btree.c	/^static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){$/;"	f	file:
ptrmapPageno	src/btree.c	/^static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){$/;"	f	file:
ptrmapPut	src/btree.c	/^static int ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent){$/;"	f	file:
ptrmapPutOvfl	src/btree.c	/^static int ptrmapPutOvfl(MemPage *pPage, int iCell){$/;"	f	file:
ptrmapPutOvflPtr	src/btree.c	/^static int ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
pushOntoSorter	src/select.c	/^static void pushOntoSorter($/;"	f	file:
put2byte	src/btreeInt.h	632;"	d
put32bits	src/pager.c	748;"	d	file:
put4byte	src/btreeInt.h	634;"	d
putVarint	ext/fts1/fts1.c	/^static int putVarint(char *p, sqlite_int64 v){$/;"	f	file:
putVarint	ext/fts2/fts2.c	/^static int putVarint(char *p, sqlite_int64 v){$/;"	f	file:
putVarint	src/btreeInt.h	502;"	d
put_item	tool/mkopts.tcl	/^proc put_item x {$/;"	p
pzErrMsg	src/sqliteInt.h	/^  char **pzErrMsg;    \/* Error message stored here *\/$/;"	m	struct:__anon14
pzNeededCollation	src/test1.c	/^static char *pzNeededCollation = zNeededCollation;$/;"	v	file:
q	ext/fts1/fts1.c	/^  Query q;                         \/* Parsed query string *\/$/;"	m	struct:fulltext_cursor	file:
q	ext/fts2/fts2.c	/^  Query q;                         \/* Parsed query string *\/$/;"	m	struct:fulltext_cursor	file:
q	ext/fts3/fts3.c	/^  Query q;                         \/* Parsed query string *\/$/;"	m	struct:fulltext_cursor	file:
queryAdd	ext/fts1/fts1.c	/^static void queryAdd(Query *q, const char *pTerm, int nTerm){$/;"	f	file:
queryAdd	ext/fts2/fts2.c	/^static void queryAdd(Query *q, const char *pTerm, int nTerm){$/;"	f	file:
queryAdd	ext/fts3/fts3.c	/^static void queryAdd(Query *q, const char *pTerm, int nTerm){$/;"	f	file:
queryClear	ext/fts1/fts1.c	/^static void queryClear(Query *q){$/;"	f	file:
queryClear	ext/fts2/fts2.c	/^static void queryClear(Query *q){$/;"	f	file:
queryClear	ext/fts3/fts3.c	/^static void queryClear(Query *q){$/;"	f	file:
queryTableLock	src/btree.c	/^static int queryTableLock(Btree *p, Pgno iTab, u8 eLock){$/;"	f	file:
queryTableLock	src/btree.c	83;"	d	file:
queryTokenizer	ext/fts2/fts2_tokenizer.c	/^int queryTokenizer($/;"	f	file:
queryTokenizer	ext/fts3/fts3_tokenizer.c	/^int queryTokenizer($/;"	f	file:
queueMutex	src/test_async.c	/^  pthread_mutex_t queueMutex;  \/* Mutex for access to write operation queue *\/$/;"	m	struct:TestAsyncStaticData	file:
queueMutex	src/test_server.c	/^  pthread_mutex_t queueMutex;   \/* Hold this mutex to access the msg queue *\/$/;"	m	struct:ServerState	file:
queueMutexHolder	src/test_async.c	/^  pthread_t queueMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
queueSignal	src/test_async.c	/^  pthread_cond_t queueSignal;  \/* For waking up sleeping writer thread *\/$/;"	m	struct:TestAsyncStaticData	file:
quote	tool/spaceanal.tcl	/^proc quote {txt} {$/;"	p
quoteFunc	src/func.c	/^static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
r	src/vdbeInt.h	/^  double r;           \/* Real value *\/$/;"	m	struct:Mem
rJD	src/date.c	/^  double rJD;      \/* The julian day number *\/$/;"	m	struct:DateTime	file:
rSum	src/func.c	/^  double rSum;      \/* Floating point sum *\/$/;"	m	struct:SumCtx	file:
randStr	src/func.c	/^static void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
randomBlob	src/func.c	/^static void randomBlob($/;"	f	file:
randomByte	src/random.c	/^static int randomByte(void){$/;"	f	file:
randomFunc	src/func.c	/^static void randomFunc($/;"	f	file:
rc	src/sqliteInt.h	/^  int rc;              \/* Return code from execution *\/$/;"	m	struct:Parse
rc	src/sqliteInt.h	/^  int rc;             \/* Result code stored here *\/$/;"	m	struct:__anon14
rc	src/table.c	/^  int rc;$/;"	m	struct:TabResult	file:
rc	src/tclsqlite.c	/^  int rc;                    \/* Return code of most recent sqlite3_exec() *\/$/;"	m	struct:SqliteDb	file:
rc	src/test4.c	/^  int rc;               \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	src/test7.c	/^  int rc;                  \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	src/vdbeInt.h	/^  int rc;                 \/* Value to return *\/$/;"	m	struct:Vdbe
read32bits	src/pager.c	/^static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){$/;"	f	file:
readDbPage	src/pager.c	/^static int readDbPage(Pager *pPager, PgHdr *pPg, Pgno pgno){$/;"	f	file:
readDocid	ext/fts1/fts1.c	/^static sqlite_int64 readDocid(DocListReader *pReader){$/;"	f	file:
readJournalHdr	src/pager.c	/^static int readJournalHdr($/;"	f	file:
readMasterJournal	src/pager.c	/^static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, int nMaster){$/;"	f	file:
readOnly	src/btreeInt.h	/^  u8 readOnly;          \/* True if the underlying file is readonly *\/$/;"	m	struct:BtShared
readOnly	src/pager.c	/^  u8 readOnly;                \/* True for a read-only database *\/$/;"	m	struct:Pager	file:
readOnly	src/sqliteInt.h	/^  u8 readOnly;     \/* True if this table should not be written by the user *\/$/;"	m	struct:Table
readPosition	ext/fts1/fts1.c	/^static int readPosition(DocListReader *pReader, int *iColumn){$/;"	f	file:
read_history	src/shell.c	42;"	d	file:
reader	ext/fts2/fts2.c	/^  DLReader reader;                 \/* Result reader if result not empty *\/$/;"	m	struct:fulltext_cursor	file:
reader	ext/fts3/fts3.c	/^  DLReader reader;                 \/* Result reader if result not empty *\/$/;"	m	struct:fulltext_cursor	file:
readerInit	ext/fts1/fts1.c	/^static void readerInit(DocListReader *r, DocList *pDoclist){$/;"	f	file:
readline	configure	/^readline ();$/;"	f
readline	src/shell.c	40;"	d	file:
readsTable	src/insert.c	/^static int readsTable(Vdbe *v, int iStartAddr, int iDb, Table *pTab){$/;"	f	file:
realloc	src/sqlite3ext.h	/^  void *(*realloc)(void*,int);$/;"	m	struct:sqlite3_api_routines
referencesOtherTables	src/where.c	/^static int referencesOtherTables($/;"	f	file:
regRoot	src/sqliteInt.h	/^  int regRoot;         \/* Register holding root page number for new objects *\/$/;"	m	struct:Parse
regRowid	src/sqliteInt.h	/^  int regRowid;        \/* Register holding rowid of CREATE TABLE entry *\/$/;"	m	struct:Parse
registerTokenizer	ext/fts2/fts2_tokenizer.c	/^int registerTokenizer($/;"	f	file:
registerTokenizer	ext/fts3/fts3_tokenizer.c	/^int registerTokenizer($/;"	f	file:
registerTrace	src/vdbe.c	/^static void registerTrace(FILE *out, int iReg, Mem *p){$/;"	f	file:
register_echo_module	src/test8.c	/^static int register_echo_module($/;"	f	file:
register_schema_module	src/test_schema.c	/^static int register_schema_module($/;"	f	file:
register_tclvar_module	src/test_tclvar.c	/^static int register_tclvar_module($/;"	f	file:
rehash	ext/fts1/fts1_hash.c	/^static void rehash(fts1Hash *pH, int new_size){$/;"	f	file:
rehash	ext/fts2/fts2_hash.c	/^static void rehash(fts2Hash *pH, int new_size){$/;"	f	file:
rehash	src/hash.c	/^static void rehash(Hash *pH, int new_size){$/;"	f	file:
reindexDatabases	src/build.c	/^static void reindexDatabases(Parse *pParse, char const *zColl){$/;"	f	file:
reindexTable	src/build.c	/^static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){$/;"	f	file:
releaseLockInfo	src/os_unix.c	/^static void releaseLockInfo(struct lockInfo *pLock){$/;"	f	file:
releaseMemArray	src/vdbeaux.c	/^static void releaseMemArray(Mem *p, int N){$/;"	f	file:
releaseOpenCnt	src/os_unix.c	/^static void releaseOpenCnt(struct openCnt *pOpen){$/;"	f	file:
releasePage	src/btree.c	/^static void releasePage(MemPage *pPage){$/;"	f	file:
release_memory	src/sqlite3ext.h	/^  int (*release_memory)(int);$/;"	m	struct:sqlite3_api_routines
reloadTableSchema	src/alter.c	/^static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){$/;"	f	file:
relocatePage	src/btree.c	/^static int relocatePage($/;"	f	file:
removeElementGivenHash	ext/fts1/fts1_hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeElementGivenHash	ext/fts2/fts2_hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeElementGivenHash	src/hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeFromSharingList	src/btree.c	/^static int removeFromSharingList(BtShared *pBt){$/;"	f	file:
renameTableFunc	src/alter.c	/^static void renameTableFunc($/;"	f	file:
renameTriggerFunc	src/alter.c	/^static void renameTriggerFunc($/;"	f	file:
reparentChildPages	src/btree.c	/^static int reparentChildPages(MemPage *pPage){$/;"	f	file:
reparentPage	src/btree.c	/^static int reparentPage(BtShared *pBt, Pgno pgno, MemPage *pNewParent, int idx){$/;"	f	file:
replaceFunc	src/func.c	/^static void replaceFunc($/;"	f	file:
report	tool/memleak3.tcl	/^proc report {} {$/;"	p
reset	src/sqlite3ext.h	/^  int  (*reset)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
resetAccumulator	src/select.c	/^static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
resetAutoExtObjCmd	src/test_autoext.c	/^static int resetAutoExtObjCmd($/;"	f	file:
reset_prng_state	src/test1.c	/^static int reset_prng_state($/;"	f	file:
resizeOpArray	src/vdbeaux.c	/^static void resizeOpArray(Vdbe *p, int N){$/;"	f	file:
resolveAttachExpr	src/attach.c	/^static int resolveAttachExpr(NameContext *pName, Expr *pExpr)$/;"	f	file:
resolveP2Values	src/vdbeaux.c	/^static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){$/;"	f	file:
resolve_backslashes	src/shell.c	/^static void resolve_backslashes(char *z){$/;"	f	file:
resolve_conflict	tool/lemon.c	/^static int resolve_conflict(apx,apy,errsym)$/;"	f	file:
restoreOrClearCursorPosition	src/btree.c	391;"	d	file:
restore_prng_state	src/test1.c	/^static int restore_prng_state($/;"	f	file:
result	ext/fts1/fts1.c	/^  DocListReader result;  \/* used when iCursorType == QUERY_FULLTEXT *\/ $/;"	m	struct:fulltext_cursor	file:
result	ext/fts2/fts2.c	/^  DataBuffer result;               \/* Doclist results from fulltextQuery *\/$/;"	m	struct:fulltext_cursor	file:
result	ext/fts3/fts3.c	/^  DataBuffer result;               \/* Doclist results from fulltextQuery *\/$/;"	m	struct:fulltext_cursor	file:
result	src/os_unix.c	/^  int result;            \/* Result of the locking operation *\/$/;"	m	struct:threadTestData	file:
result_blob	src/sqlite3ext.h	/^  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_double	src/sqlite3ext.h	/^  void  (*result_double)(sqlite3_context*,double);$/;"	m	struct:sqlite3_api_routines
result_error	src/sqlite3ext.h	/^  void  (*result_error)(sqlite3_context*,const char*,int);$/;"	m	struct:sqlite3_api_routines
result_error16	src/sqlite3ext.h	/^  void  (*result_error16)(sqlite3_context*,const void*,int);$/;"	m	struct:sqlite3_api_routines
result_error_nomem	src/sqlite3ext.h	/^  void (*result_error_nomem)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_error_toobig	src/sqlite3ext.h	/^  void (*result_error_toobig)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_int	src/sqlite3ext.h	/^  void  (*result_int)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
result_int64	src/sqlite3ext.h	/^  void  (*result_int64)(sqlite3_context*,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
result_null	src/sqlite3ext.h	/^  void  (*result_null)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_text	src/sqlite3ext.h	/^  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16	src/sqlite3ext.h	/^  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16be	src/sqlite3ext.h	/^  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16le	src/sqlite3ext.h	/^  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_value	src/sqlite3ext.h	/^  void  (*result_value)(sqlite3_context*,sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
retRangeStart	src/os_unix.c	/^  unsigned long long retRangeStart; \/* nbr of 1st byte locked if successful *\/$/;"	m	struct:ByteRangeLockPB2	file:
returnDepth	src/vdbeInt.h	/^  int returnDepth;        \/* Next unused element in returnStack[] *\/$/;"	m	struct:Vdbe
returnSingleInt	src/pragma.c	/^static void returnSingleInt(Parse *pParse, const char *zLabel, int value){$/;"	f	file:
returnStack	src/vdbeInt.h	/^  int returnStack[25];    \/* Return address stack for OP_Gosub & OP_Return *\/$/;"	m	struct:Vdbe
rhs	tool/lemon.c	/^  struct symbol **rhs;     \/* The RHS symbols *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
rhs	tool/lemon.c	/^  struct symbol *rhs[MAXRHS];  \/* RHS symbols *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
rhsalias	tool/lemon.c	/^  char **rhsalias;         \/* An alias for each RHS symbol (NULL if none) *\/$/;"	m	struct:rule	file:
rollback_hook	src/sqlite3ext.h	/^  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
rootData	ext/fts2/fts2.c	/^  DataBuffer rootData;      \/* root data for inline. *\/$/;"	m	struct:LeavesReader	file:
rootData	ext/fts3/fts3.c	/^  DataBuffer rootData;      \/* root data for inline. *\/$/;"	m	struct:LeavesReader	file:
roundFunc	src/func.c	/^static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
rowid	src/test_schema.c	/^  int rowid;$/;"	m	struct:schema_cursor	file:
rowidIsValid	src/vdbeInt.h	/^  Bool rowidIsValid;    \/* True if lastRowid is valid *\/$/;"	m	struct:Cursor
rp	tool/lemon.c	/^    struct rule *rp;       \/* The rule, if a reduce *\/$/;"	m	union:action::__anon9	typeref:struct:action::__anon9::rule	file:
rp	tool/lemon.c	/^  struct rule *rp;         \/* The rule upon which the configuration is based *\/$/;"	m	struct:config	typeref:struct:config::rule	file:
rule	tool/lemon.c	/^  struct rule *rule;       \/* Linked list of rules of this (if an NT) *\/$/;"	m	struct:symbol	typeref:struct:symbol::rule	file:
rule	tool/lemon.c	/^  struct rule *rule;       \/* List of all rules *\/$/;"	m	struct:lemon	typeref:struct:lemon::rule	file:
rule	tool/lemon.c	/^struct rule {$/;"	s	file:
ruleline	tool/lemon.c	/^  int ruleline;            \/* Line number for the rule *\/$/;"	m	struct:rule	file:
run_quick_test	tool/omittest.tcl	/^proc run_quick_test {dir omit_symbol_list} {$/;"	p
run_schema_dump_query	src/shell.c	/^static int run_schema_dump_query($/;"	f	file:
run_table_dump_query	src/shell.c	/^static int run_table_dump_query(FILE *out, sqlite3 *db, const char *zSelect){$/;"	f	file:
runtest	tool/speedtest.tcl	/^proc runtest {title} {$/;"	p
runtest	tool/speedtest2.tcl	/^proc runtest {title} {$/;"	p
s	ext/fts1/fts1.c	/^  char *s;      \/* Content of the string *\/$/;"	m	struct:StringBuffer	file:
s	src/date.c	/^  double s;        \/* Seconds *\/$/;"	m	struct:DateTime	file:
s	src/random.c	/^  unsigned char s[256];          \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
s	src/vdbeInt.h	/^  Mem s;                \/* The return value is stored here *\/$/;"	m	struct:sqlite3_context
sArg	src/sqliteInt.h	/^  Token sArg;                \/* Complete text of a module argument *\/$/;"	m	struct:Parse
sBegin	src/shell.c	/^static struct rusage sBegin;$/;"	v	typeref:struct:rusage	file:
sColMap	src/sqliteInt.h	/^  struct sColMap {  \/* Mapping of columns in pFrom to columns in zTo *\/$/;"	s	struct:FKey
sDb	src/test3.c	/^static sqlite3 sDb;$/;"	v	file:
sErrToken	src/sqliteInt.h	/^  Token sErrToken;     \/* The token at which the error occurred *\/$/;"	m	struct:Parse
sFifo	src/vdbeInt.h	/^  Fifo sFifo;             \/* A list of ROWIDs *\/$/;"	m	struct:Vdbe
sFifo	src/vdbeInt.h	/^  Fifo sFifo;       \/* Records that will participate in a DELETE or UPDATE *\/$/;"	m	struct:Context
sLastToken	src/sqliteInt.h	/^  Token sLastToken;    \/* The last token parsed *\/$/;"	m	struct:Parse
sNameToken	src/sqliteInt.h	/^  Token sNameToken;    \/* Token with unqualified schema object name *\/$/;"	m	struct:Parse
s_options	tool/lemon.c	/^struct s_options {$/;"	s	file:
s_x1	tool/lemon.c	/^struct s_x1 {$/;"	s	file:
s_x1node	tool/lemon.c	/^typedef struct s_x1node {$/;"	s	file:
s_x2	tool/lemon.c	/^struct s_x2 {$/;"	s	file:
s_x2node	tool/lemon.c	/^typedef struct s_x2node {$/;"	s	file:
s_x3	tool/lemon.c	/^struct s_x3 {$/;"	s	file:
s_x3node	tool/lemon.c	/^typedef struct s_x3node {$/;"	s	file:
s_x4	tool/lemon.c	/^struct s_x4 {$/;"	s	file:
s_x4node	tool/lemon.c	/^typedef struct s_x4node {$/;"	s	file:
safeToUseEvalObjv	src/tclsqlite.c	/^static int safeToUseEvalObjv(Tcl_Interp *interp, Tcl_Obj *pCmd){$/;"	f	file:
safe_isalnum	ext/fts1/fts1.c	/^static int safe_isalnum(char c){$/;"	f	file:
safe_isalnum	ext/fts2/fts2.c	/^static int safe_isalnum(char c){$/;"	f	file:
safe_isalnum	ext/fts3/fts3.c	/^static int safe_isalnum(char c){$/;"	f	file:
safe_isspace	ext/fts1/fts1.c	/^static int safe_isspace(char c){$/;"	f	file:
safe_isspace	ext/fts2/fts2.c	/^static int safe_isspace(char c){$/;"	f	file:
safe_isspace	ext/fts3/fts3.c	/^static int safe_isspace(char c){$/;"	f	file:
safe_tolower	ext/fts1/fts1.c	/^static int safe_tolower(char c){$/;"	f	file:
safe_tolower	ext/fts2/fts2.c	/^static int safe_tolower(char c){$/;"	f	file:
safe_tolower	ext/fts3/fts3.c	/^static int safe_tolower(char c){$/;"	f	file:
safety_level	src/sqliteInt.h	/^  u8 safety_level;     \/* How aggressive at synching data to disk *\/$/;"	m	struct:Db
same_symbol	tool/lemon.c	/^int same_symbol(a,b)$/;"	f
saveAllCursors	src/btree.c	/^static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){$/;"	f	file:
saveCursorPosition	src/btree.c	/^static int saveCursorPosition(BtCursor *pCur){$/;"	f	file:
save_prng_state	src/test1.c	/^static int save_prng_state($/;"	f	file:
saved_cnt	src/pager.c	/^static int saved_cnt;$/;"	v	file:
scalarFunc	ext/fts2/fts2_tokenizer.c	/^static void scalarFunc($/;"	f	file:
scalarFunc	ext/fts3/fts3_tokenizer.c	/^static void scalarFunc($/;"	f	file:
scenario	tool/soak1.tcl	/^proc scenario {id title pattern} {$/;"	p
schemaBestIndex	src/test_schema.c	/^static int schemaBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
schemaClose	src/test_schema.c	/^static int schemaClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaColumn	src/test_schema.c	/^static int schemaColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
schemaCreate	src/test_schema.c	/^static int schemaCreate($/;"	f	file:
schemaDestroy	src/test_schema.c	/^static int schemaDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
schemaEof	src/test_schema.c	/^static int schemaEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaFilter	src/test_schema.c	/^static int schemaFilter($/;"	f	file:
schemaIsValid	src/prepare.c	/^static int schemaIsValid(sqlite3 *db){$/;"	f	file:
schemaModule	src/test_schema.c	/^static sqlite3_module schemaModule = {$/;"	v	file:
schemaNext	src/test_schema.c	/^static int schemaNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaOpen	src/test_schema.c	/^static int schemaOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
schemaRowid	src/test_schema.c	/^static int schemaRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
schema_cookie	src/sqliteInt.h	/^  int schema_cookie;   \/* Database schema version number for this file *\/$/;"	m	struct:Schema
schema_cursor	src/test_schema.c	/^struct schema_cursor {$/;"	s	file:
schema_cursor	src/test_schema.c	/^typedef struct schema_cursor schema_cursor;$/;"	t	typeref:struct:schema_cursor	file:
schema_vtab	src/test_schema.c	/^struct schema_vtab {$/;"	s	file:
schema_vtab	src/test_schema.c	/^typedef struct schema_vtab schema_vtab;$/;"	t	typeref:struct:schema_vtab	file:
section_comment	ext/fts2/mkfts2amal.tcl	/^proc section_comment {text} {$/;"	p
section_comment	ext/fts3/mkfts3amal.tcl	/^proc section_comment {text} {$/;"	p
section_comment	tool/mksqlite3c.tcl	/^proc section_comment {text} {$/;"	p
sectorSize	src/pager.c	/^  int sectorSize;             \/* Assumed sector size during rollback *\/$/;"	m	struct:Pager	file:
seekAndRead	src/os_unix.c	/^static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){$/;"	f	file:
seekAndWrite	src/os_unix.c	/^static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){$/;"	f	file:
seekJournalHdr	src/pager.c	/^static void seekJournalHdr(Pager *pPager){$/;"	f	file:
seenInterrupt	src/shell.c	/^static volatile int seenInterrupt = 0;$/;"	v	file:
segdirNextIndex	ext/fts2/fts2.c	/^static int segdirNextIndex(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdirNextIndex	ext/fts3/fts3.c	/^static int segdirNextIndex(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdir_delete	ext/fts2/fts2.c	/^static int segdir_delete(fulltext_vtab *v, int iLevel){$/;"	f	file:
segdir_delete	ext/fts3/fts3.c	/^static int segdir_delete(fulltext_vtab *v, int iLevel){$/;"	f	file:
segdir_max_index	ext/fts2/fts2.c	/^static int segdir_max_index(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdir_max_index	ext/fts3/fts3.c	/^static int segdir_max_index(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdir_set	ext/fts2/fts2.c	/^static int segdir_set(fulltext_vtab *v, int iLevel, int idx,$/;"	f	file:
segdir_set	ext/fts3/fts3.c	/^static int segdir_set(fulltext_vtab *v, int iLevel, int idx,$/;"	f	file:
segdir_span	ext/fts2/fts2.c	/^static int segdir_span(fulltext_vtab *v, int iLevel,$/;"	f	file:
segdir_span	ext/fts3/fts3.c	/^static int segdir_span(fulltext_vtab *v, int iLevel,$/;"	f	file:
segmentMerge	ext/fts2/fts2.c	/^static int segmentMerge(fulltext_vtab *v, int iLevel){$/;"	f	file:
segmentMerge	ext/fts3/fts3.c	/^static int segmentMerge(fulltext_vtab *v, int iLevel){$/;"	f	file:
selectInnerLoop	src/select.c	/^static void selectInnerLoop($/;"	f	file:
selectOpName	src/select.c	/^static const char *selectOpName(int id){$/;"	f	file:
sendToServer	src/test_server.c	/^static void sendToServer(SqlMessage *pMsg){$/;"	f	file:
separator	src/shell.c	/^  char separator[20];    \/* Separator character for MODE_List *\/$/;"	m	struct:callback_data	file:
seqCount	src/vdbeInt.h	/^  i64 seqCount;         \/* Sequence counter *\/$/;"	m	struct:Cursor
serverHalt	src/test_server.c	/^  volatile int serverHalt;      \/* Server halts itself when true *\/$/;"	m	struct:ServerState	file:
serverMutex	src/test_server.c	/^  pthread_mutex_t serverMutex;  \/* Held by the server while it is running *\/$/;"	m	struct:ServerState	file:
serverWakeup	src/test_server.c	/^  pthread_cond_t serverWakeup;  \/* Signal this condvar to wake up the server *\/$/;"	m	struct:ServerState	file:
setChildPtrmaps	src/btree.c	/^static int setChildPtrmaps(MemPage *pPage){$/;"	f	file:
setJoinExpr	src/select.c	/^static void setJoinExpr(Expr *p, int iTable){$/;"	f	file:
setLikeOptFlag	src/func.c	/^static void setLikeOptFlag(sqlite3 *db, const char *zName, int flagVal){$/;"	f	file:
setMaster	src/pager.c	/^  u8 setMaster;               \/* True if a m-j name has been written to jrnl *\/$/;"	m	struct:Pager	file:
setQuotedToken	src/select.c	/^static void setQuotedToken(Parse *pParse, Token *p, const char *z){$/;"	f	file:
setSectorSize	src/pager.c	/^static void setSectorSize(Pager *pPager){$/;"	f	file:
setToken	src/select.c	/^static void setToken(Token *p, const char *z){$/;"	f	file:
set_authorizer	src/sqlite3ext.h	/^  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,const char*,const char*),void*);$/;"	m	struct:sqlite3_api_routines
set_auxdata	src/sqlite3ext.h	/^  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));$/;"	m	struct:sqlite3_api_routines
set_options	src/test_config.c	/^static void set_options(Tcl_Interp *interp){$/;"	f	file:
set_table_name	src/shell.c	/^static void set_table_name(struct callback_data *p, const char *zName){$/;"	f	file:
sharable	src/btreeInt.h	/^  u8 sharable;       \/* True if we can share pBt with another db *\/$/;"	m	struct:Btree
shared	src/os_win.c	/^  winceLock *shared;      \/* Global shared lock memory for the file  *\/$/;"	m	struct:winFile	file:
sharedLockByte	src/os_unix.c	/^  unsigned long long sharedLockByte;$/;"	m	struct:afpLockingContext	file:
sharedLockByte	src/os_win.c	/^  short sharedLockByte;   \/* Randomly chosen byte used as a shared lock *\/$/;"	m	struct:winFile	file:
shellstaticFunc	src/shell.c	/^static void shellstaticFunc($/;"	f	file:
shift	tool/memleak3.tcl	/^proc shift {listvar} {$/;"	p
shl_load	configure	/^shl_load ();$/;"	f
showHeader	src/shell.c	/^  int showHeader;        \/* True to show column names in List or Column mode *\/$/;"	m	struct:callback_data	file:
showHeader	src/shell.c	/^  int showHeader;$/;"	m	struct:previous_mode_data	file:
sig	test/threadtest1.c	/^pthread_cond_t sig = PTHREAD_COND_INITIALIZER;$/;"	v
signed	parse.y	/^signed ::= minus_num.$/;"	l
signed	parse.y	/^signed ::= plus_num.$/;"	l
signed	src/parse.y	/^signed ::= minus_num.$/;"	l
signed	src/parse.y	/^signed ::= plus_num.$/;"	l
simpleClose	ext/fts1/fts1_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleClose	ext/fts2/fts2_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleClose	ext/fts3/fts3_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleCreate	ext/fts1/fts1_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleCreate	ext/fts2/fts2_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleCreate	ext/fts3/fts3_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleDelim	ext/fts2/fts2_tokenizer1.c	/^static int simpleDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
simpleDelim	ext/fts3/fts3_tokenizer1.c	/^static int simpleDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
simpleDestroy	ext/fts1/fts1_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleDestroy	ext/fts2/fts2_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleDestroy	ext/fts3/fts3_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleNext	ext/fts1/fts1_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleNext	ext/fts2/fts2_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleNext	ext/fts3/fts3_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleOpen	ext/fts1/fts1_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleOpen	ext/fts2/fts2_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleOpen	ext/fts3/fts3_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleTokenizerModule	ext/fts1/fts1_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	ext/fts1/fts1_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule;$/;"	v	file:
simpleTokenizerModule	ext/fts2/fts2_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	ext/fts2/fts2_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule;$/;"	v	file:
simpleTokenizerModule	ext/fts3/fts3_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	ext/fts3/fts3_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule;$/;"	v	file:
simple_tokenizer	ext/fts1/fts1_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	ext/fts1/fts1_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer	ext/fts2/fts2_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	ext/fts2/fts2_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer	ext/fts3/fts3_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	ext/fts3/fts3_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer_cursor	ext/fts1/fts1_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	ext/fts1/fts1_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simple_tokenizer_cursor	ext/fts2/fts2_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	ext/fts2/fts2_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simple_tokenizer_cursor	ext/fts3/fts3_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	ext/fts3/fts3_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x1	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x2	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x3	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x4	file:
size	tool/lemon.c	/^static int size = 0;$/;"	v	file:
size4x	src/mem3.c	/^      u32 size4x;     \/* 4x the size of current chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon19::__anon20	file:
sizeCnt	src/mem2.c	/^  int sizeCnt[NCSIZE];$/;"	m	struct:__anon16	file:
skip	src/btreeInt.h	/^  int skip;        \/* (skip<0) -> Prev() is a no-op. (skip>0) -> Next() is *\/$/;"	m	struct:BtCursor
skipDocument	ext/fts1/fts1.c	/^static void skipDocument(DocListReader *pReader){$/;"	f	file:
skipPositionList	ext/fts1/fts1.c	/^static void skipPositionList(DocListReader *pReader){$/;"	f	file:
skipToDocid	ext/fts1/fts1.c	/^static int skipToDocid(DocListReader *pReader, sqlite_int64 iDocid){$/;"	f	file:
sleep	src/sqlite3ext.h	/^  int (*sleep)(int);$/;"	m	struct:sqlite3_api_routines
snStatus	ext/fts1/fts1.c	/^    char snStatus;       \/* Status flag for use while constructing snippets *\/$/;"	m	struct:Snippet::snippetMatch	file:
snStatus	ext/fts2/fts2.c	/^    char snStatus;       \/* Status flag for use while constructing snippets *\/$/;"	m	struct:Snippet::snippetMatch	file:
snStatus	ext/fts3/fts3.c	/^    char snStatus;       \/* Status flag for use while constructing snippets *\/$/;"	m	struct:Snippet::snippetMatch	file:
snippet	ext/fts1/fts1.c	/^  Snippet snippet;                 \/* Cached snippet for the current row *\/$/;"	m	struct:fulltext_cursor	file:
snippet	ext/fts2/fts2.c	/^  Snippet snippet;                 \/* Cached snippet for the current row *\/$/;"	m	struct:fulltext_cursor	file:
snippet	ext/fts3/fts3.c	/^  Snippet snippet;                 \/* Cached snippet for the current row *\/$/;"	m	struct:fulltext_cursor	file:
snippetAllOffsets	ext/fts1/fts1.c	/^static void snippetAllOffsets(fulltext_cursor *p){$/;"	f	file:
snippetAllOffsets	ext/fts2/fts2.c	/^static void snippetAllOffsets(fulltext_cursor *p){$/;"	f	file:
snippetAllOffsets	ext/fts3/fts3.c	/^static void snippetAllOffsets(fulltext_cursor *p){$/;"	f	file:
snippetAppendMatch	ext/fts1/fts1.c	/^static void snippetAppendMatch($/;"	f	file:
snippetAppendMatch	ext/fts2/fts2.c	/^static void snippetAppendMatch($/;"	f	file:
snippetAppendMatch	ext/fts3/fts3.c	/^static void snippetAppendMatch($/;"	f	file:
snippetClear	ext/fts1/fts1.c	/^static void snippetClear(Snippet *p){$/;"	f	file:
snippetClear	ext/fts2/fts2.c	/^static void snippetClear(Snippet *p){$/;"	f	file:
snippetClear	ext/fts3/fts3.c	/^static void snippetClear(Snippet *p){$/;"	f	file:
snippetFunc	ext/fts1/fts1.c	/^static void snippetFunc($/;"	f	file:
snippetFunc	ext/fts2/fts2.c	/^static void snippetFunc($/;"	f	file:
snippetFunc	ext/fts3/fts3.c	/^static void snippetFunc($/;"	f	file:
snippetMatch	ext/fts1/fts1.c	/^  struct snippetMatch { \/* One entry for each matching term *\/$/;"	s	struct:Snippet	file:
snippetMatch	ext/fts2/fts2.c	/^  struct snippetMatch { \/* One entry for each matching term *\/$/;"	s	struct:Snippet	file:
snippetMatch	ext/fts3/fts3.c	/^  struct snippetMatch { \/* One entry for each matching term *\/$/;"	s	struct:Snippet	file:
snippetOffsetText	ext/fts1/fts1.c	/^static void snippetOffsetText(Snippet *p){$/;"	f	file:
snippetOffsetText	ext/fts2/fts2.c	/^static void snippetOffsetText(Snippet *p){$/;"	f	file:
snippetOffsetText	ext/fts3/fts3.c	/^static void snippetOffsetText(Snippet *p){$/;"	f	file:
snippetOffsetsFunc	ext/fts1/fts1.c	/^static void snippetOffsetsFunc($/;"	f	file:
snippetOffsetsFunc	ext/fts2/fts2.c	/^static void snippetOffsetsFunc($/;"	f	file:
snippetOffsetsFunc	ext/fts3/fts3.c	/^static void snippetOffsetsFunc($/;"	f	file:
snippetOffsetsOfColumn	ext/fts1/fts1.c	/^static void snippetOffsetsOfColumn($/;"	f	file:
snippetOffsetsOfColumn	ext/fts2/fts2.c	/^static void snippetOffsetsOfColumn($/;"	f	file:
snippetOffsetsOfColumn	ext/fts3/fts3.c	/^static void snippetOffsetsOfColumn($/;"	f	file:
snippetText	ext/fts1/fts1.c	/^static void snippetText($/;"	f	file:
snippetText	ext/fts2/fts2.c	/^static void snippetText($/;"	f	file:
snippetText	ext/fts3/fts3.c	/^static void snippetText($/;"	f	file:
snprintf	src/sqlite3ext.h	/^  char * (*snprintf)(int,char*,const char*,...);$/;"	m	struct:sqlite3_api_routines
softHeapLimitEnforcer	src/malloc.c	/^static void softHeapLimitEnforcer($/;"	f	file:
soft_heap_limit	src/sqlite3ext.h	/^  void (*soft_heap_limit)(int);$/;"	m	struct:sqlite3_api_routines
sortOrder	src/sqliteInt.h	/^    u8 sortOrder;          \/* 1 for DESC or 0 for ASC *\/$/;"	m	struct:ExprList::ExprList_item
sort_pagelist	src/pager.c	/^static PgHdr *sort_pagelist(PgHdr *pIn){$/;"	f	file:
sortableByRowid	src/where.c	/^static int sortableByRowid($/;"	f	file:
sorted	tool/lemon.c	/^  struct state **sorted;   \/* Table of states sorted by state number *\/$/;"	m	struct:lemon	typeref:struct:lemon::state	file:
sortingIdx	src/sqliteInt.h	/^  int sortingIdx;         \/* Cursor number of the sorting index *\/$/;"	m	struct:AggInfo
soundexFunc	src/func.c	/^static void soundexFunc($/;"	f	file:
sp	tool/lemon.c	/^  struct symbol *sp;       \/* The look-ahead symbol *\/$/;"	m	struct:action	typeref:struct:action::symbol	file:
span	src/sqliteInt.h	/^  Token span;            \/* Complete text of the expression *\/$/;"	m	struct:Expr
speed_trial	test/tester.tcl	/^proc speed_trial {name numstmt units sql} {$/;"	p
speed_trial_init	test/tester.tcl	/^proc speed_trial_init {name} {$/;"	p
speed_trial_summary	test/tester.tcl	/^proc speed_trial_summary {name} {$/;"	p
sql_exec	ext/fts1/fts1.c	/^static int sql_exec(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_exec	ext/fts2/fts2.c	/^static int sql_exec(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_exec	ext/fts3/fts3.c	/^static int sql_exec(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_get_leaf_statement	ext/fts2/fts2.c	/^static int sql_get_leaf_statement(fulltext_vtab *v, int idx,$/;"	f	file:
sql_get_leaf_statement	ext/fts3/fts3.c	/^static int sql_get_leaf_statement(fulltext_vtab *v, int idx,$/;"	f	file:
sql_get_statement	ext/fts1/fts1.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_get_statement	ext/fts2/fts2.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_get_statement	ext/fts3/fts3.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_prepare	ext/fts1/fts1.c	/^static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_prepare	ext/fts2/fts2.c	/^static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_prepare	ext/fts3/fts3.c	/^static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_single_step	ext/fts2/fts2.c	/^static int sql_single_step(sqlite3_stmt *s){$/;"	f	file:
sql_single_step	ext/fts3/fts3.c	/^static int sql_single_step(sqlite3_stmt *s){$/;"	f	file:
sql_single_step_statement	ext/fts1/fts1.c	/^static int sql_single_step_statement(fulltext_vtab *v,$/;"	f	file:
sql_step_statement	ext/fts1/fts1.c	/^static int sql_step_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sqlite3	sqlite3.h	/^typedef struct sqlite3 sqlite3;$/;"	t	typeref:struct:sqlite3
sqlite3	src/sqliteInt.h	/^struct sqlite3 {$/;"	s
sqlite3	test/tester.tcl	/^  proc sqlite3 {args} {$/;"	p
sqlite3AFPLockingUnixIoMethod	src/os_unix.c	/^static const sqlite3_io_methods sqlite3AFPLockingUnixIoMethod = {$/;"	v	file:
sqlite3AddCheckConstraint	src/build.c	/^void sqlite3AddCheckConstraint($/;"	f
sqlite3AddCollateType	src/build.c	/^void sqlite3AddCollateType(Parse *pParse, Token *pToken){$/;"	f
sqlite3AddColumn	src/build.c	/^void sqlite3AddColumn(Parse *pParse, Token *pName){$/;"	f
sqlite3AddColumnType	src/build.c	/^void sqlite3AddColumnType(Parse *pParse, Token *pType){$/;"	f
sqlite3AddDefaultValue	src/build.c	/^void sqlite3AddDefaultValue(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3AddNotNull	src/build.c	/^void sqlite3AddNotNull(Parse *pParse, int onError){$/;"	f
sqlite3AddPrimaryKey	src/build.c	/^void sqlite3AddPrimaryKey($/;"	f
sqlite3AffinityType	src/build.c	/^char sqlite3AffinityType(const Token *pType){$/;"	f
sqlite3AlterBeginAddColumn	src/alter.c	/^void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3AlterFinishAddColumn	src/alter.c	/^void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){$/;"	f
sqlite3AlterFunctions	src/alter.c	/^void sqlite3AlterFunctions(sqlite3 *db){$/;"	f
sqlite3AlterRenameTable	src/alter.c	/^void sqlite3AlterRenameTable($/;"	f
sqlite3AnalysisLoad	src/analyze.c	/^int sqlite3AnalysisLoad(sqlite3 *db, int iDb){$/;"	f
sqlite3Analyze	src/analyze.c	/^void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ApiExit	src/malloc.c	/^int sqlite3ApiExit(sqlite3* db, int rc){$/;"	f
sqlite3ArrayAllocate	src/build.c	/^void *sqlite3ArrayAllocate($/;"	f
sqlite3AtoF	src/util.c	/^int sqlite3AtoF(const char *z, double *pResult){$/;"	f
sqlite3Atoi64	src/util.c	/^int sqlite3Atoi64(const char *zNum, i64 *pNum){$/;"	f
sqlite3Attach	src/attach.c	/^void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){$/;"	f
sqlite3AttachFunctions	src/attach.c	/^void sqlite3AttachFunctions(sqlite3 *db){$/;"	f
sqlite3AuthCheck	src/auth.c	/^int sqlite3AuthCheck($/;"	f
sqlite3AuthCheck	src/sqliteInt.h	1867;"	d
sqlite3AuthContextPop	src/auth.c	/^void sqlite3AuthContextPop(AuthContext *pContext){$/;"	f
sqlite3AuthContextPop	src/sqliteInt.h	1869;"	d
sqlite3AuthContextPush	src/auth.c	/^void sqlite3AuthContextPush($/;"	f
sqlite3AuthContextPush	src/sqliteInt.h	1868;"	d
sqlite3AuthRead	src/auth.c	/^void sqlite3AuthRead($/;"	f
sqlite3AuthRead	src/sqliteInt.h	1866;"	d
sqlite3AutoLoadExtensions	src/loadext.c	/^int sqlite3AutoLoadExtensions(sqlite3 *db){$/;"	f
sqlite3AutoLoadExtensions	src/sqliteInt.h	1973;"	d
sqlite3BeginParse	src/build.c	/^void sqlite3BeginParse(Parse *pParse, int explainFlag){$/;"	f
sqlite3BeginTransaction	src/build.c	/^void sqlite3BeginTransaction(Parse *pParse, int type){$/;"	f
sqlite3BeginTrigger	src/trigger.c	/^void sqlite3BeginTrigger($/;"	f
sqlite3BeginWriteOperation	src/build.c	/^void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){$/;"	f
sqlite3BinaryCompareCollSeq	src/expr.c	/^CollSeq *sqlite3BinaryCompareCollSeq($/;"	f
sqlite3BtreeBeginStmt	src/btree.c	/^int sqlite3BtreeBeginStmt(Btree *p){$/;"	f
sqlite3BtreeBeginTrans	src/btree.c	/^int sqlite3BtreeBeginTrans(Btree *p, int wrflag){$/;"	f
sqlite3BtreeCacheOverflow	src/btree.c	/^void sqlite3BtreeCacheOverflow(BtCursor *pCur){$/;"	f
sqlite3BtreeClearTable	src/btree.c	/^int sqlite3BtreeClearTable(Btree *p, int iTable){$/;"	f
sqlite3BtreeClose	src/btree.c	/^int sqlite3BtreeClose(Btree *p){$/;"	f
sqlite3BtreeCloseCursor	src/btree.c	/^int sqlite3BtreeCloseCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeCommit	src/btree.c	/^int sqlite3BtreeCommit(Btree *p){$/;"	f
sqlite3BtreeCommitPhaseOne	src/btree.c	/^int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){$/;"	f
sqlite3BtreeCommitPhaseTwo	src/btree.c	/^int sqlite3BtreeCommitPhaseTwo(Btree *p){$/;"	f
sqlite3BtreeCommitStmt	src/btree.c	/^int sqlite3BtreeCommitStmt(Btree *p){$/;"	f
sqlite3BtreeCopyFile	src/btree.c	/^int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){$/;"	f
sqlite3BtreeCreateTable	src/btree.c	/^int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){$/;"	f
sqlite3BtreeCursor	src/btree.c	/^int sqlite3BtreeCursor($/;"	f
sqlite3BtreeCursorDb	src/btree.c	/^sqlite3 *sqlite3BtreeCursorDb(const BtCursor *pCur){$/;"	f
sqlite3BtreeCursorInfo	src/test_btree.c	/^int sqlite3BtreeCursorInfo(BtCursor *pCur, int *aResult, int upCnt){$/;"	f
sqlite3BtreeCursorList	src/test_btree.c	/^void sqlite3BtreeCursorList(Btree *p){$/;"	f
sqlite3BtreeData	src/btree.c	/^int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeDataFetch	src/btree.c	/^const void *sqlite3BtreeDataFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeDataSize	src/btree.c	/^int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){$/;"	f
sqlite3BtreeDelete	src/btree.c	/^int sqlite3BtreeDelete(BtCursor *pCur){$/;"	f
sqlite3BtreeDropTable	src/btree.c	/^int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){$/;"	f
sqlite3BtreeEnter	src/btmutex.c	/^void sqlite3BtreeEnter(Btree *p){$/;"	f
sqlite3BtreeEnter	src/btree.h	189;"	d
sqlite3BtreeEnterAll	src/btmutex.c	/^void sqlite3BtreeEnterAll(sqlite3 *db){$/;"	f
sqlite3BtreeEnterAll	src/btree.h	194;"	d
sqlite3BtreeEnterCursor	src/btmutex.c	/^void sqlite3BtreeEnterCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeEnterCursor	src/btree.h	192;"	d
sqlite3BtreeEof	src/btree.c	/^int sqlite3BtreeEof(BtCursor *pCur){$/;"	f
sqlite3BtreeFactory	src/main.c	/^int sqlite3BtreeFactory($/;"	f
sqlite3BtreeFindCell	src/btree.c	/^u8 *sqlite3BtreeFindCell(MemPage *pPage, int iCell){$/;"	f
sqlite3BtreeFirst	src/btree.c	/^int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeFlags	src/btree.c	/^int sqlite3BtreeFlags(BtCursor *pCur){$/;"	f
sqlite3BtreeGetAutoVacuum	src/btree.c	/^int sqlite3BtreeGetAutoVacuum(Btree *p){$/;"	f
sqlite3BtreeGetDirname	src/btree.c	/^const char *sqlite3BtreeGetDirname(Btree *p){$/;"	f
sqlite3BtreeGetFilename	src/btree.c	/^const char *sqlite3BtreeGetFilename(Btree *p){$/;"	f
sqlite3BtreeGetJournalname	src/btree.c	/^const char *sqlite3BtreeGetJournalname(Btree *p){$/;"	f
sqlite3BtreeGetMeta	src/btree.c	/^int sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){$/;"	f
sqlite3BtreeGetPage	src/btree.c	/^int sqlite3BtreeGetPage($/;"	f
sqlite3BtreeGetPageSize	src/btree.c	/^int sqlite3BtreeGetPageSize(Btree *p){$/;"	f
sqlite3BtreeGetReserve	src/btree.c	/^int sqlite3BtreeGetReserve(Btree *p){$/;"	f
sqlite3BtreeGetTempCursor	src/btree.c	/^void sqlite3BtreeGetTempCursor(BtCursor *pCur, BtCursor *pTempCur){$/;"	f
sqlite3BtreeHoldsAllMutexes	src/btmutex.c	/^int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){$/;"	f
sqlite3BtreeHoldsAllMutexes	src/btree.h	196;"	d
sqlite3BtreeHoldsMutex	src/btmutex.c	/^int sqlite3BtreeHoldsMutex(Btree *p){$/;"	f
sqlite3BtreeHoldsMutex	src/btree.h	191;"	d
sqlite3BtreeIncrVacuum	src/btree.c	/^int sqlite3BtreeIncrVacuum(Btree *p){$/;"	f
sqlite3BtreeInitPage	src/btree.c	/^int sqlite3BtreeInitPage($/;"	f
sqlite3BtreeInsert	src/btree.c	/^int sqlite3BtreeInsert($/;"	f
sqlite3BtreeIntegrityCheck	src/btree.c	/^char *sqlite3BtreeIntegrityCheck($/;"	f
sqlite3BtreeInvokeBusyHandler	src/btree.c	/^static int sqlite3BtreeInvokeBusyHandler(void *pArg, int n){$/;"	f	file:
sqlite3BtreeIsInReadTrans	src/btree.c	/^int sqlite3BtreeIsInReadTrans(Btree *p){$/;"	f
sqlite3BtreeIsInStmt	src/btree.c	/^int sqlite3BtreeIsInStmt(Btree *p){$/;"	f
sqlite3BtreeIsInTrans	src/btree.c	/^int sqlite3BtreeIsInTrans(Btree *p){$/;"	f
sqlite3BtreeIsRootPage	src/btree.c	/^int sqlite3BtreeIsRootPage(MemPage *pPage){$/;"	f
sqlite3BtreeKey	src/btree.c	/^int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeKeyFetch	src/btree.c	/^const void *sqlite3BtreeKeyFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeKeySize	src/btree.c	/^int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){$/;"	f
sqlite3BtreeLast	src/btree.c	/^int sqlite3BtreeLast(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeLeave	src/btmutex.c	/^void sqlite3BtreeLeave(Btree *p){$/;"	f
sqlite3BtreeLeave	src/btree.h	190;"	d
sqlite3BtreeLeaveAll	src/btmutex.c	/^void sqlite3BtreeLeaveAll(sqlite3 *db){$/;"	f
sqlite3BtreeLeaveAll	src/btree.h	195;"	d
sqlite3BtreeLeaveCursor	src/btmutex.c	/^void sqlite3BtreeLeaveCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeLeaveCursor	src/btree.h	193;"	d
sqlite3BtreeLockTable	src/btree.c	/^int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){$/;"	f
sqlite3BtreeMaxPageCount	src/btree.c	/^int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){$/;"	f
sqlite3BtreeMoveToParent	src/btree.c	/^void sqlite3BtreeMoveToParent(BtCursor *pCur){$/;"	f
sqlite3BtreeMoveto	src/btree.c	/^int sqlite3BtreeMoveto($/;"	f
sqlite3BtreeMutexArrayEnter	src/btmutex.c	/^void sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray){$/;"	f
sqlite3BtreeMutexArrayEnter	src/btree.h	197;"	d
sqlite3BtreeMutexArrayInsert	src/btmutex.c	/^void sqlite3BtreeMutexArrayInsert(BtreeMutexArray *pArray, Btree *pBtree){$/;"	f
sqlite3BtreeMutexArrayInsert	src/btree.h	199;"	d
sqlite3BtreeMutexArrayLeave	src/btmutex.c	/^void sqlite3BtreeMutexArrayLeave(BtreeMutexArray *pArray){$/;"	f
sqlite3BtreeMutexArrayLeave	src/btree.h	198;"	d
sqlite3BtreeNext	src/btree.c	/^int sqlite3BtreeNext(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeOpen	src/btree.c	/^int sqlite3BtreeOpen($/;"	f
sqlite3BtreePageDump	src/test_btree.c	/^int sqlite3BtreePageDump(Btree *p, int pgno, int recursive){$/;"	f
sqlite3BtreePager	src/btree.c	/^Pager *sqlite3BtreePager(Btree *p){$/;"	f
sqlite3BtreeParseCell	src/btree.c	/^void sqlite3BtreeParseCell($/;"	f
sqlite3BtreeParseCellPtr	src/btree.c	/^void sqlite3BtreeParseCellPtr($/;"	f
sqlite3BtreePrevious	src/btree.c	/^int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreePutData	src/btree.c	/^int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){$/;"	f
sqlite3BtreeReleaseTempCursor	src/btree.c	/^void sqlite3BtreeReleaseTempCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeRestoreOrClearCursorPosition	src/btree.c	/^int sqlite3BtreeRestoreOrClearCursorPosition(BtCursor *pCur){$/;"	f
sqlite3BtreeRollback	src/btree.c	/^int sqlite3BtreeRollback(Btree *p){$/;"	f
sqlite3BtreeRollbackStmt	src/btree.c	/^int sqlite3BtreeRollbackStmt(Btree *p){$/;"	f
sqlite3BtreeSchema	src/btree.c	/^void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){$/;"	f
sqlite3BtreeSchemaLocked	src/btree.c	/^int sqlite3BtreeSchemaLocked(Btree *p){$/;"	f
sqlite3BtreeSetAutoVacuum	src/btree.c	/^int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){$/;"	f
sqlite3BtreeSetCacheSize	src/btree.c	/^int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){$/;"	f
sqlite3BtreeSetPageSize	src/btree.c	/^int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve){$/;"	f
sqlite3BtreeSetSafetyLevel	src/btree.c	/^int sqlite3BtreeSetSafetyLevel(Btree *p, int level, int fullSync){$/;"	f
sqlite3BtreeSharedCacheReport	src/test_btree.c	/^int sqlite3BtreeSharedCacheReport($/;"	f
sqlite3BtreeSyncDisabled	src/btree.c	/^int sqlite3BtreeSyncDisabled(Btree *p){$/;"	f
sqlite3BtreeTripAllCursors	src/btree.c	/^void sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode){$/;"	f
sqlite3BtreeUpdateMeta	src/btree.c	/^int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){$/;"	f
sqlite3ChangeCookie	src/build.c	/^void sqlite3ChangeCookie(Parse *pParse, int iDb){$/;"	f
sqlite3CheckCollSeq	src/callback.c	/^int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){$/;"	f
sqlite3CheckObjectName	src/build.c	/^int sqlite3CheckObjectName(Parse *pParse, const char *zName){$/;"	f
sqlite3CloseExtensions	src/loadext.c	/^void sqlite3CloseExtensions(sqlite3 *db){$/;"	f
sqlite3CloseExtensions	src/sqliteInt.h	1972;"	d
sqlite3CodeRowTrigger	src/sqliteInt.h	1854;"	d
sqlite3CodeRowTrigger	src/trigger.c	/^int sqlite3CodeRowTrigger($/;"	f
sqlite3CodeSubselect	src/expr.c	/^void sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3CodeVerifySchema	src/build.c	/^void sqlite3CodeVerifySchema(Parse *pParse, int iDb){$/;"	f
sqlite3ColumnDefault	src/update.c	/^void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i){$/;"	f
sqlite3CommitInternalChanges	src/build.c	/^void sqlite3CommitInternalChanges(sqlite3 *db){$/;"	f
sqlite3CommitTransaction	src/build.c	/^void sqlite3CommitTransaction(Parse *pParse){$/;"	f
sqlite3CompareAffinity	src/expr.c	/^char sqlite3CompareAffinity(Expr *pExpr, char aff2){$/;"	f
sqlite3CompleteInsertion	src/insert.c	/^void sqlite3CompleteInsertion($/;"	f
sqlite3Corrupt	src/main.c	/^int sqlite3Corrupt(void){$/;"	f
sqlite3CrashTestEnable	src/test6.c	/^static int sqlite3CrashTestEnable = 0;$/;"	v	file:
sqlite3CreateForeignKey	src/build.c	/^void sqlite3CreateForeignKey($/;"	f
sqlite3CreateFunc	src/main.c	/^int sqlite3CreateFunc($/;"	f
sqlite3CreateIdExpr	src/select.c	/^Expr *sqlite3CreateIdExpr(Parse *pParse, const char *zName){$/;"	f
sqlite3CreateIndex	src/build.c	/^void sqlite3CreateIndex($/;"	f
sqlite3CreateView	src/build.c	/^void sqlite3CreateView($/;"	f
sqlite3DbMallocRaw	src/malloc.c	/^void *sqlite3DbMallocRaw(sqlite3 *db, unsigned n){$/;"	f
sqlite3DbMallocZero	src/malloc.c	/^void *sqlite3DbMallocZero(sqlite3 *db, unsigned n){$/;"	f
sqlite3DbRealloc	src/malloc.c	/^void *sqlite3DbRealloc(sqlite3 *db, void *p, int n){$/;"	f
sqlite3DbReallocOrFree	src/malloc.c	/^void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, int n){$/;"	f
sqlite3DbStrDup	src/malloc.c	/^char *sqlite3DbStrDup(sqlite3 *db, const char *z){$/;"	f
sqlite3DbStrNDup	src/malloc.c	/^char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){$/;"	f
sqlite3DebugPrintf	src/printf.c	/^void sqlite3DebugPrintf(const char *zFormat, ...){$/;"	f
sqlite3DefaultRowEst	src/build.c	/^void sqlite3DefaultRowEst(Index *pIdx){$/;"	f
sqlite3DeferForeignKey	src/build.c	/^void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){$/;"	f
sqlite3DeleteFrom	src/delete.c	/^void sqlite3DeleteFrom($/;"	f
sqlite3DeleteTable	src/build.c	/^void sqlite3DeleteTable(Table *pTable){$/;"	f
sqlite3DeleteTrigger	src/sqliteInt.h	1851;"	d
sqlite3DeleteTrigger	src/trigger.c	/^void sqlite3DeleteTrigger(Trigger *pTrigger){$/;"	f
sqlite3DeleteTriggerStep	src/trigger.c	/^void sqlite3DeleteTriggerStep(TriggerStep *pTriggerStep){$/;"	f
sqlite3Dequote	src/util.c	/^void sqlite3Dequote(char *z){$/;"	f
sqlite3DequoteExpr	src/expr.c	/^void sqlite3DequoteExpr(sqlite3 *db, Expr *p){$/;"	f
sqlite3Detach	src/attach.c	/^void sqlite3Detach(Parse *pParse, Expr *pDbname){$/;"	f
sqlite3DetectLockingStyle	src/os_unix.c	/^static sqlite3LockingStyle sqlite3DetectLockingStyle($/;"	f	file:
sqlite3DotlockLockingUnixIoMethod	src/os_unix.c	/^static const sqlite3_io_methods sqlite3DotlockLockingUnixIoMethod = {$/;"	v	file:
sqlite3DropIndex	src/build.c	/^void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){$/;"	f
sqlite3DropTable	src/build.c	/^void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){$/;"	f
sqlite3DropTrigger	src/trigger.c	/^void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){$/;"	f
sqlite3DropTriggerPtr	src/sqliteInt.h	1852;"	d
sqlite3DropTriggerPtr	src/trigger.c	/^void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){$/;"	f
sqlite3EndTable	src/build.c	/^void sqlite3EndTable($/;"	f
sqlite3ErrStr	src/main.c	/^const char *sqlite3ErrStr(int rc){$/;"	f
sqlite3Error	src/util.c	/^void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...){$/;"	f
sqlite3ErrorClear	src/util.c	/^void sqlite3ErrorClear(Parse *pParse){$/;"	f
sqlite3ErrorMsg	src/util.c	/^void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3ExecFunc	src/test1.c	/^static void sqlite3ExecFunc($/;"	f	file:
sqlite3ExpirePreparedStatements	src/vdbeaux.c	/^void sqlite3ExpirePreparedStatements(sqlite3 *db){$/;"	f
sqlite3Expr	src/expr.c	/^Expr *sqlite3Expr($/;"	f
sqlite3ExprAffinity	src/expr.c	/^char sqlite3ExprAffinity(Expr *pExpr){$/;"	f
sqlite3ExprAnalyzeAggList	src/expr.c	/^void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){$/;"	f
sqlite3ExprAnalyzeAggregates	src/expr.c	/^void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){$/;"	f
sqlite3ExprAnd	src/expr.c	/^Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){$/;"	f
sqlite3ExprAssignVarNumber	src/expr.c	/^void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCode	src/expr.c	/^int sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeAndCache	src/expr.c	/^int sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeExprList	src/expr.c	/^int sqlite3ExprCodeExprList($/;"	f
sqlite3ExprCodeGetColumn	src/expr.c	/^void sqlite3ExprCodeGetColumn($/;"	f
sqlite3ExprCodeTarget	src/expr.c	/^static int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){$/;"	f	file:
sqlite3ExprCodeTemp	src/expr.c	/^int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){$/;"	f
sqlite3ExprCollSeq	src/expr.c	/^CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCompare	src/expr.c	/^int sqlite3ExprCompare(Expr *pA, Expr *pB){$/;"	f
sqlite3ExprDelete	src/expr.c	/^void sqlite3ExprDelete(Expr *p){$/;"	f
sqlite3ExprDup	src/expr.c	/^Expr *sqlite3ExprDup(sqlite3 *db, Expr *p){$/;"	f
sqlite3ExprFunction	src/expr.c	/^Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){$/;"	f
sqlite3ExprIfFalse	src/expr.c	/^void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIfTrue	src/expr.c	/^void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIsConstant	src/expr.c	/^int sqlite3ExprIsConstant(Expr *p){$/;"	f
sqlite3ExprIsConstantNotJoin	src/expr.c	/^int sqlite3ExprIsConstantNotJoin(Expr *p){$/;"	f
sqlite3ExprIsConstantOrFunction	src/expr.c	/^int sqlite3ExprIsConstantOrFunction(Expr *p){$/;"	f
sqlite3ExprIsInteger	src/expr.c	/^int sqlite3ExprIsInteger(Expr *p, int *pValue){$/;"	f
sqlite3ExprListAppend	src/expr.c	/^ExprList *sqlite3ExprListAppend($/;"	f
sqlite3ExprListCheckLength	src/expr.c	/^void sqlite3ExprListCheckLength($/;"	f
sqlite3ExprListDelete	src/expr.c	/^void sqlite3ExprListDelete(ExprList *pList){$/;"	f
sqlite3ExprListDup	src/expr.c	/^ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p){$/;"	f
sqlite3ExprResolveNames	src/expr.c	/^int sqlite3ExprResolveNames( $/;"	f
sqlite3ExprSetColl	src/expr.c	/^Expr *sqlite3ExprSetColl(Parse *pParse, Expr *pExpr, Token *pName){$/;"	f
sqlite3ExprSetHeight	src/expr.c	/^void sqlite3ExprSetHeight(Expr *p){$/;"	f
sqlite3ExprSetHeight	src/sqliteInt.h	2060;"	d
sqlite3ExprSpan	src/expr.c	/^void sqlite3ExprSpan(Expr *pExpr, Token *pLeft, Token *pRight){$/;"	f
sqlite3Fault	src/fault.c	/^static void sqlite3Fault(void){$/;"	f	file:
sqlite3FaultBenign	src/fault.c	/^void sqlite3FaultBenign(int id, int enable){$/;"	f
sqlite3FaultBenign	src/sqliteInt.h	2037;"	d
sqlite3FaultBenignFailures	src/fault.c	/^int sqlite3FaultBenignFailures(int id){$/;"	f
sqlite3FaultBenignFailures	src/sqliteInt.h	2035;"	d
sqlite3FaultConfig	src/fault.c	/^void sqlite3FaultConfig(int id, int nDelay, int nRepeat){$/;"	f
sqlite3FaultConfig	src/sqliteInt.h	2033;"	d
sqlite3FaultFailures	src/fault.c	/^int sqlite3FaultFailures(int id){$/;"	f
sqlite3FaultFailures	src/sqliteInt.h	2034;"	d
sqlite3FaultPending	src/fault.c	/^int sqlite3FaultPending(int id){$/;"	f
sqlite3FaultPending	src/sqliteInt.h	2036;"	d
sqlite3FaultStep	src/fault.c	/^int sqlite3FaultStep(int id){$/;"	f
sqlite3FaultStep	src/sqliteInt.h	2038;"	d
sqlite3FindCollSeq	src/callback.c	/^CollSeq *sqlite3FindCollSeq($/;"	f
sqlite3FindDb	src/build.c	/^int sqlite3FindDb(sqlite3 *db, Token *pName){$/;"	f
sqlite3FindFunction	src/callback.c	/^FuncDef *sqlite3FindFunction($/;"	f
sqlite3FindInIndex	src/expr.c	/^int sqlite3FindInIndex(Parse *pParse, Expr *pX, int mustBeUnique){$/;"	f
sqlite3FindIndex	src/build.c	/^Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){$/;"	f
sqlite3FindTable	src/build.c	/^Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){$/;"	f
sqlite3FinishCoding	src/build.c	/^void sqlite3FinishCoding(Parse *pParse){$/;"	f
sqlite3FinishTrigger	src/trigger.c	/^void sqlite3FinishTrigger($/;"	f
sqlite3FitsIn64Bits	src/util.c	/^int sqlite3FitsIn64Bits(const char *zNum, int negFlag){$/;"	f
sqlite3FixExpr	src/attach.c	/^int sqlite3FixExpr($/;"	f
sqlite3FixExprList	src/attach.c	/^int sqlite3FixExprList($/;"	f
sqlite3FixInit	src/attach.c	/^int sqlite3FixInit($/;"	f
sqlite3FixSelect	src/attach.c	/^int sqlite3FixSelect($/;"	f
sqlite3FixSrcList	src/attach.c	/^int sqlite3FixSrcList($/;"	f
sqlite3FixTriggerStep	src/attach.c	/^int sqlite3FixTriggerStep($/;"	f
sqlite3FlockLockingUnixIoMethod	src/os_unix.c	/^static const sqlite3_io_methods sqlite3FlockLockingUnixIoMethod = {$/;"	v	file:
sqlite3Fts1HashClear	ext/fts1/fts1_hash.c	/^void sqlite3Fts1HashClear(fts1Hash *pH){$/;"	f
sqlite3Fts1HashFind	ext/fts1/fts1_hash.c	/^void *sqlite3Fts1HashFind(const fts1Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts1HashInit	ext/fts1/fts1_hash.c	/^void sqlite3Fts1HashInit(fts1Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3Fts1HashInsert	ext/fts1/fts1_hash.c	/^void *sqlite3Fts1HashInsert($/;"	f
sqlite3Fts1Init	ext/fts1/fts1.c	/^int sqlite3Fts1Init(sqlite3 *db){$/;"	f
sqlite3Fts1PorterTokenizerModule	ext/fts1/fts1_porter.c	/^void sqlite3Fts1PorterTokenizerModule($/;"	f
sqlite3Fts1SimpleTokenizerModule	ext/fts1/fts1_tokenizer1.c	/^void sqlite3Fts1SimpleTokenizerModule($/;"	f
sqlite3Fts2HashClear	ext/fts2/fts2_hash.c	/^void sqlite3Fts2HashClear(fts2Hash *pH){$/;"	f
sqlite3Fts2HashFind	ext/fts2/fts2_hash.c	/^void *sqlite3Fts2HashFind(const fts2Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts2HashInit	ext/fts2/fts2_hash.c	/^void sqlite3Fts2HashInit(fts2Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3Fts2HashInsert	ext/fts2/fts2_hash.c	/^void *sqlite3Fts2HashInsert($/;"	f
sqlite3Fts2IcuTokenizerModule	ext/fts2/fts2_icu.c	/^void sqlite3Fts2IcuTokenizerModule($/;"	f
sqlite3Fts2Init	ext/fts2/fts2.c	/^int sqlite3Fts2Init(sqlite3 *db){$/;"	f
sqlite3Fts2InitHashTable	ext/fts2/fts2_tokenizer.c	/^int sqlite3Fts2InitHashTable($/;"	f
sqlite3Fts2PorterTokenizerModule	ext/fts2/fts2_porter.c	/^void sqlite3Fts2PorterTokenizerModule($/;"	f
sqlite3Fts2SimpleTokenizerModule	ext/fts2/fts2_tokenizer1.c	/^void sqlite3Fts2SimpleTokenizerModule($/;"	f
sqlite3Fts3HashClear	ext/fts3/fts3_hash.c	/^void sqlite3Fts3HashClear(fts3Hash *pH){$/;"	f
sqlite3Fts3HashFind	ext/fts3/fts3_hash.c	/^void *sqlite3Fts3HashFind(const fts3Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts3HashInit	ext/fts3/fts3_hash.c	/^void sqlite3Fts3HashInit(fts3Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3Fts3HashInsert	ext/fts3/fts3_hash.c	/^void *sqlite3Fts3HashInsert($/;"	f
sqlite3Fts3IcuTokenizerModule	ext/fts3/fts3_icu.c	/^void sqlite3Fts3IcuTokenizerModule($/;"	f
sqlite3Fts3Init	ext/fts3/fts3.c	/^int sqlite3Fts3Init(sqlite3 *db){$/;"	f
sqlite3Fts3InitHashTable	ext/fts3/fts3_tokenizer.c	/^int sqlite3Fts3InitHashTable($/;"	f
sqlite3Fts3PorterTokenizerModule	ext/fts3/fts3_porter.c	/^void sqlite3Fts3PorterTokenizerModule($/;"	f
sqlite3Fts3SimpleTokenizerModule	ext/fts3/fts3_tokenizer1.c	/^void sqlite3Fts3SimpleTokenizerModule($/;"	f
sqlite3GenerateConstraintChecks	src/insert.c	/^void sqlite3GenerateConstraintChecks($/;"	f
sqlite3GenerateIndexKey	src/delete.c	/^int sqlite3GenerateIndexKey($/;"	f
sqlite3GenerateRowDelete	src/delete.c	/^void sqlite3GenerateRowDelete($/;"	f
sqlite3GenerateRowIndexDelete	src/delete.c	/^void sqlite3GenerateRowIndexDelete($/;"	f
sqlite3Get4byte	src/util.c	/^u32 sqlite3Get4byte(const u8 *p){$/;"	f
sqlite3GetCollSeq	src/callback.c	/^CollSeq *sqlite3GetCollSeq($/;"	f
sqlite3GetFuncCollSeq	src/func.c	/^static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){$/;"	f	file:
sqlite3GetInt32	src/util.c	/^int sqlite3GetInt32(const char *zNum, int *pValue){$/;"	f
sqlite3GetInt64	src/test1.c	/^static int sqlite3GetInt64(const char *zNum, i64 *pValue){$/;"	f	file:
sqlite3GetTempRange	src/expr.c	/^int sqlite3GetTempRange(Parse *pParse, int nReg){$/;"	f
sqlite3GetTempReg	src/expr.c	/^int sqlite3GetTempReg(Parse *pParse){$/;"	f
sqlite3GetToken	src/tokenize.c	/^int sqlite3GetToken(const unsigned char *z, int *tokenType){$/;"	f
sqlite3GetVarint	src/util.c	/^int sqlite3GetVarint(const unsigned char *p, u64 *v){$/;"	f
sqlite3GetVarint32	src/util.c	/^int sqlite3GetVarint32(const unsigned char *p, u32 *v){$/;"	f
sqlite3GetVdbe	src/select.c	/^Vdbe *sqlite3GetVdbe(Parse *pParse){$/;"	f
sqlite3HashClear	src/hash.c	/^void sqlite3HashClear(Hash *pH){$/;"	f
sqlite3HashFind	src/hash.c	/^void *sqlite3HashFind(const Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3HashFindElem	src/hash.c	/^HashElem *sqlite3HashFindElem(const Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3HashInit	src/hash.c	/^void sqlite3HashInit(Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3HashInsert	src/hash.c	/^void *sqlite3HashInsert(Hash *pH, const void *pKey, int nKey, void *data){$/;"	f
sqlite3HexToBlob	src/util.c	/^void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){$/;"	f
sqlite3IcuInit	ext/icu/icu.c	/^int sqlite3IcuInit(sqlite3 *db){$/;"	f
sqlite3IdListAppend	src/build.c	/^IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){$/;"	f
sqlite3IdListDelete	src/build.c	/^void sqlite3IdListDelete(IdList *pList){$/;"	f
sqlite3IdListDup	src/expr.c	/^IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){$/;"	f
sqlite3IdListIndex	src/build.c	/^int sqlite3IdListIndex(IdList *pList, const char *zName){$/;"	f
sqlite3IndexAffinityOk	src/expr.c	/^int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){$/;"	f
sqlite3IndexAffinityStr	src/insert.c	/^void sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){$/;"	f
sqlite3IndexKeyinfo	src/build.c	/^KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){$/;"	f
sqlite3Init	src/prepare.c	/^int sqlite3Init(sqlite3 *db, char **pzErrMsg){$/;"	f
sqlite3InitCallback	src/prepare.c	/^int sqlite3InitCallback(void *pInit, int argc, char **argv, char **azColName){$/;"	f
sqlite3InitInfo	src/sqliteInt.h	/^  struct sqlite3InitInfo {      \/* Information used during initialization *\/$/;"	s	struct:sqlite3
sqlite3InitOne	src/prepare.c	/^static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){$/;"	f	file:
sqlite3Insert	src/insert.c	/^void sqlite3Insert($/;"	f
sqlite3InvalidFunction	src/vdbeapi.c	/^void sqlite3InvalidFunction($/;"	f
sqlite3InvokeBusyHandler	src/main.c	/^int sqlite3InvokeBusyHandler(BusyHandler *p){$/;"	f
sqlite3IsAsciiIdChar	src/tokenize.c	/^const char sqlite3IsAsciiIdChar[] = {$/;"	v
sqlite3IsEbcdicIdChar	src/tokenize.c	/^const char sqlite3IsEbcdicIdChar[] = {$/;"	v
sqlite3IsLikeFunction	src/func.c	/^int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){$/;"	f
sqlite3IsNumber	src/util.c	/^int sqlite3IsNumber(const char *z, int *realnum, u8 enc){$/;"	f
sqlite3IsNumericAffinity	src/sqliteInt.h	716;"	d
sqlite3IsReadOnly	src/delete.c	/^int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){$/;"	f
sqlite3IsRowid	src/expr.c	/^int sqlite3IsRowid(const char *z){$/;"	f
sqlite3JoinType	src/select.c	/^int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){$/;"	f
sqlite3JournalCreate	src/journal.c	/^int sqlite3JournalCreate(sqlite3_file *p){$/;"	f
sqlite3JournalOpen	src/journal.c	/^int sqlite3JournalOpen($/;"	f
sqlite3JournalSize	src/journal.c	/^int sqlite3JournalSize(sqlite3_vfs *pVfs){$/;"	f
sqlite3JournalSize	src/sqliteInt.h	2053;"	d
sqlite3KeywordCode	keywordhash.h	/^int sqlite3KeywordCode(const unsigned char *z, int n){$/;"	f
sqlite3LoadExtension	src/loadext.c	/^static int sqlite3LoadExtension($/;"	f	file:
sqlite3LocateCollSeq	src/build.c	/^CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName, int nName){$/;"	f
sqlite3LocateTable	src/build.c	/^Table *sqlite3LocateTable($/;"	f
sqlite3LockAndPrepare	src/prepare.c	/^static int sqlite3LockAndPrepare($/;"	f	file:
sqlite3LockingStyle	src/os_unix.c	/^} sqlite3LockingStyle;$/;"	t	typeref:enum:__anon15	file:
sqlite3LruPageList	src/pager.c	/^static PagerLruList sqlite3LruPageList = {0, 0, 0};$/;"	v	file:
sqlite3MAX_COLUMN	src/test_config.c	/^int sqlite3MAX_COLUMN = SQLITE_MAX_COLUMN;$/;"	v
sqlite3MAX_COMPOUND_SELECT	src/test_config.c	/^int sqlite3MAX_COMPOUND_SELECT = SQLITE_MAX_COMPOUND_SELECT;$/;"	v
sqlite3MAX_EXPR_DEPTH	src/test_config.c	/^int sqlite3MAX_EXPR_DEPTH = SQLITE_MAX_EXPR_DEPTH;$/;"	v
sqlite3MAX_FUNCTION_ARG	src/test_config.c	/^int sqlite3MAX_FUNCTION_ARG = SQLITE_MAX_FUNCTION_ARG;$/;"	v
sqlite3MAX_LENGTH	src/test_config.c	/^int sqlite3MAX_LENGTH = SQLITE_MAX_LENGTH;$/;"	v
sqlite3MAX_LIKE_PATTERN_LENGTH	src/test_config.c	/^int sqlite3MAX_LIKE_PATTERN_LENGTH = SQLITE_MAX_LIKE_PATTERN_LENGTH;$/;"	v
sqlite3MAX_PAGE_COUNT	src/test_config.c	/^int sqlite3MAX_PAGE_COUNT = SQLITE_MAX_PAGE_COUNT;$/;"	v
sqlite3MAX_PAGE_SIZE	src/test_config.c	/^int sqlite3MAX_PAGE_SIZE = SQLITE_MAX_PAGE_SIZE;$/;"	v
sqlite3MAX_SQL_LENGTH	src/test_config.c	/^int sqlite3MAX_SQL_LENGTH = SQLITE_MAX_SQL_LENGTH;$/;"	v
sqlite3MAX_VARIABLE_NUMBER	src/test_config.c	/^int sqlite3MAX_VARIABLE_NUMBER = SQLITE_MAX_VARIABLE_NUMBER;$/;"	v
sqlite3MAX_VDBE_OP	src/test_config.c	/^int sqlite3MAX_VDBE_OP = SQLITE_MAX_VDBE_OP;$/;"	v
sqlite3MPrintf	src/printf.c	/^char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){$/;"	f
sqlite3MallocZero	src/malloc.c	/^void *sqlite3MallocZero(unsigned n){$/;"	f
sqlite3MemCompare	src/vdbemem.c	/^int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){$/;"	f
sqlite3MemsysAlarm	src/mem1.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysAlarm	src/mem2.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysAlarm	src/mem4.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysGetHeader	src/mem2.c	/^static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){$/;"	f	file:
sqlite3MinimumFileFormat	src/build.c	/^void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){$/;"	f
sqlite3NameFromToken	src/build.c	/^char *sqlite3NameFromToken(sqlite3 *db, Token *pName){$/;"	f
sqlite3NestedParse	src/build.c	/^void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3NolockLockingUnixIoMethod	src/os_unix.c	/^static const sqlite3_io_methods sqlite3NolockLockingUnixIoMethod = {$/;"	v	file:
sqlite3One	src/sqliteInt.h	/^const int sqlite3One;$/;"	v
sqlite3OpcodeName	opcodes.c	/^const char *sqlite3OpcodeName(int i){$/;"	f
sqlite3OpenMasterTable	src/build.c	/^void sqlite3OpenMasterTable(Parse *p, int iDb){$/;"	f
sqlite3OpenTable	src/delete.c	/^void sqlite3OpenTable($/;"	f
sqlite3OpenTableAndIndices	src/insert.c	/^int sqlite3OpenTableAndIndices($/;"	f
sqlite3OpenTempDatabase	src/build.c	/^int sqlite3OpenTempDatabase(Parse *pParse){$/;"	f
sqlite3OsAccess	src/os.c	/^int sqlite3OsAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f
sqlite3OsCheckReservedLock	src/os.c	/^int sqlite3OsCheckReservedLock(sqlite3_file *id){$/;"	f
sqlite3OsClose	src/os.c	/^int sqlite3OsClose(sqlite3_file *pId){$/;"	f
sqlite3OsCloseFree	src/os.c	/^int sqlite3OsCloseFree(sqlite3_file *pFile){$/;"	f
sqlite3OsCurrentTime	src/os.c	/^int sqlite3OsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f
sqlite3OsDefaultVfs	src/os.h	272;"	d
sqlite3OsDefaultVfs	src/os_os2.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDefaultVfs	src/os_unix.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDefaultVfs	src/os_win.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDelete	src/os.c	/^int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f
sqlite3OsDeviceCharacteristics	src/os.c	/^int sqlite3OsDeviceCharacteristics(sqlite3_file *id){$/;"	f
sqlite3OsDlClose	src/os.c	/^void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
sqlite3OsDlError	src/os.c	/^void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsDlOpen	src/os.c	/^void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f
sqlite3OsDlSym	src/os.c	/^void *sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
sqlite3OsFileControl	src/os.c	/^int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f
sqlite3OsFileSize	src/os.c	/^int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){$/;"	f
sqlite3OsFullPathname	src/os.c	/^int sqlite3OsFullPathname($/;"	f
sqlite3OsGetTempname	src/os.c	/^int sqlite3OsGetTempname(sqlite3_vfs *pVfs, int nBufOut, char *zBufOut){$/;"	f
sqlite3OsLock	src/os.c	/^int sqlite3OsLock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsOpen	src/os.c	/^int sqlite3OsOpen($/;"	f
sqlite3OsOpenMalloc	src/os.c	/^int sqlite3OsOpenMalloc($/;"	f
sqlite3OsRandomness	src/os.c	/^int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsRead	src/os.c	/^int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){$/;"	f
sqlite3OsSectorSize	src/os.c	/^int sqlite3OsSectorSize(sqlite3_file *id){$/;"	f
sqlite3OsSleep	src/os.c	/^int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f
sqlite3OsSync	src/os.c	/^int sqlite3OsSync(sqlite3_file *id, int flags){$/;"	f
sqlite3OsTruncate	src/os.c	/^int sqlite3OsTruncate(sqlite3_file *id, i64 size){$/;"	f
sqlite3OsUnlock	src/os.c	/^int sqlite3OsUnlock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsWrite	src/os.c	/^int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){$/;"	f
sqlite3PExpr	src/expr.c	/^Expr *sqlite3PExpr($/;"	f
sqlite3PagerAcquire	src/pager.c	/^int sqlite3PagerAcquire($/;"	f
sqlite3PagerBegin	src/pager.c	/^int sqlite3PagerBegin(DbPage *pPg, int exFlag){$/;"	f
sqlite3PagerClose	src/pager.c	/^int sqlite3PagerClose(Pager *pPager){$/;"	f
sqlite3PagerCommitPhaseOne	src/pager.c	/^int sqlite3PagerCommitPhaseOne(Pager *pPager, const char *zMaster, Pgno nTrunc){$/;"	f
sqlite3PagerCommitPhaseTwo	src/pager.c	/^int sqlite3PagerCommitPhaseTwo(Pager *pPager){$/;"	f
sqlite3PagerDirname	src/pager.c	/^const char *sqlite3PagerDirname(Pager *pPager){$/;"	f
sqlite3PagerDontRollback	src/pager.c	/^void sqlite3PagerDontRollback(DbPage *pPg){$/;"	f
sqlite3PagerDontWrite	src/pager.c	/^void sqlite3PagerDontWrite(DbPage *pDbPage){$/;"	f
sqlite3PagerFile	src/pager.c	/^sqlite3_file *sqlite3PagerFile(Pager *pPager){$/;"	f
sqlite3PagerFilename	src/pager.c	/^const char *sqlite3PagerFilename(Pager *pPager){$/;"	f
sqlite3PagerGet	src/pager.h	67;"	d
sqlite3PagerGetData	src/pager.c	/^void *sqlite3PagerGetData(DbPage *pPg){$/;"	f
sqlite3PagerGetExtra	src/pager.c	/^void *sqlite3PagerGetExtra(DbPage *pPg){$/;"	f
sqlite3PagerIsreadonly	src/pager.c	/^int sqlite3PagerIsreadonly(Pager *pPager){$/;"	f
sqlite3PagerIswriteable	src/pager.c	/^int sqlite3PagerIswriteable(DbPage *pPg){$/;"	f
sqlite3PagerJournalname	src/pager.c	/^const char *sqlite3PagerJournalname(Pager *pPager){$/;"	f
sqlite3PagerList	src/pager.c	/^static Pager *sqlite3PagerList = 0;$/;"	v	file:
sqlite3PagerLockingMode	src/pager.c	/^int sqlite3PagerLockingMode(Pager *pPager, int eMode){$/;"	f
sqlite3PagerLookup	src/pager.c	/^DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){$/;"	f
sqlite3PagerMaxPageCount	src/pager.c	/^int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerMovepage	src/pager.c	/^int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno){$/;"	f
sqlite3PagerNosync	src/pager.c	/^int sqlite3PagerNosync(Pager *pPager){$/;"	f
sqlite3PagerOpen	src/pager.c	/^int sqlite3PagerOpen($/;"	f
sqlite3PagerOpentemp	src/pager.c	/^static int sqlite3PagerOpentemp($/;"	f	file:
sqlite3PagerOverwrite	src/pager.c	/^int sqlite3PagerOverwrite(Pager *pPager, Pgno pgno, void *pData){$/;"	f
sqlite3PagerPagecount	src/pager.c	/^int sqlite3PagerPagecount(Pager *pPager){$/;"	f
sqlite3PagerPagenumber	src/pager.c	/^Pgno sqlite3PagerPagenumber(DbPage *p){$/;"	f
sqlite3PagerReadFileheader	src/pager.c	/^int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){$/;"	f
sqlite3PagerRef	src/pager.c	/^int sqlite3PagerRef(DbPage *pPg){$/;"	f
sqlite3PagerRefcount	src/pager.c	/^int sqlite3PagerRefcount(Pager *pPager){$/;"	f
sqlite3PagerRefdump	src/pager.c	/^void sqlite3PagerRefdump(Pager *pPager){$/;"	f
sqlite3PagerReleaseMemory	src/pager.c	/^int sqlite3PagerReleaseMemory(int nReq){$/;"	f
sqlite3PagerRollback	src/pager.c	/^int sqlite3PagerRollback(Pager *pPager){$/;"	f
sqlite3PagerSetBusyhandler	src/pager.c	/^void sqlite3PagerSetBusyhandler(Pager *pPager, BusyHandler *pBusyHandler){$/;"	f
sqlite3PagerSetCachesize	src/pager.c	/^void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerSetCodec	src/pager.c	/^void sqlite3PagerSetCodec($/;"	f
sqlite3PagerSetDestructor	src/pager.c	/^void sqlite3PagerSetDestructor(Pager *pPager, void (*xDesc)(DbPage*,int)){$/;"	f
sqlite3PagerSetPagesize	src/pager.c	/^int sqlite3PagerSetPagesize(Pager *pPager, u16 *pPageSize){$/;"	f
sqlite3PagerSetReiniter	src/pager.c	/^void sqlite3PagerSetReiniter(Pager *pPager, void (*xReinit)(DbPage*,int)){$/;"	f
sqlite3PagerSetSafetyLevel	src/pager.c	/^void sqlite3PagerSetSafetyLevel(Pager *pPager, int level, int full_fsync){$/;"	f
sqlite3PagerStats	src/pager.c	/^int *sqlite3PagerStats(Pager *pPager){$/;"	f
sqlite3PagerStmtBegin	src/pager.c	/^int sqlite3PagerStmtBegin(Pager *pPager){$/;"	f
sqlite3PagerStmtCommit	src/pager.c	/^int sqlite3PagerStmtCommit(Pager *pPager){$/;"	f
sqlite3PagerStmtRollback	src/pager.c	/^int sqlite3PagerStmtRollback(Pager *pPager){$/;"	f
sqlite3PagerTempSpace	src/pager.c	/^void *sqlite3PagerTempSpace(Pager *pPager){$/;"	f
sqlite3PagerTruncate	src/pager.c	/^int sqlite3PagerTruncate(Pager *pPager, Pgno nPage){$/;"	f
sqlite3PagerUnref	src/pager.c	/^int sqlite3PagerUnref(DbPage *pPg){$/;"	f
sqlite3PagerVfs	src/pager.c	/^const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){$/;"	f
sqlite3PagerWrite	src/pager.c	/^int sqlite3PagerWrite(DbPage *pDbPage){$/;"	f
sqlite3Parser	parse.c	/^void sqlite3Parser($/;"	f
sqlite3ParserARG_FETCH	parse.c	120;"	d	file:
sqlite3ParserARG_PDECL	parse.c	119;"	d	file:
sqlite3ParserARG_SDECL	parse.c	118;"	d	file:
sqlite3ParserARG_STORE	parse.c	121;"	d	file:
sqlite3ParserAlloc	parse.c	/^void *sqlite3ParserAlloc(void *(*mallocProc)(size_t)){$/;"	f
sqlite3ParserFree	parse.c	/^void sqlite3ParserFree($/;"	f
sqlite3ParserTOKENTYPE	parse.c	99;"	d	file:
sqlite3ParserTrace	parse.c	/^void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
sqlite3Pragma	src/pragma.c	/^void sqlite3Pragma($/;"	f
sqlite3Prepare	src/prepare.c	/^int sqlite3Prepare($/;"	f
sqlite3Prepare16	src/prepare.c	/^static int sqlite3Prepare16($/;"	f	file:
sqlite3PrintExpr	src/select.c	/^void sqlite3PrintExpr(Expr *p){$/;"	f
sqlite3PrintExprList	src/select.c	/^void sqlite3PrintExprList(ExprList *pList){$/;"	f
sqlite3PrintSelect	src/select.c	/^void sqlite3PrintSelect(Select *p, int indent){$/;"	f
sqlite3Prng	src/random.c	/^} sqlite3Prng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3PrngType	src/random.c	/^static struct sqlite3PrngType {$/;"	s	file:
sqlite3Put4byte	src/util.c	/^void sqlite3Put4byte(unsigned char *p, u32 v){$/;"	f
sqlite3PutVarint	src/util.c	/^int sqlite3PutVarint(unsigned char *p, u64 v){$/;"	f
sqlite3Randomness	src/random.c	/^void sqlite3Randomness(int N, void *pBuf){$/;"	f
sqlite3ReadSchema	src/prepare.c	/^int sqlite3ReadSchema(Parse *pParse){$/;"	f
sqlite3RefillIndex	src/build.c	/^static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){$/;"	f	file:
sqlite3RegisterBuiltinFunctions	src/func.c	/^void sqlite3RegisterBuiltinFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterDateTimeFunctions	src/date.c	/^void sqlite3RegisterDateTimeFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterExpr	src/expr.c	/^Expr *sqlite3RegisterExpr(Parse *pParse, Token *pToken){$/;"	f
sqlite3RegisterLikeFunctions	src/func.c	/^void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){$/;"	f
sqlite3Reindex	src/build.c	/^void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ReleaseTempRange	src/expr.c	/^void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){$/;"	f
sqlite3ReleaseTempReg	src/expr.c	/^void sqlite3ReleaseTempReg(Parse *pParse, int iReg){$/;"	f
sqlite3Reprepare	src/prepare.c	/^int sqlite3Reprepare(Vdbe *p){$/;"	f
sqlite3ResetInternalSchema	src/build.c	/^void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){$/;"	f
sqlite3ResetPrngState	src/random.c	/^void sqlite3ResetPrngState(void){$/;"	f
sqlite3RestorePrngState	src/random.c	/^void sqlite3RestorePrngState(void){$/;"	f
sqlite3ResultSetOfSelect	src/select.c	/^Table *sqlite3ResultSetOfSelect(Parse *pParse, char *zTabName, Select *pSelect){$/;"	f
sqlite3RollbackAll	src/main.c	/^void sqlite3RollbackAll(sqlite3 *db){$/;"	f
sqlite3RollbackTransaction	src/build.c	/^void sqlite3RollbackTransaction(Parse *pParse){$/;"	f
sqlite3RootPageMoved	src/build.c	/^void sqlite3RootPageMoved(Db *pDb, int iFrom, int iTo){$/;"	f
sqlite3RunParser	src/tokenize.c	/^int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){$/;"	f
sqlite3RunVacuum	src/vacuum.c	/^int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){$/;"	f
sqlite3SafetyCheckOk	src/util.c	/^int sqlite3SafetyCheckOk(sqlite3 *db){$/;"	f
sqlite3SafetyCheckSickOrOk	src/util.c	/^int sqlite3SafetyCheckSickOrOk(sqlite3 *db){$/;"	f
sqlite3SafetyOff	src/sqliteInt.h	1825;"	d
sqlite3SafetyOff	src/util.c	/^int sqlite3SafetyOff(sqlite3 *db){$/;"	f
sqlite3SafetyOn	src/sqliteInt.h	1824;"	d
sqlite3SafetyOn	src/util.c	/^int sqlite3SafetyOn(sqlite3 *db){$/;"	f
sqlite3SavePrngState	src/random.c	/^void sqlite3SavePrngState(void){$/;"	f
sqlite3SavedPrng	src/random.c	/^static struct sqlite3PrngType sqlite3SavedPrng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3SchemaFree	src/callback.c	/^void sqlite3SchemaFree(void *p){$/;"	f
sqlite3SchemaGet	src/callback.c	/^Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){$/;"	f
sqlite3SchemaToIndex	src/prepare.c	/^int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){$/;"	f
sqlite3Select	src/select.c	/^int sqlite3Select($/;"	f
sqlite3SelectDelete	src/select.c	/^void sqlite3SelectDelete(Select *p){$/;"	f
sqlite3SelectDestInit	src/select.c	/^void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){$/;"	f
sqlite3SelectDup	src/expr.c	/^Select *sqlite3SelectDup(sqlite3 *db, Select *p){$/;"	f
sqlite3SelectExprHeight	src/expr.c	/^int sqlite3SelectExprHeight(Select *p){$/;"	f
sqlite3SelectMask	src/select.c	/^void sqlite3SelectMask(Parse *pParse, Select *p, u32 mask){$/;"	f
sqlite3SelectNew	src/select.c	/^Select *sqlite3SelectNew($/;"	f
sqlite3SelectResolve	src/select.c	/^int sqlite3SelectResolve($/;"	f
sqlite3SetString	src/malloc.c	/^void sqlite3SetString(char **pz, ...){$/;"	f
sqlite3SharedCacheEnabled	src/btree.c	/^int sqlite3SharedCacheEnabled = 0;$/;"	v
sqlite3SharedCacheEnabled	src/btree.c	/^static int sqlite3SharedCacheEnabled = 0;$/;"	v	file:
sqlite3SharedCacheList	src/btree.c	/^BtShared *sqlite3SharedCacheList = 0;$/;"	v
sqlite3SharedCacheList	src/btree.c	/^static BtShared *sqlite3SharedCacheList = 0;$/;"	v	file:
sqlite3SrcListAppend	src/build.c	/^SrcList *sqlite3SrcListAppend($/;"	f
sqlite3SrcListAppendFromTerm	src/build.c	/^SrcList *sqlite3SrcListAppendFromTerm($/;"	f
sqlite3SrcListAssignCursors	src/build.c	/^void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){$/;"	f
sqlite3SrcListDelete	src/build.c	/^void sqlite3SrcListDelete(SrcList *pList){$/;"	f
sqlite3SrcListDup	src/expr.c	/^SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p){$/;"	f
sqlite3SrcListLookup	src/delete.c	/^Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3SrcListShiftJoinType	src/build.c	/^void sqlite3SrcListShiftJoinType(SrcList *p){$/;"	f
sqlite3StackDepth	src/test1.c	/^u64 sqlite3StackDepth(void){$/;"	f
sqlite3StartTable	src/build.c	/^void sqlite3StartTable($/;"	f
sqlite3Step	src/vdbeapi.c	/^static int sqlite3Step(Vdbe *p){$/;"	f	file:
sqlite3StrAccumAppend	src/printf.c	/^void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){$/;"	f
sqlite3StrAccumFinish	src/printf.c	/^char *sqlite3StrAccumFinish(StrAccum *p){$/;"	f
sqlite3StrAccumInit	src/printf.c	/^static void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n){$/;"	f	file:
sqlite3StrAccumReset	src/printf.c	/^void sqlite3StrAccumReset(StrAccum *p){$/;"	f
sqlite3StrDup	src/malloc.c	/^char *sqlite3StrDup(const char *z){$/;"	f
sqlite3StrICmp	src/util.c	/^int sqlite3StrICmp(const char *zLeft, const char *zRight){$/;"	f
sqlite3StrNDup	src/malloc.c	/^char *sqlite3StrNDup(const char *z, int n){$/;"	f
sqlite3StrNICmp	src/util.c	/^int sqlite3StrNICmp(const char *zLeft, const char *zRight, int N){$/;"	f
sqlite3TableAffinityStr	src/insert.c	/^void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){$/;"	f
sqlite3TableLock	src/build.c	/^void sqlite3TableLock($/;"	f
sqlite3TableLock	src/sqliteInt.h	1979;"	d
sqlite3TestBinToHex	src/test_hexio.c	/^void sqlite3TestBinToHex(unsigned char *zBuf, int N){$/;"	f
sqlite3TestErrCode	src/test1.c	/^int sqlite3TestErrCode(Tcl_Interp *interp, sqlite3 *db, int rc){$/;"	f
sqlite3TestErrorName	src/test1.c	/^const char *sqlite3TestErrorName(int rc){$/;"	f
sqlite3TestHexToBin	src/test_hexio.c	/^int sqlite3TestHexToBin(const unsigned char *zIn, int N, unsigned char *aOut){$/;"	f
sqlite3TestLockingStyle	src/os_unix.c	/^static sqlite3LockingStyle sqlite3TestLockingStyle($/;"	f	file:
sqlite3TestMakePointerStr	src/test1.c	/^int sqlite3TestMakePointerStr(Tcl_Interp *interp, char *zPtr, void *p){$/;"	f
sqlite3TextToPtr	src/test1.c	/^void *sqlite3TextToPtr(const char *z){$/;"	f
sqlite3TokenCopy	src/expr.c	/^void sqlite3TokenCopy(sqlite3 *db, Token *pTo, Token *pFrom){$/;"	f
sqlite3TriggerDeleteStep	src/trigger.c	/^TriggerStep *sqlite3TriggerDeleteStep($/;"	f
sqlite3TriggerInsertStep	src/trigger.c	/^TriggerStep *sqlite3TriggerInsertStep($/;"	f
sqlite3TriggerSelectStep	src/trigger.c	/^TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){$/;"	f
sqlite3TriggerUpdateStep	src/trigger.c	/^TriggerStep *sqlite3TriggerUpdateStep($/;"	f
sqlite3TriggersExist	src/sqliteInt.h	1850;"	d
sqlite3TriggersExist	src/trigger.c	/^int sqlite3TriggersExist($/;"	f
sqlite3TwoPartName	src/build.c	/^int sqlite3TwoPartName($/;"	f
sqlite3UnixIoMethod	src/os_unix.c	/^static const sqlite3_io_methods sqlite3UnixIoMethod = {$/;"	v	file:
sqlite3UnlinkAndDeleteIndex	src/build.c	/^void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){$/;"	f
sqlite3UnlinkAndDeleteTable	src/build.c	/^void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){$/;"	f
sqlite3UnlinkAndDeleteTrigger	src/sqliteInt.h	1853;"	d
sqlite3UnlinkAndDeleteTrigger	src/trigger.c	/^void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){$/;"	f
sqlite3Update	src/update.c	/^void sqlite3Update($/;"	f
sqlite3UpperToLower	src/util.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3UpperToLower	tool/mkkeywordhash.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3Utf16ByteLen	src/utf.c	/^int sqlite3Utf16ByteLen(const void *zIn, int nChar){$/;"	f
sqlite3Utf16to8	src/utf.c	/^char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte){$/;"	f
sqlite3Utf8CharLen	src/utf.c	/^int sqlite3Utf8CharLen(const char *zIn, int nByte){$/;"	f
sqlite3Utf8Read	src/func.c	415;"	d	file:
sqlite3Utf8Read	src/utf.c	/^int sqlite3Utf8Read($/;"	f
sqlite3Utf8To8	src/utf.c	/^int sqlite3Utf8To8(unsigned char *zIn){$/;"	f
sqlite3UtfSelfTest	src/utf.c	/^void sqlite3UtfSelfTest(){$/;"	f
sqlite3UtfTrans1	src/utf.c	/^static const unsigned char sqlite3UtfTrans1[] = {$/;"	v	file:
sqlite3VMPrintf	src/printf.c	/^char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){$/;"	f
sqlite3Vacuum	src/vacuum.c	/^void sqlite3Vacuum(Parse *pParse){$/;"	f
sqlite3ValueApplyAffinity	src/vdbe.c	/^void sqlite3ValueApplyAffinity($/;"	f
sqlite3ValueBytes	src/vdbemem.c	/^int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){$/;"	f
sqlite3ValueFree	src/vdbemem.c	/^void sqlite3ValueFree(sqlite3_value *v){$/;"	f
sqlite3ValueFromExpr	src/vdbemem.c	/^int sqlite3ValueFromExpr($/;"	f
sqlite3ValueNew	src/vdbemem.c	/^sqlite3_value *sqlite3ValueNew(sqlite3 *db){$/;"	f
sqlite3ValueSetStr	src/vdbemem.c	/^void sqlite3ValueSetStr($/;"	f
sqlite3ValueText	src/vdbemem.c	/^const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){$/;"	f
sqlite3VarintLen	src/util.c	/^int sqlite3VarintLen(u64 v){$/;"	f
sqlite3VdbeAddOp0	src/vdbeaux.c	/^int sqlite3VdbeAddOp0(Vdbe *p, int op){$/;"	f
sqlite3VdbeAddOp1	src/vdbeaux.c	/^int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){$/;"	f
sqlite3VdbeAddOp2	src/vdbeaux.c	/^int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){$/;"	f
sqlite3VdbeAddOp3	src/vdbeaux.c	/^int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){$/;"	f
sqlite3VdbeAddOp4	src/vdbeaux.c	/^int sqlite3VdbeAddOp4($/;"	f
sqlite3VdbeAddOpList	src/vdbeaux.c	/^int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){$/;"	f
sqlite3VdbeChangeEncoding	src/vdbemem.c	/^int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){$/;"	f
sqlite3VdbeChangeP1	src/vdbeaux.c	/^void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP2	src/vdbeaux.c	/^void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP3	src/vdbeaux.c	/^void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP4	src/vdbeaux.c	/^void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){$/;"	f
sqlite3VdbeChangeP5	src/vdbeaux.c	/^void sqlite3VdbeChangeP5(Vdbe *p, u8 val){$/;"	f
sqlite3VdbeChangeToNoop	src/vdbeaux.c	/^void sqlite3VdbeChangeToNoop(Vdbe *p, int addr, int N){$/;"	f
sqlite3VdbeComment	src/vdbeaux.c	/^void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeCountChanges	src/vdbeaux.c	/^void sqlite3VdbeCountChanges(Vdbe *v){$/;"	f
sqlite3VdbeCreate	src/vdbeaux.c	/^Vdbe *sqlite3VdbeCreate(sqlite3 *db){$/;"	f
sqlite3VdbeCurrentAddr	src/vdbeaux.c	/^int sqlite3VdbeCurrentAddr(Vdbe *p){$/;"	f
sqlite3VdbeCursorMoveto	src/vdbeaux.c	/^int sqlite3VdbeCursorMoveto(Cursor *p){$/;"	f
sqlite3VdbeDb	src/vdbeaux.c	/^sqlite3 *sqlite3VdbeDb(Vdbe *v){$/;"	f
sqlite3VdbeDelete	src/vdbeaux.c	/^void sqlite3VdbeDelete(Vdbe *p){$/;"	f
sqlite3VdbeDeleteAuxData	src/vdbeaux.c	/^void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){$/;"	f
sqlite3VdbeExec	src/vdbe.c	/^int sqlite3VdbeExec($/;"	f
sqlite3VdbeFifoClear	src/vdbefifo.c	/^void sqlite3VdbeFifoClear(Fifo *pFifo){$/;"	f
sqlite3VdbeFifoInit	src/vdbefifo.c	/^void sqlite3VdbeFifoInit(Fifo *pFifo){$/;"	f
sqlite3VdbeFifoPop	src/vdbefifo.c	/^int sqlite3VdbeFifoPop(Fifo *pFifo, i64 *pVal){$/;"	f
sqlite3VdbeFifoPush	src/vdbefifo.c	/^int sqlite3VdbeFifoPush(Fifo *pFifo, i64 val){$/;"	f
sqlite3VdbeFinalize	src/vdbeaux.c	/^int sqlite3VdbeFinalize(Vdbe *p){$/;"	f
sqlite3VdbeFreeCursor	src/vdbeaux.c	/^void sqlite3VdbeFreeCursor(Vdbe *p, Cursor *pCx){$/;"	f
sqlite3VdbeGetOp	src/vdbeaux.c	/^VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){$/;"	f
sqlite3VdbeHalt	src/vdbeaux.c	/^int sqlite3VdbeHalt(Vdbe *p){$/;"	f
sqlite3VdbeIOTraceSql	src/sqliteInt.h	2084;"	d
sqlite3VdbeIOTraceSql	src/vdbeaux.c	/^void sqlite3VdbeIOTraceSql(Vdbe *p){$/;"	f
sqlite3VdbeIdxKeyCompare	src/vdbeaux.c	/^int sqlite3VdbeIdxKeyCompare($/;"	f
sqlite3VdbeIdxRowid	src/vdbeaux.c	/^int sqlite3VdbeIdxRowid(BtCursor *pCur, i64 *rowid){$/;"	f
sqlite3VdbeIdxRowidLen	src/vdbeaux.c	/^int sqlite3VdbeIdxRowidLen(const u8 *aKey){$/;"	f
sqlite3VdbeIntValue	src/vdbemem.c	/^i64 sqlite3VdbeIntValue(Mem *pMem){$/;"	f
sqlite3VdbeIntegerAffinity	src/vdbemem.c	/^void sqlite3VdbeIntegerAffinity(Mem *pMem){$/;"	f
sqlite3VdbeJumpHere	src/vdbeaux.c	/^void sqlite3VdbeJumpHere(Vdbe *p, int addr){$/;"	f
sqlite3VdbeList	src/vdbeaux.c	/^int sqlite3VdbeList($/;"	f
sqlite3VdbeMakeLabel	src/vdbeaux.c	/^int sqlite3VdbeMakeLabel(Vdbe *p){$/;"	f
sqlite3VdbeMakeReady	src/vdbeaux.c	/^void sqlite3VdbeMakeReady($/;"	f
sqlite3VdbeMemCopy	src/vdbemem.c	/^int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){$/;"	f
sqlite3VdbeMemDynamicify	src/vdbemem.c	/^int sqlite3VdbeMemDynamicify(Mem *pMem){$/;"	f
sqlite3VdbeMemExpandBlob	src/vdbeInt.h	419;"	d
sqlite3VdbeMemExpandBlob	src/vdbemem.c	/^int sqlite3VdbeMemExpandBlob(Mem *pMem){$/;"	f
sqlite3VdbeMemFinalize	src/vdbemem.c	/^int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){$/;"	f
sqlite3VdbeMemFromBtree	src/vdbemem.c	/^int sqlite3VdbeMemFromBtree($/;"	f
sqlite3VdbeMemHandleBom	src/utf.c	/^int sqlite3VdbeMemHandleBom(Mem *pMem){$/;"	f
sqlite3VdbeMemIntegerify	src/vdbemem.c	/^int sqlite3VdbeMemIntegerify(Mem *pMem){$/;"	f
sqlite3VdbeMemMakeWriteable	src/vdbemem.c	/^int sqlite3VdbeMemMakeWriteable(Mem *pMem){$/;"	f
sqlite3VdbeMemMove	src/vdbemem.c	/^void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){$/;"	f
sqlite3VdbeMemNulTerminate	src/vdbemem.c	/^int sqlite3VdbeMemNulTerminate(Mem *pMem){$/;"	f
sqlite3VdbeMemNumerify	src/vdbemem.c	/^int sqlite3VdbeMemNumerify(Mem *pMem){$/;"	f
sqlite3VdbeMemPrettyPrint	src/vdbe.c	/^void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf){$/;"	f
sqlite3VdbeMemRealify	src/vdbemem.c	/^int sqlite3VdbeMemRealify(Mem *pMem){$/;"	f
sqlite3VdbeMemRelease	src/vdbemem.c	/^void sqlite3VdbeMemRelease(Mem *p){$/;"	f
sqlite3VdbeMemSetDouble	src/vdbemem.c	/^void sqlite3VdbeMemSetDouble(Mem *pMem, double val){$/;"	f
sqlite3VdbeMemSetInt64	src/vdbemem.c	/^void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){$/;"	f
sqlite3VdbeMemSetNull	src/vdbemem.c	/^void sqlite3VdbeMemSetNull(Mem *pMem){$/;"	f
sqlite3VdbeMemSetStr	src/vdbemem.c	/^int sqlite3VdbeMemSetStr($/;"	f
sqlite3VdbeMemSetZeroBlob	src/vdbemem.c	/^void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){$/;"	f
sqlite3VdbeMemShallowCopy	src/vdbemem.c	/^void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){$/;"	f
sqlite3VdbeMemStringify	src/vdbemem.c	/^int sqlite3VdbeMemStringify(Mem *pMem, int enc){$/;"	f
sqlite3VdbeMemTooBig	src/vdbemem.c	/^int sqlite3VdbeMemTooBig(Mem *p){$/;"	f
sqlite3VdbeMemTranslate	src/utf.c	/^int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){$/;"	f
sqlite3VdbeOpcodeHasProperty	src/vdbe.c	/^int sqlite3VdbeOpcodeHasProperty(int opcode, int mask){$/;"	f
sqlite3VdbePrintOp	src/vdbeaux.c	/^void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){$/;"	f
sqlite3VdbePrintSql	src/vdbeaux.c	/^void sqlite3VdbePrintSql(Vdbe *p){$/;"	f
sqlite3VdbeRealValue	src/vdbemem.c	/^double sqlite3VdbeRealValue(Mem *pMem){$/;"	f
sqlite3VdbeRecordCompare	src/vdbeaux.c	/^int sqlite3VdbeRecordCompare($/;"	f
sqlite3VdbeReset	src/vdbeaux.c	/^int sqlite3VdbeReset(Vdbe *p){$/;"	f
sqlite3VdbeResetStepResult	src/vdbeaux.c	/^void sqlite3VdbeResetStepResult(Vdbe *p){$/;"	f
sqlite3VdbeResolveLabel	src/vdbeaux.c	/^void sqlite3VdbeResolveLabel(Vdbe *p, int x){$/;"	f
sqlite3VdbeSerialGet	src/vdbeaux.c	/^int sqlite3VdbeSerialGet($/;"	f
sqlite3VdbeSerialPut	src/vdbeaux.c	/^int sqlite3VdbeSerialPut(u8 *buf, int nBuf, Mem *pMem, int file_format){$/;"	f
sqlite3VdbeSerialType	src/vdbeaux.c	/^u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){$/;"	f
sqlite3VdbeSerialTypeLen	src/vdbeaux.c	/^int sqlite3VdbeSerialTypeLen(u32 serial_type){$/;"	f
sqlite3VdbeSetChanges	src/vdbeaux.c	/^void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){$/;"	f
sqlite3VdbeSetColName	src/vdbeaux.c	/^int sqlite3VdbeSetColName(Vdbe *p, int idx, int var, const char *zName, int N){$/;"	f
sqlite3VdbeSetNumCols	src/vdbeaux.c	/^void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){$/;"	f
sqlite3VdbeSetSql	src/vdbeaux.c	/^void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n){$/;"	f
sqlite3VdbeSwap	src/vdbeaux.c	/^void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){$/;"	f
sqlite3VdbeTrace	src/vdbeaux.c	/^void sqlite3VdbeTrace(Vdbe *p, FILE *trace){$/;"	f
sqlite3VdbeUsesBtree	src/vdbeaux.c	/^void sqlite3VdbeUsesBtree(Vdbe *p, int i){$/;"	f
sqlite3ViewGetColumnNames	src/build.c	/^int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){$/;"	f
sqlite3ViewGetColumnNames	src/sqliteInt.h	1740;"	d
sqlite3VtabArgExtend	src/vtab.c	/^void sqlite3VtabArgExtend(Parse *pParse, Token *p){$/;"	f
sqlite3VtabArgInit	src/vtab.c	/^void sqlite3VtabArgInit(Parse *pParse){$/;"	f
sqlite3VtabBegin	src/vtab.c	/^int sqlite3VtabBegin(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f
sqlite3VtabBeginParse	src/vtab.c	/^void sqlite3VtabBeginParse($/;"	f
sqlite3VtabCallConnect	src/vtab.c	/^int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){$/;"	f
sqlite3VtabCallCreate	src/vtab.c	/^int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){$/;"	f
sqlite3VtabCallDestroy	src/vtab.c	/^int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab)$/;"	f
sqlite3VtabClear	src/sqliteInt.h	1987;"	d
sqlite3VtabClear	src/vtab.c	/^void sqlite3VtabClear(Table *p){$/;"	f
sqlite3VtabCommit	src/sqliteInt.h	1990;"	d
sqlite3VtabCommit	src/vtab.c	/^int sqlite3VtabCommit(sqlite3 *db){$/;"	f
sqlite3VtabFinishParse	src/vtab.c	/^void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){$/;"	f
sqlite3VtabLock	src/vtab.c	/^void sqlite3VtabLock(sqlite3_vtab *pVtab){$/;"	f
sqlite3VtabOverloadFunction	src/vtab.c	/^FuncDef *sqlite3VtabOverloadFunction($/;"	f
sqlite3VtabRollback	src/sqliteInt.h	1989;"	d
sqlite3VtabRollback	src/vtab.c	/^int sqlite3VtabRollback(sqlite3 *db){$/;"	f
sqlite3VtabSync	src/sqliteInt.h	1988;"	d
sqlite3VtabSync	src/vtab.c	/^int sqlite3VtabSync(sqlite3 *db, int rc2){$/;"	f
sqlite3VtabUnlock	src/vtab.c	/^void sqlite3VtabUnlock(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f
sqlite3WhereBegin	src/where.c	/^WhereInfo *sqlite3WhereBegin($/;"	f
sqlite3WhereEnd	src/where.c	/^void sqlite3WhereEnd(WhereInfo *pWInfo){$/;"	f
sqlite3_aggregate_context	src/sqlite3ext.h	199;"	d
sqlite3_aggregate_context	src/vdbeapi.c	/^void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){$/;"	f
sqlite3_aggregate_count	src/sqlite3ext.h	200;"	d
sqlite3_aggregate_count	src/vdbeapi.c	/^int sqlite3_aggregate_count(sqlite3_context *p){$/;"	f
sqlite3_api_routines	src/sqlite3ext.h	/^struct sqlite3_api_routines {$/;"	s
sqlite3_api_routines	src/sqlite3ext.h	/^typedef struct sqlite3_api_routines sqlite3_api_routines;$/;"	t	typeref:struct:sqlite3_api_routines
sqlite3_apis	src/loadext.c	/^const sqlite3_api_routines sqlite3_apis = {$/;"	v
sqlite3_auto_extension	src/loadext.c	/^int sqlite3_auto_extension(void *xInit){$/;"	f
sqlite3_bind_blob	src/sqlite3ext.h	201;"	d
sqlite3_bind_blob	src/vdbeapi.c	/^int sqlite3_bind_blob($/;"	f
sqlite3_bind_double	src/sqlite3ext.h	202;"	d
sqlite3_bind_double	src/vdbeapi.c	/^int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){$/;"	f
sqlite3_bind_int	src/sqlite3ext.h	203;"	d
sqlite3_bind_int	src/vdbeapi.c	/^int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){$/;"	f
sqlite3_bind_int64	src/sqlite3ext.h	204;"	d
sqlite3_bind_int64	src/vdbeapi.c	/^int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){$/;"	f
sqlite3_bind_null	src/sqlite3ext.h	205;"	d
sqlite3_bind_null	src/vdbeapi.c	/^int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_parameter_count	src/sqlite3ext.h	206;"	d
sqlite3_bind_parameter_count	src/vdbeapi.c	/^int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_bind_parameter_index	src/sqlite3ext.h	207;"	d
sqlite3_bind_parameter_index	src/vdbeapi.c	/^int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){$/;"	f
sqlite3_bind_parameter_name	src/sqlite3ext.h	208;"	d
sqlite3_bind_parameter_name	src/vdbeapi.c	/^const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_text	src/sqlite3ext.h	209;"	d
sqlite3_bind_text	src/vdbeapi.c	/^int sqlite3_bind_text( $/;"	f
sqlite3_bind_text16	src/loadext.c	45;"	d	file:
sqlite3_bind_text16	src/sqlite3ext.h	210;"	d
sqlite3_bind_text16	src/vdbeapi.c	/^int sqlite3_bind_text16($/;"	f
sqlite3_bind_value	src/sqlite3ext.h	211;"	d
sqlite3_bind_value	src/vdbeapi.c	/^int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){$/;"	f
sqlite3_bind_zeroblob	src/loadext.c	99;"	d	file:
sqlite3_bind_zeroblob	src/sqlite3ext.h	321;"	d
sqlite3_bind_zeroblob	src/vdbeapi.c	/^int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){$/;"	f
sqlite3_blob	sqlite3.h	/^typedef struct sqlite3_blob sqlite3_blob;$/;"	t	typeref:struct:sqlite3_blob
sqlite3_blob_bytes	src/loadext.c	100;"	d	file:
sqlite3_blob_bytes	src/sqlite3ext.h	322;"	d
sqlite3_blob_bytes	src/vdbeblob.c	/^int sqlite3_blob_bytes(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_close	src/loadext.c	101;"	d	file:
sqlite3_blob_close	src/sqlite3ext.h	323;"	d
sqlite3_blob_close	src/vdbeblob.c	/^int sqlite3_blob_close(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_open	src/loadext.c	102;"	d	file:
sqlite3_blob_open	src/sqlite3ext.h	324;"	d
sqlite3_blob_open	src/vdbeblob.c	/^int sqlite3_blob_open($/;"	f
sqlite3_blob_read	src/loadext.c	103;"	d	file:
sqlite3_blob_read	src/sqlite3ext.h	325;"	d
sqlite3_blob_read	src/vdbeblob.c	/^int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){$/;"	f
sqlite3_blob_write	src/loadext.c	104;"	d	file:
sqlite3_blob_write	src/sqlite3ext.h	326;"	d
sqlite3_blob_write	src/vdbeblob.c	/^int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){$/;"	f
sqlite3_btree_trace	src/btree.c	/^int sqlite3_btree_trace=0;  \/* True to enable tracing *\/$/;"	v
sqlite3_busy_handler	src/main.c	/^int sqlite3_busy_handler($/;"	f
sqlite3_busy_handler	src/sqlite3ext.h	212;"	d
sqlite3_busy_timeout	src/main.c	/^int sqlite3_busy_timeout(sqlite3 *db, int ms){$/;"	f
sqlite3_busy_timeout	src/sqlite3ext.h	213;"	d
sqlite3_callback	sqlite3.h	/^typedef int (*sqlite3_callback)(void*,int,char**, char**);$/;"	t
sqlite3_changes	src/main.c	/^int sqlite3_changes(sqlite3 *db){$/;"	f
sqlite3_changes	src/sqlite3ext.h	214;"	d
sqlite3_clear_bindings	src/sqlite3ext.h	320;"	d
sqlite3_clear_bindings	src/vdbeapi.c	/^int sqlite3_clear_bindings(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_close	src/test_server.c	/^int sqlite3_client_close(sqlite3 *pDb){$/;"	f
sqlite3_client_finalize	src/test_server.c	/^int sqlite3_client_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_open	src/test_server.c	/^int sqlite3_client_open(const char *zDatabaseName, sqlite3 **ppDb){$/;"	f
sqlite3_client_prepare	src/test_server.c	/^int sqlite3_client_prepare($/;"	f
sqlite3_client_reset	src/test_server.c	/^int sqlite3_client_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_step	src/test_server.c	/^int sqlite3_client_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_close	src/main.c	/^int sqlite3_close(sqlite3 *db){$/;"	f
sqlite3_close	src/sqlite3ext.h	215;"	d
sqlite3_collation_needed	src/main.c	/^int sqlite3_collation_needed($/;"	f
sqlite3_collation_needed	src/sqlite3ext.h	216;"	d
sqlite3_collation_needed16	src/loadext.c	46;"	d	file:
sqlite3_collation_needed16	src/main.c	/^int sqlite3_collation_needed16($/;"	f
sqlite3_collation_needed16	src/sqlite3ext.h	217;"	d
sqlite3_column_blob	src/sqlite3ext.h	218;"	d
sqlite3_column_blob	src/vdbeapi.c	/^const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes	src/sqlite3ext.h	219;"	d
sqlite3_column_bytes	src/vdbeapi.c	/^int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes16	src/sqlite3ext.h	220;"	d
sqlite3_column_bytes16	src/vdbeapi.c	/^int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_count	src/sqlite3ext.h	221;"	d
sqlite3_column_count	src/vdbeapi.c	/^int sqlite3_column_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_column_database_name	src/loadext.c	31;"	d	file:
sqlite3_column_database_name	src/sqlite3ext.h	222;"	d
sqlite3_column_database_name	src/vdbeapi.c	/^const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_database_name16	src/loadext.c	32;"	d	file:
sqlite3_column_database_name16	src/loadext.c	64;"	d	file:
sqlite3_column_database_name16	src/sqlite3ext.h	223;"	d
sqlite3_column_database_name16	src/vdbeapi.c	/^const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype	src/sqlite3ext.h	224;"	d
sqlite3_column_decltype	src/vdbeapi.c	/^const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype16	src/loadext.c	47;"	d	file:
sqlite3_column_decltype16	src/sqlite3ext.h	225;"	d
sqlite3_column_decltype16	src/vdbeapi.c	/^const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_double	src/sqlite3ext.h	226;"	d
sqlite3_column_double	src/vdbeapi.c	/^double sqlite3_column_double(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int	src/sqlite3ext.h	227;"	d
sqlite3_column_int	src/vdbeapi.c	/^int sqlite3_column_int(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int64	src/sqlite3ext.h	228;"	d
sqlite3_column_int64	src/vdbeapi.c	/^sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_name	src/sqlite3ext.h	229;"	d
sqlite3_column_name	src/vdbeapi.c	/^const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_name16	src/loadext.c	48;"	d	file:
sqlite3_column_name16	src/sqlite3ext.h	230;"	d
sqlite3_column_name16	src/vdbeapi.c	/^const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name	src/loadext.c	35;"	d	file:
sqlite3_column_origin_name	src/sqlite3ext.h	231;"	d
sqlite3_column_origin_name	src/vdbeapi.c	/^const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name16	src/loadext.c	36;"	d	file:
sqlite3_column_origin_name16	src/loadext.c	66;"	d	file:
sqlite3_column_origin_name16	src/sqlite3ext.h	232;"	d
sqlite3_column_origin_name16	src/vdbeapi.c	/^const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name	src/loadext.c	33;"	d	file:
sqlite3_column_table_name	src/sqlite3ext.h	233;"	d
sqlite3_column_table_name	src/vdbeapi.c	/^const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name16	src/loadext.c	34;"	d	file:
sqlite3_column_table_name16	src/loadext.c	65;"	d	file:
sqlite3_column_table_name16	src/sqlite3ext.h	234;"	d
sqlite3_column_table_name16	src/vdbeapi.c	/^const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_text	src/sqlite3ext.h	235;"	d
sqlite3_column_text	src/vdbeapi.c	/^const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_text16	src/loadext.c	49;"	d	file:
sqlite3_column_text16	src/sqlite3ext.h	236;"	d
sqlite3_column_text16	src/vdbeapi.c	/^const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_type	src/sqlite3ext.h	237;"	d
sqlite3_column_type	src/vdbeapi.c	/^int sqlite3_column_type(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_value	src/sqlite3ext.h	238;"	d
sqlite3_column_value	src/vdbeapi.c	/^sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_commit_hook	src/main.c	/^void *sqlite3_commit_hook($/;"	f
sqlite3_commit_hook	src/sqlite3ext.h	239;"	d
sqlite3_complete	src/complete.c	/^int sqlite3_complete(const char *zSql){$/;"	f
sqlite3_complete	src/loadext.c	70;"	d	file:
sqlite3_complete	src/sqlite3ext.h	240;"	d
sqlite3_complete16	src/complete.c	/^int sqlite3_complete16(const void *zSql){$/;"	f
sqlite3_complete16	src/loadext.c	50;"	d	file:
sqlite3_complete16	src/loadext.c	71;"	d	file:
sqlite3_complete16	src/sqlite3ext.h	241;"	d
sqlite3_context	sqlite3.h	/^typedef struct sqlite3_context sqlite3_context;$/;"	t	typeref:struct:sqlite3_context
sqlite3_context	src/vdbeInt.h	/^struct sqlite3_context {$/;"	s
sqlite3_create_collation	src/main.c	/^int sqlite3_create_collation($/;"	f
sqlite3_create_collation	src/sqlite3ext.h	242;"	d
sqlite3_create_collation16	src/loadext.c	51;"	d	file:
sqlite3_create_collation16	src/main.c	/^int sqlite3_create_collation16($/;"	f
sqlite3_create_collation16	src/sqlite3ext.h	243;"	d
sqlite3_create_collation_v2	src/main.c	/^int sqlite3_create_collation_v2($/;"	f
sqlite3_create_collation_v2	src/sqlite3ext.h	327;"	d
sqlite3_create_function	src/main.c	/^int sqlite3_create_function($/;"	f
sqlite3_create_function	src/sqlite3ext.h	244;"	d
sqlite3_create_function16	src/loadext.c	52;"	d	file:
sqlite3_create_function16	src/main.c	/^int sqlite3_create_function16($/;"	f
sqlite3_create_function16	src/sqlite3ext.h	245;"	d
sqlite3_create_module	src/loadext.c	79;"	d	file:
sqlite3_create_module	src/sqlite3ext.h	246;"	d
sqlite3_create_module	src/vtab.c	/^int sqlite3_create_module($/;"	f
sqlite3_create_module_v2	src/loadext.c	80;"	d	file:
sqlite3_create_module_v2	src/sqlite3ext.h	247;"	d
sqlite3_create_module_v2	src/vtab.c	/^int sqlite3_create_module_v2($/;"	f
sqlite3_current_time	src/os_os2.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_current_time	src/os_unix.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_current_time	src/os_win.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_data_count	src/sqlite3ext.h	248;"	d
sqlite3_data_count	src/vdbeapi.c	/^int sqlite3_data_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_db_handle	src/sqlite3ext.h	249;"	d
sqlite3_db_handle	src/vdbeapi.c	/^sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){$/;"	f
sqlite3_declare_vtab	src/loadext.c	81;"	d	file:
sqlite3_declare_vtab	src/sqlite3ext.h	250;"	d
sqlite3_declare_vtab	src/vtab.c	/^int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){$/;"	f
sqlite3_destructor_type	sqlite3.h	/^typedef void (*sqlite3_destructor_type)(void*);$/;"	t
sqlite3_diskfull	src/os_common.h	/^int sqlite3_diskfull = 0;$/;"	v
sqlite3_diskfull_pending	src/os_common.h	/^int sqlite3_diskfull_pending = 0;$/;"	v
sqlite3_enable_in_opt	src/expr.c	/^  int sqlite3_enable_in_opt = 1;$/;"	v
sqlite3_enable_in_opt	src/expr.c	1528;"	d	file:
sqlite3_enable_load_extension	src/loadext.c	/^int sqlite3_enable_load_extension(sqlite3 *db, int onoff){$/;"	f
sqlite3_enable_shared_cache	src/btree.c	/^int sqlite3_enable_shared_cache(int enable){$/;"	f
sqlite3_enable_shared_cache	src/loadext.c	85;"	d	file:
sqlite3_enable_shared_cache	src/sqlite3ext.h	251;"	d
sqlite3_errcode	src/main.c	/^int sqlite3_errcode(sqlite3 *db){$/;"	f
sqlite3_errcode	src/sqlite3ext.h	252;"	d
sqlite3_errmsg	src/main.c	/^const char *sqlite3_errmsg(sqlite3 *db){$/;"	f
sqlite3_errmsg	src/sqlite3ext.h	253;"	d
sqlite3_errmsg16	src/loadext.c	53;"	d	file:
sqlite3_errmsg16	src/main.c	/^const void *sqlite3_errmsg16(sqlite3 *db){$/;"	f
sqlite3_errmsg16	src/sqlite3ext.h	254;"	d
sqlite3_exec	src/legacy.c	/^int sqlite3_exec($/;"	f
sqlite3_exec	src/sqlite3ext.h	255;"	d
sqlite3_expired	src/sqlite3ext.h	256;"	d
sqlite3_expired	src/vdbeapi.c	/^int sqlite3_expired(sqlite3_stmt *pStmt){$/;"	f
sqlite3_extended_result_codes	src/main.c	/^int sqlite3_extended_result_codes(sqlite3 *db, int onoff){$/;"	f
sqlite3_extension_init	ext/fts1/fts1.c	/^int sqlite3_extension_init(sqlite3 *db, char **pzErrMsg,$/;"	f
sqlite3_extension_init	ext/fts2/fts2.c	/^int sqlite3_extension_init($/;"	f
sqlite3_extension_init	ext/fts3/fts3.c	/^int sqlite3_extension_init($/;"	f
sqlite3_extension_init	ext/icu/icu.c	/^int sqlite3_extension_init($/;"	f
sqlite3_extension_init	src/test_schema.c	/^int sqlite3_extension_init($/;"	f
sqlite3_file	sqlite3.h	/^struct sqlite3_file {$/;"	s
sqlite3_file	sqlite3.h	/^typedef struct sqlite3_file sqlite3_file;$/;"	t	typeref:struct:sqlite3_file
sqlite3_file_control	src/main.c	/^int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){$/;"	f
sqlite3_file_control	src/sqlite3ext.h	328;"	d
sqlite3_finalize	src/sqlite3ext.h	257;"	d
sqlite3_finalize	src/vdbeapi.c	/^int sqlite3_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_free	src/mem1.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	src/mem2.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	src/mem3.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	src/mem4.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	src/sqlite3ext.h	258;"	d
sqlite3_free_table	src/loadext.c	94;"	d	file:
sqlite3_free_table	src/sqlite3ext.h	259;"	d
sqlite3_free_table	src/table.c	/^void sqlite3_free_table($/;"	f
sqlite3_fullsync_count	src/os_os2.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_fullsync_count	src/os_unix.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_fullsync_count	src/os_win.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_get_autocommit	src/main.c	/^int sqlite3_get_autocommit(sqlite3 *db){$/;"	f
sqlite3_get_autocommit	src/sqlite3ext.h	260;"	d
sqlite3_get_auxdata	src/sqlite3ext.h	261;"	d
sqlite3_get_auxdata	src/vdbeapi.c	/^void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){$/;"	f
sqlite3_get_table	src/loadext.c	95;"	d	file:
sqlite3_get_table	src/sqlite3ext.h	262;"	d
sqlite3_get_table	src/table.c	/^int sqlite3_get_table($/;"	f
sqlite3_get_table_cb	src/table.c	/^static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){$/;"	f	file:
sqlite3_global_recover	src/main.c	/^int sqlite3_global_recover(void){$/;"	f
sqlite3_global_recover	src/sqlite3ext.h	263;"	d
sqlite3_index_constraint	sqlite3.h	/^  struct sqlite3_index_constraint {$/;"	s	struct:sqlite3_index_info
sqlite3_index_constraint_usage	sqlite3.h	/^  struct sqlite3_index_constraint_usage {$/;"	s	struct:sqlite3_index_info
sqlite3_index_info	sqlite3.h	/^struct sqlite3_index_info {$/;"	s
sqlite3_index_info	sqlite3.h	/^typedef struct sqlite3_index_info sqlite3_index_info;$/;"	t	typeref:struct:sqlite3_index_info
sqlite3_index_orderby	sqlite3.h	/^  struct sqlite3_index_orderby {$/;"	s	struct:sqlite3_index_info
sqlite3_int64	sqlite3.h	/^typedef sqlite_int64 sqlite3_int64;$/;"	t
sqlite3_interrupt	src/main.c	/^void sqlite3_interrupt(sqlite3 *db){$/;"	f
sqlite3_interrupt	src/sqlite3ext.h	264;"	d
sqlite3_interrupt_count	src/vdbe.c	/^int sqlite3_interrupt_count = 0;$/;"	v
sqlite3_io_error_hit	src/os_common.h	/^int sqlite3_io_error_hit = 0;$/;"	v
sqlite3_io_error_pending	src/os_common.h	/^int sqlite3_io_error_pending = 0;$/;"	v
sqlite3_io_error_persist	src/os_common.h	/^int sqlite3_io_error_persist = 0;$/;"	v
sqlite3_io_methods	sqlite3.h	/^struct sqlite3_io_methods {$/;"	s
sqlite3_io_methods	sqlite3.h	/^typedef struct sqlite3_io_methods sqlite3_io_methods;$/;"	t	typeref:struct:sqlite3_io_methods
sqlite3_io_trace	src/main.c	/^void (*sqlite3_io_trace)(const char*, ...) = 0;$/;"	v
sqlite3_io_trace	src/sqliteInt.h	/^SQLITE_EXTERN void (*sqlite3_io_trace)(const char*,...);$/;"	v
sqlite3_isnan	src/sqliteInt.h	161;"	d
sqlite3_last_insert_rowid	src/main.c	/^sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){$/;"	f
sqlite3_last_insert_rowid	src/sqlite3ext.h	265;"	d
sqlite3_libversion	src/main.c	/^const char *sqlite3_libversion(void){ return sqlite3_version; }$/;"	f
sqlite3_libversion	src/sqlite3ext.h	266;"	d
sqlite3_libversion_number	src/main.c	/^int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }$/;"	f
sqlite3_libversion_number	src/sqlite3ext.h	267;"	d
sqlite3_like_count	src/func.c	/^int sqlite3_like_count = 0;$/;"	v
sqlite3_load_extension	src/loadext.c	/^int sqlite3_load_extension($/;"	f
sqlite3_malloc	src/mem1.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	src/mem2.c	/^void *sqlite3_malloc(int nByte){$/;"	f
sqlite3_malloc	src/mem3.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	src/mem4.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	src/sqlite3ext.h	268;"	d
sqlite3_max_blobsize	src/vdbe.c	/^int sqlite3_max_blobsize = 0;$/;"	v
sqlite3_memdebug_backtrace	src/mem2.c	/^void sqlite3_memdebug_backtrace(int depth){$/;"	f
sqlite3_memdebug_dump	src/mem2.c	/^void sqlite3_memdebug_dump(const char *zFilename){$/;"	f
sqlite3_memdebug_dump	src/mem3.c	/^void sqlite3_memdebug_dump(const char *zFilename){$/;"	f
sqlite3_memdebug_settitle	src/mem2.c	/^void sqlite3_memdebug_settitle(const char *zTitle){$/;"	f
sqlite3_memory_alarm	src/mem1.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	src/mem2.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	src/mem3.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	src/mem4.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_highwater	src/mem1.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	src/mem2.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	src/mem3.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	src/mem4.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	src/sqlite3ext.h	329;"	d
sqlite3_memory_used	src/mem1.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	src/mem2.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	src/mem3.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	src/mem4.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	src/sqlite3ext.h	330;"	d
sqlite3_module	sqlite3.h	/^struct sqlite3_module {$/;"	s
sqlite3_module	sqlite3.h	/^typedef struct sqlite3_module sqlite3_module;$/;"	t	typeref:struct:sqlite3_module
sqlite3_mprintf	src/printf.c	/^char *sqlite3_mprintf(const char *zFormat, ...){$/;"	f
sqlite3_mprintf	src/sqlite3ext.h	269;"	d
sqlite3_mprintf_double	src/test1.c	/^static int sqlite3_mprintf_double($/;"	f	file:
sqlite3_mprintf_hexdouble	src/test1.c	/^static int sqlite3_mprintf_hexdouble($/;"	f	file:
sqlite3_mprintf_int	src/test1.c	/^static int sqlite3_mprintf_int($/;"	f	file:
sqlite3_mprintf_int64	src/test1.c	/^static int sqlite3_mprintf_int64($/;"	f	file:
sqlite3_mprintf_scaled	src/test1.c	/^static int sqlite3_mprintf_scaled($/;"	f	file:
sqlite3_mprintf_str	src/test1.c	/^static int sqlite3_mprintf_str($/;"	f	file:
sqlite3_mprintf_stronly	src/test1.c	/^static int sqlite3_mprintf_stronly($/;"	f	file:
sqlite3_mutex	sqlite3.h	/^typedef struct sqlite3_mutex sqlite3_mutex;$/;"	t	typeref:struct:sqlite3_mutex
sqlite3_mutex	src/mutex.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	src/mutex_os2.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	src/mutex_unix.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	src/mutex_w32.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex_alloc	src/mutex.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int id){$/;"	f
sqlite3_mutex_alloc	src/mutex.h	73;"	d
sqlite3_mutex_alloc	src/mutex_os2.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	src/mutex_unix.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	src/mutex_w32.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	src/sqlite3ext.h	331;"	d
sqlite3_mutex_enter	src/mutex.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	src/mutex.h	75;"	d
sqlite3_mutex_enter	src/mutex_os2.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	src/mutex_unix.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	src/mutex_w32.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	src/sqlite3ext.h	332;"	d
sqlite3_mutex_free	src/mutex.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	src/mutex.h	74;"	d
sqlite3_mutex_free	src/mutex_os2.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	src/mutex_unix.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	src/mutex_w32.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	src/sqlite3ext.h	333;"	d
sqlite3_mutex_held	src/mutex.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	src/mutex.h	78;"	d
sqlite3_mutex_held	src/mutex_os2.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	src/mutex_unix.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	src/mutex_w32.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	src/mutex.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	src/mutex.h	77;"	d
sqlite3_mutex_leave	src/mutex_os2.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	src/mutex_unix.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	src/mutex_w32.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	src/sqlite3ext.h	334;"	d
sqlite3_mutex_notheld	src/mutex.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	src/mutex.h	79;"	d
sqlite3_mutex_notheld	src/mutex_os2.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	src/mutex_unix.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	src/mutex_w32.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	src/mutex.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	src/mutex.h	76;"	d
sqlite3_mutex_try	src/mutex_os2.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	src/mutex_unix.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	src/mutex_w32.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	src/sqlite3ext.h	335;"	d
sqlite3_open	src/main.c	/^int sqlite3_open($/;"	f
sqlite3_open	src/sqlite3ext.h	270;"	d
sqlite3_open16	src/loadext.c	54;"	d	file:
sqlite3_open16	src/main.c	/^int sqlite3_open16($/;"	f
sqlite3_open16	src/sqlite3ext.h	271;"	d
sqlite3_open_file_count	src/os_common.h	/^int sqlite3_open_file_count = 0;$/;"	v
sqlite3_open_v2	src/main.c	/^int sqlite3_open_v2($/;"	f
sqlite3_open_v2	src/sqlite3ext.h	336;"	d
sqlite3_opentemp_count	src/pager.c	/^int sqlite3_opentemp_count = 0;$/;"	v
sqlite3_os_trace	src/os_common.h	/^int sqlite3_os_trace = 0;$/;"	v
sqlite3_os_type	src/os_win.c	/^int sqlite3_os_type = 0;$/;"	v
sqlite3_os_type	src/os_win.c	/^static int sqlite3_os_type = 0;$/;"	v	file:
sqlite3_overload_function	src/main.c	/^int sqlite3_overload_function($/;"	f
sqlite3_overload_function	src/sqlite3ext.h	317;"	d
sqlite3_pager_n_sort_bucket	src/pager.c	/^  int sqlite3_pager_n_sort_bucket = 0;$/;"	v
sqlite3_pager_pgfree_count	src/pager.c	/^int sqlite3_pager_pgfree_count = 0;    \/* Number of cache pages freed *\/$/;"	v
sqlite3_pager_readdb_count	src/pager.c	/^int sqlite3_pager_readdb_count = 0;    \/* Number of full pages read from DB *\/$/;"	v
sqlite3_pager_writedb_count	src/pager.c	/^int sqlite3_pager_writedb_count = 0;   \/* Number of full pages written to DB *\/$/;"	v
sqlite3_pager_writej_count	src/pager.c	/^int sqlite3_pager_writej_count = 0;    \/* Number of pages written to journal *\/$/;"	v
sqlite3_pending_byte	src/os_common.h	/^unsigned int sqlite3_pending_byte = 0x40000000;$/;"	v
sqlite3_prepare	src/prepare.c	/^int sqlite3_prepare($/;"	f
sqlite3_prepare	src/sqlite3ext.h	272;"	d
sqlite3_prepare16	src/loadext.c	55;"	d	file:
sqlite3_prepare16	src/prepare.c	/^int sqlite3_prepare16($/;"	f
sqlite3_prepare16	src/sqlite3ext.h	273;"	d
sqlite3_prepare16_v2	src/loadext.c	56;"	d	file:
sqlite3_prepare16_v2	src/prepare.c	/^int sqlite3_prepare16_v2($/;"	f
sqlite3_prepare16_v2	src/sqlite3ext.h	275;"	d
sqlite3_prepare16_v2	src/sqlite3ext.h	319;"	d
sqlite3_prepare_v2	src/prepare.c	/^int sqlite3_prepare_v2($/;"	f
sqlite3_prepare_v2	src/sqlite3ext.h	274;"	d
sqlite3_prepare_v2	src/sqlite3ext.h	318;"	d
sqlite3_profile	src/loadext.c	89;"	d	file:
sqlite3_profile	src/main.c	/^void *sqlite3_profile($/;"	f
sqlite3_profile	src/sqlite3ext.h	276;"	d
sqlite3_progress_handler	src/loadext.c	75;"	d	file:
sqlite3_progress_handler	src/main.c	/^void sqlite3_progress_handler($/;"	f
sqlite3_progress_handler	src/sqlite3ext.h	277;"	d
sqlite3_query_plan	src/where.c	/^char sqlite3_query_plan[BMS*2*40];  \/* Text of the join *\/$/;"	v
sqlite3_realloc	src/mem1.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	src/mem2.c	/^void *sqlite3_realloc(void *pPrior, int nByte){$/;"	f
sqlite3_realloc	src/mem3.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	src/mem4.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	src/sqlite3ext.h	278;"	d
sqlite3_release_memory	src/malloc.c	/^int sqlite3_release_memory(int n){$/;"	f
sqlite3_release_memory	src/sqlite3ext.h	337;"	d
sqlite3_reset	src/sqlite3ext.h	279;"	d
sqlite3_reset	src/vdbeapi.c	/^int sqlite3_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_reset_auto_extension	src/loadext.c	/^void sqlite3_reset_auto_extension(void){$/;"	f
sqlite3_result_blob	src/sqlite3ext.h	280;"	d
sqlite3_result_blob	src/vdbeapi.c	/^void sqlite3_result_blob($/;"	f
sqlite3_result_double	src/sqlite3ext.h	281;"	d
sqlite3_result_double	src/vdbeapi.c	/^void sqlite3_result_double(sqlite3_context *pCtx, double rVal){$/;"	f
sqlite3_result_error	src/sqlite3ext.h	282;"	d
sqlite3_result_error	src/vdbeapi.c	/^void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){$/;"	f
sqlite3_result_error16	src/loadext.c	57;"	d	file:
sqlite3_result_error16	src/sqlite3ext.h	283;"	d
sqlite3_result_error16	src/vdbeapi.c	/^void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){$/;"	f
sqlite3_result_error_nomem	src/sqlite3ext.h	338;"	d
sqlite3_result_error_nomem	src/vdbeapi.c	/^void sqlite3_result_error_nomem(sqlite3_context *pCtx){$/;"	f
sqlite3_result_error_toobig	src/sqlite3ext.h	339;"	d
sqlite3_result_error_toobig	src/vdbeapi.c	/^void sqlite3_result_error_toobig(sqlite3_context *pCtx){$/;"	f
sqlite3_result_int	src/sqlite3ext.h	284;"	d
sqlite3_result_int	src/vdbeapi.c	/^void sqlite3_result_int(sqlite3_context *pCtx, int iVal){$/;"	f
sqlite3_result_int64	src/sqlite3ext.h	285;"	d
sqlite3_result_int64	src/vdbeapi.c	/^void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){$/;"	f
sqlite3_result_null	src/sqlite3ext.h	286;"	d
sqlite3_result_null	src/vdbeapi.c	/^void sqlite3_result_null(sqlite3_context *pCtx){$/;"	f
sqlite3_result_text	src/sqlite3ext.h	287;"	d
sqlite3_result_text	src/vdbeapi.c	/^void sqlite3_result_text($/;"	f
sqlite3_result_text16	src/loadext.c	58;"	d	file:
sqlite3_result_text16	src/sqlite3ext.h	288;"	d
sqlite3_result_text16	src/vdbeapi.c	/^void sqlite3_result_text16($/;"	f
sqlite3_result_text16be	src/loadext.c	59;"	d	file:
sqlite3_result_text16be	src/sqlite3ext.h	289;"	d
sqlite3_result_text16be	src/vdbeapi.c	/^void sqlite3_result_text16be($/;"	f
sqlite3_result_text16le	src/loadext.c	60;"	d	file:
sqlite3_result_text16le	src/sqlite3ext.h	290;"	d
sqlite3_result_text16le	src/vdbeapi.c	/^void sqlite3_result_text16le($/;"	f
sqlite3_result_value	src/sqlite3ext.h	291;"	d
sqlite3_result_value	src/vdbeapi.c	/^void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){$/;"	f
sqlite3_result_zeroblob	src/vdbeapi.c	/^void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){$/;"	f
sqlite3_rollback_hook	src/main.c	/^void *sqlite3_rollback_hook($/;"	f
sqlite3_rollback_hook	src/sqlite3ext.h	292;"	d
sqlite3_search_count	src/vdbe.c	/^int sqlite3_search_count = 0;$/;"	v
sqlite3_server	src/test_server.c	/^void *sqlite3_server(void *NotUsed){$/;"	f
sqlite3_server_start	src/test_server.c	/^void sqlite3_server_start(void){$/;"	f
sqlite3_server_stop	src/test_server.c	/^void sqlite3_server_stop(void){$/;"	f
sqlite3_set_authorizer	src/auth.c	/^int sqlite3_set_authorizer($/;"	f
sqlite3_set_authorizer	src/loadext.c	41;"	d	file:
sqlite3_set_authorizer	src/sqlite3ext.h	293;"	d
sqlite3_set_auxdata	src/sqlite3ext.h	294;"	d
sqlite3_set_auxdata	src/vdbeapi.c	/^void sqlite3_set_auxdata($/;"	f
sqlite3_sleep	src/main.c	/^int sqlite3_sleep(int ms){$/;"	f
sqlite3_sleep	src/sqlite3ext.h	340;"	d
sqlite3_snprintf	src/printf.c	/^char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){$/;"	f
sqlite3_snprintf	src/sqlite3ext.h	295;"	d
sqlite3_snprintf_str	src/test1.c	/^static int sqlite3_snprintf_str($/;"	f	file:
sqlite3_soft_heap_limit	src/malloc.c	/^void sqlite3_soft_heap_limit(int n){$/;"	f
sqlite3_soft_heap_limit	src/sqlite3ext.h	341;"	d
sqlite3_sort_count	src/vdbe.c	/^int sqlite3_sort_count = 0;$/;"	v
sqlite3_sql	src/vdbeaux.c	/^const char *sqlite3_sql(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stack_baseline	src/test1.c	/^static u8 *sqlite3_stack_baseline = 0;$/;"	v	file:
sqlite3_step	src/sqlite3ext.h	296;"	d
sqlite3_step	src/vdbeapi.c	/^int sqlite3_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt	sqlite3.h	/^typedef struct sqlite3_stmt sqlite3_stmt;$/;"	t	typeref:struct:sqlite3_stmt
sqlite3_sync_count	src/os_os2.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_sync_count	src/os_unix.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_sync_count	src/os_win.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_table_column_metadata	src/loadext.c	37;"	d	file:
sqlite3_table_column_metadata	src/main.c	/^int sqlite3_table_column_metadata($/;"	f
sqlite3_table_column_metadata	src/sqlite3ext.h	297;"	d
sqlite3_temp_directory	sqlite3.h	/^SQLITE_EXTERN char *sqlite3_temp_directory;$/;"	v
sqlite3_temp_directory	src/main.c	/^char *sqlite3_temp_directory = 0;$/;"	v
sqlite3_test_control	src/main.c	/^int sqlite3_test_control(int op, ...){$/;"	f
sqlite3_thread_cleanup	src/main.c	/^void sqlite3_thread_cleanup(void){$/;"	f
sqlite3_thread_cleanup	src/sqlite3ext.h	298;"	d
sqlite3_threadsafe	src/main.c	/^int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }$/;"	f
sqlite3_tokenizer	ext/fts1/fts1_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	ext/fts1/fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer	ext/fts2/fts2_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	ext/fts2/fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer	ext/fts3/fts3_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	ext/fts3/fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer_cursor	ext/fts1/fts1_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	ext/fts1/fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_cursor	ext/fts2/fts2_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	ext/fts2/fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_cursor	ext/fts3/fts3_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	ext/fts3/fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_module	ext/fts1/fts1_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	ext/fts1/fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_tokenizer_module	ext/fts2/fts2_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	ext/fts2/fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_tokenizer_module	ext/fts3/fts3_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	ext/fts3/fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_total_changes	src/main.c	/^int sqlite3_total_changes(sqlite3 *db){$/;"	f
sqlite3_total_changes	src/sqlite3ext.h	299;"	d
sqlite3_trace	src/loadext.c	90;"	d	file:
sqlite3_trace	src/main.c	/^void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){$/;"	f
sqlite3_trace	src/sqlite3ext.h	300;"	d
sqlite3_transfer_bindings	src/sqlite3ext.h	301;"	d
sqlite3_transfer_bindings	src/vdbeapi.c	/^int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){$/;"	f
sqlite3_uint64	sqlite3.h	/^typedef sqlite_uint64 sqlite3_uint64;$/;"	t
sqlite3_update_hook	src/main.c	/^void *sqlite3_update_hook($/;"	f
sqlite3_update_hook	src/sqlite3ext.h	302;"	d
sqlite3_user_data	src/sqlite3ext.h	303;"	d
sqlite3_user_data	src/vdbeapi.c	/^void *sqlite3_user_data(sqlite3_context *p){$/;"	f
sqlite3_value	sqlite3.h	/^typedef struct Mem sqlite3_value;$/;"	t	typeref:struct:Mem
sqlite3_value_blob	src/sqlite3ext.h	304;"	d
sqlite3_value_blob	src/vdbeapi.c	/^const void *sqlite3_value_blob(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes	src/sqlite3ext.h	305;"	d
sqlite3_value_bytes	src/vdbeapi.c	/^int sqlite3_value_bytes(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes16	src/sqlite3ext.h	306;"	d
sqlite3_value_bytes16	src/vdbeapi.c	/^int sqlite3_value_bytes16(sqlite3_value *pVal){$/;"	f
sqlite3_value_double	src/sqlite3ext.h	307;"	d
sqlite3_value_double	src/vdbeapi.c	/^double sqlite3_value_double(sqlite3_value *pVal){$/;"	f
sqlite3_value_int	src/sqlite3ext.h	308;"	d
sqlite3_value_int	src/vdbeapi.c	/^int sqlite3_value_int(sqlite3_value *pVal){$/;"	f
sqlite3_value_int64	src/sqlite3ext.h	309;"	d
sqlite3_value_int64	src/vdbeapi.c	/^sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){$/;"	f
sqlite3_value_numeric_type	src/sqlite3ext.h	310;"	d
sqlite3_value_numeric_type	src/vdbe.c	/^int sqlite3_value_numeric_type(sqlite3_value *pVal){$/;"	f
sqlite3_value_text	src/sqlite3ext.h	311;"	d
sqlite3_value_text	src/vdbeapi.c	/^const unsigned char *sqlite3_value_text(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16	src/loadext.c	61;"	d	file:
sqlite3_value_text16	src/sqlite3ext.h	312;"	d
sqlite3_value_text16	src/vdbeapi.c	/^const void *sqlite3_value_text16(sqlite3_value* pVal){$/;"	f
sqlite3_value_text16be	src/loadext.c	62;"	d	file:
sqlite3_value_text16be	src/sqlite3ext.h	313;"	d
sqlite3_value_text16be	src/vdbeapi.c	/^const void *sqlite3_value_text16be(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16le	src/loadext.c	63;"	d	file:
sqlite3_value_text16le	src/sqlite3ext.h	314;"	d
sqlite3_value_text16le	src/vdbeapi.c	/^const void *sqlite3_value_text16le(sqlite3_value *pVal){$/;"	f
sqlite3_value_type	src/sqlite3ext.h	315;"	d
sqlite3_value_type	src/vdbeapi.c	/^int sqlite3_value_type(sqlite3_value* pVal){$/;"	f
sqlite3_vdbe_addop_trace	src/vdbeaux.c	/^int sqlite3_vdbe_addop_trace = 0;$/;"	v
sqlite3_version	sqlite3.h	/^SQLITE_EXTERN const char sqlite3_version[];$/;"	v
sqlite3_version	src/main.c	/^const char sqlite3_version[] = SQLITE_VERSION;$/;"	v
sqlite3_vfs	sqlite3.h	/^struct sqlite3_vfs {$/;"	s
sqlite3_vfs	sqlite3.h	/^typedef struct sqlite3_vfs sqlite3_vfs;$/;"	t	typeref:struct:sqlite3_vfs
sqlite3_vfs_find	src/os.c	/^sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){$/;"	f
sqlite3_vfs_find	src/sqlite3ext.h	342;"	d
sqlite3_vfs_register	src/os.c	/^int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){$/;"	f
sqlite3_vfs_register	src/sqlite3ext.h	343;"	d
sqlite3_vfs_unregister	src/os.c	/^int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){$/;"	f
sqlite3_vfs_unregister	src/sqlite3ext.h	344;"	d
sqlite3_vmprintf	src/printf.c	/^char *sqlite3_vmprintf(const char *zFormat, va_list ap){$/;"	f
sqlite3_vmprintf	src/sqlite3ext.h	316;"	d
sqlite3_vtab	sqlite3.h	/^struct sqlite3_vtab {$/;"	s
sqlite3_vtab	sqlite3.h	/^typedef struct sqlite3_vtab sqlite3_vtab;$/;"	t	typeref:struct:sqlite3_vtab
sqlite3_vtab_cursor	sqlite3.h	/^struct sqlite3_vtab_cursor {$/;"	s
sqlite3_vtab_cursor	sqlite3.h	/^typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;$/;"	t	typeref:struct:sqlite3_vtab_cursor
sqlite3_where_trace	src/where.c	/^int sqlite3_where_trace = 0;$/;"	v
sqlite3_xferopt_count	src/insert.c	/^int sqlite3_xferopt_count;$/;"	v
sqlite3async_trace	src/test_async.c	/^static int sqlite3async_trace = 0;$/;"	v	file:
sqlite3one	src/utf.c	/^const int sqlite3one = 1;$/;"	v
sqliteAuthBadReturnCode	src/auth.c	/^static void sqliteAuthBadReturnCode(Parse *pParse, int rc){$/;"	f	file:
sqliteDefaultBusyCallback	src/main.c	/^static int sqliteDefaultBusyCallback($/;"	f	file:
sqliteDeleteIndex	src/build.c	/^static void sqliteDeleteIndex(Index *p){$/;"	f	file:
sqliteHashCount	src/hash.h	108;"	d
sqliteHashData	src/hash.h	101;"	d
sqliteHashFirst	src/hash.h	99;"	d
sqliteHashKey	src/hash.h	102;"	d
sqliteHashKeysize	src/hash.h	103;"	d
sqliteHashNext	src/hash.h	100;"	d
sqlitePersistTriggerStep	src/trigger.c	/^static void sqlitePersistTriggerStep(sqlite3 *db, TriggerStep *p){$/;"	f	file:
sqliteProcessJoin	src/select.c	/^static int sqliteProcessJoin(Parse *pParse, Select *p){$/;"	f	file:
sqliteResetColumnNames	src/build.c	/^static void sqliteResetColumnNames(Table *pTable){$/;"	f	file:
sqliteViewResetAll	src/build.c	/^static void sqliteViewResetAll(sqlite3 *db, int idx){$/;"	f	file:
sqliteViewResetAll	src/build.c	1806;"	d	file:
sqlite_abort	src/test1.c	/^static int sqlite_abort($/;"	f	file:
sqlite_int64	sqlite3.h	/^  typedef SQLITE_INT64_TYPE sqlite_int64;$/;"	t
sqlite_int64	sqlite3.h	/^  typedef __int64 sqlite_int64;$/;"	t
sqlite_int64	sqlite3.h	/^  typedef long long int sqlite_int64;$/;"	t
sqlite_set_magic	src/test1.c	/^static int sqlite_set_magic($/;"	f	file:
sqlite_static_bind_nbyte	src/test1.c	/^static int sqlite_static_bind_nbyte = 0;$/;"	v	file:
sqlite_static_bind_value	src/test1.c	/^static char *sqlite_static_bind_value = 0;$/;"	v	file:
sqlite_test_close	src/test1.c	/^static int sqlite_test_close($/;"	f	file:
sqlite_uint64	sqlite3.h	/^  typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;$/;"	t
sqlite_uint64	sqlite3.h	/^  typedef unsigned __int64 sqlite_uint64;$/;"	t
sqlite_uint64	sqlite3.h	/^  typedef unsigned long long int sqlite_uint64;$/;"	t
sqlitecon::B1Leave	contrib/sqlitecon.tcl	/^proc sqlitecon::B1Leave {w x y} {$/;"	p
sqlitecon::B1Motion	contrib/sqlitecon.tcl	/^proc sqlitecon::B1Motion {w x y} {$/;"	p
sqlitecon::Backspace	contrib/sqlitecon.tcl	/^proc sqlitecon::Backspace {w} {$/;"	p
sqlitecon::Button1	contrib/sqlitecon.tcl	/^proc sqlitecon::Button1 {w x y} {$/;"	p
sqlitecon::Clear	contrib/sqlitecon.tcl	/^proc sqlitecon::Clear w {$/;"	p
sqlitecon::Copy	contrib/sqlitecon.tcl	/^proc sqlitecon::Copy w {$/;"	p
sqlitecon::Cut	contrib/sqlitecon.tcl	/^proc sqlitecon::Cut w {$/;"	p
sqlitecon::Delete	contrib/sqlitecon.tcl	/^proc sqlitecon::Delete w {$/;"	p
sqlitecon::DoCommand	contrib/sqlitecon.tcl	/^proc sqlitecon::DoCommand {w cmd} {$/;"	p
sqlitecon::EnableEditMenu	contrib/sqlitecon.tcl	/^proc sqlitecon::EnableEditMenu w {$/;"	p
sqlitecon::End	contrib/sqlitecon.tcl	/^proc sqlitecon::End w {$/;"	p
sqlitecon::Enter	contrib/sqlitecon.tcl	/^proc sqlitecon::Enter w {$/;"	p
sqlitecon::EraseEOL	contrib/sqlitecon.tcl	/^proc sqlitecon::EraseEOL {w} {$/;"	p
sqlitecon::Home	contrib/sqlitecon.tcl	/^proc sqlitecon::Home w {$/;"	p
sqlitecon::Insert	contrib/sqlitecon.tcl	/^proc sqlitecon::Insert {w a} {$/;"	p
sqlitecon::Left	contrib/sqlitecon.tcl	/^proc sqlitecon::Left {w} {$/;"	p
sqlitecon::Next	contrib/sqlitecon.tcl	/^proc sqlitecon::Next w {$/;"	p
sqlitecon::Paste	contrib/sqlitecon.tcl	/^proc sqlitecon::Paste w {$/;"	p
sqlitecon::Prior	contrib/sqlitecon.tcl	/^proc sqlitecon::Prior w {$/;"	p
sqlitecon::Right	contrib/sqlitecon.tcl	/^proc sqlitecon::Right {w} {$/;"	p
sqlitecon::SaveFile	contrib/sqlitecon.tcl	/^proc sqlitecon::SaveFile w {$/;"	p
sqlitecon::SelectTo	contrib/sqlitecon.tcl	/^proc sqlitecon::SelectTo {w x y} {$/;"	p
sqlitecon::SetLine	contrib/sqlitecon.tcl	/^proc sqlitecon::SetLine {w line} {$/;"	p
sqlitecon::_edit	contrib/sqlitecon.tcl	/^proc sqlitecon::_edit {origtxt {title {}}} {$/;"	p
sqlitecon::addHistory	contrib/sqlitecon.tcl	/^proc sqlitecon::addHistory {w line} {$/;"	p
sqlitecon::canCut	contrib/sqlitecon.tcl	/^proc sqlitecon::canCut w {$/;"	p
sqlitecon::cancelMotor	contrib/sqlitecon.tcl	/^proc sqlitecon::cancelMotor w {$/;"	p
sqlitecon::create	contrib/sqlitecon.tcl	/^proc sqlitecon::create {w prompt title db} {$/;"	p
sqlitecon::create_child	contrib/sqlitecon.tcl	/^proc sqlitecon::create_child {w prompt editmenu} {$/;"	p
sqlitecon::motor	contrib/sqlitecon.tcl	/^proc sqlitecon::motor w {$/;"	p
sqlitecon::nearestBoundry	contrib/sqlitecon.tcl	/^proc sqlitecon::nearestBoundry {w x y} {$/;"	p
sqlthread_id	src/test_thread.c	/^static int sqlthread_id($/;"	f	file:
sqlthread_open	src/test_thread.c	/^static int sqlthread_open($/;"	f	file:
sqlthread_parent	src/test_thread.c	/^static int sqlthread_parent($/;"	f	file:
sqlthread_proc	src/test_thread.c	/^static Tcl_ObjCmdProc sqlthread_proc;$/;"	v	file:
sqlthread_proc	src/test_thread.c	/^static int sqlthread_proc($/;"	f	file:
sqlthread_spawn	src/test_thread.c	/^static int sqlthread_spawn($/;"	f	file:
sqrFunc	src/test_autoext.c	/^static void sqrFunc($/;"	f	file:
sqr_init	src/test_autoext.c	/^static int sqr_init($/;"	f	file:
stacksize	tool/lemon.c	/^  char *stacksize;         \/* Size of the parser stack *\/$/;"	m	struct:lemon	file:
star_oh	ext/fts1/fts1_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
star_oh	ext/fts2/fts2_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
star_oh	ext/fts3/fts3_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
start	tool/lemon.c	/^  char *start;             \/* Name of the start symbol for the grammar *\/$/;"	m	struct:lemon	file:
startEndFlag	src/os_unix.c	/^  unsigned char startEndFlag;       \/* 1=rel to end of fork, 0=rel to start *\/$/;"	m	struct:ByteRangeLockPB2	file:
startTime	src/vdbeInt.h	/^  i64 startTime;          \/* Time when query started - used for profiling *\/$/;"	m	struct:Vdbe
startsWith	ext/fts1/fts1.c	/^static int startsWith(const char *s, const char *t){$/;"	f	file:
startsWith	ext/fts2/fts2.c	/^static int startsWith(const char *s, const char *t){$/;"	f	file:
startsWith	ext/fts3/fts3.c	/^static int startsWith(const char *s, const char *t){$/;"	f	file:
state	src/pager.c	/^  u8 state;                   \/* PAGER_UNLOCK, _SHARED, _RESERVED, etc. *\/$/;"	m	struct:Pager	file:
state	tool/lemon.c	/^  } state;                   \/* The state of the parser *\/$/;"	m	struct:pstate	typeref:enum:pstate::e_state	file:
state	tool/lemon.c	/^struct state {$/;"	s	file:
stateResortCompare	tool/lemon.c	/^static int stateResortCompare(const void *a, const void *b){$/;"	f	file:
statecmp	tool/lemon.c	/^PRIVATE int statecmp(a,b)$/;"	f
statehash	tool/lemon.c	/^PRIVATE int statehash(a)$/;"	f
stateno	lempar.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
stateno	parse.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
stateno	tool/lempar.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
statenum	tool/lemon.c	/^  int statenum;            \/* Sequencial number for this state *\/$/;"	m	struct:state	file:
statline	tool/spaceanal.tcl	/^proc statline {title value {extra {}}} {$/;"	p
status	tool/lemon.c	/^  } status;$/;"	m	struct:config	typeref:enum:config::__anon8	file:
stdin_is_interactive	src/shell.c	/^static int stdin_is_interactive = 1;$/;"	v	file:
stem	ext/fts1/fts1_porter.c	/^static int stem($/;"	f	file:
stem	ext/fts2/fts2_porter.c	/^static int stem($/;"	f	file:
stem	ext/fts3/fts3_porter.c	/^static int stem($/;"	f	file:
step	src/sqlite3ext.h	/^  int  (*step)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
step_list	src/sqliteInt.h	/^  TriggerStep *step_list; \/* Link list of trigger program steps             *\/$/;"	m	struct:Trigger
stepsql	test/tester.tcl	/^proc stepsql {dbptr sql} {$/;"	p
stfd	src/pager.c	/^  sqlite3_file *stfd;         \/* File descriptor for the statement subjournal*\/$/;"	m	struct:Pager	file:
stifle_history	src/shell.c	44;"	d	file:
stmtAutoopen	src/pager.c	/^  u8 stmtAutoopen;            \/* Open stmt journal when main journal is opened*\/$/;"	m	struct:Pager	file:
stmtCksum	src/pager.c	/^  i64 stmtCksum;              \/* cksumInit when statement was started *\/$/;"	m	struct:Pager	file:
stmtHdrOff	src/pager.c	/^  i64 stmtHdrOff;             \/* First journal header written this statement *\/$/;"	m	struct:Pager	file:
stmtInUse	src/pager.c	/^  u8 stmtInUse;               \/* True we are in a statement subtransaction *\/$/;"	m	struct:Pager	file:
stmtJSize	src/pager.c	/^  i64 stmtJSize;              \/* Size of journal at stmt_begin() *\/$/;"	m	struct:Pager	file:
stmtLast	src/tclsqlite.c	/^  SqlPreparedStmt *stmtLast; \/* Last statement in the list *\/$/;"	m	struct:SqliteDb	file:
stmtList	src/tclsqlite.c	/^  SqlPreparedStmt *stmtList; \/* List of prepared statements*\/$/;"	m	struct:SqliteDb	file:
stmtNRec	src/pager.c	/^  int stmtNRec;               \/* Number of records in stmt subjournal *\/$/;"	m	struct:Pager	file:
stmtOpen	src/pager.c	/^  u8 stmtOpen;                \/* True if the statement subjournal is open *\/$/;"	m	struct:Pager	file:
stmtSize	src/pager.c	/^  int stmtSize;               \/* Size of database (in pages) at stmt_begin() *\/$/;"	m	struct:Pager	file:
stop_thread	src/test4.c	/^static void stop_thread(Thread *p){$/;"	f	file:
stop_thread	src/test7.c	/^static void stop_thread(Thread *p){$/;"	f	file:
storeTypeInfo	src/vdbe.c	171;"	d	file:
stp	tool/lemon.c	/^    struct state *stp;     \/* The new state, if a shift *\/$/;"	m	union:action::__anon9	typeref:struct:action::__anon9::state	file:
stp	tool/lemon.c	/^  struct state *stp;       \/* Pointer to state which contains this *\/$/;"	m	struct:config	typeref:struct:config::state	file:
stp	tool/lemon.c	/^  struct state *stp;   \/* A pointer to a state *\/$/;"	m	struct:axset	typeref:struct:axset::state	file:
strCompare	ext/fts1/fts1_hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strCompare	ext/fts2/fts2_hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strCompare	src/hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strHash	ext/fts1/fts1_hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strHash	ext/fts2/fts2_hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strHash	src/hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strftimeFunc	src/date.c	/^static void strftimeFunc($/;"	f	file:
strhash	tool/lemon.c	/^PRIVATE int strhash(x)$/;"	f
stringBufferData	ext/fts2/fts2.c	/^static char *stringBufferData(StringBuffer *sb){$/;"	f	file:
stringBufferData	ext/fts3/fts3.c	/^static char *stringBufferData(StringBuffer *sb){$/;"	f	file:
stringBufferDestroy	ext/fts2/fts2.c	/^static void stringBufferDestroy(StringBuffer *sb){$/;"	f	file:
stringBufferDestroy	ext/fts3/fts3.c	/^static void stringBufferDestroy(StringBuffer *sb){$/;"	f	file:
stringBufferLength	ext/fts2/fts2.c	/^static int stringBufferLength(StringBuffer *sb){$/;"	f	file:
stringBufferLength	ext/fts3/fts3.c	/^static int stringBufferLength(StringBuffer *sb){$/;"	f	file:
string_concat	src/test8.c	/^static void string_concat(char **pzStr, char *zAppend, int doFree, int *pRc){$/;"	f	file:
string_dup	ext/fts1/fts1.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup	ext/fts2/fts2.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup	ext/fts3/fts3.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup_n	ext/fts1/fts1.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_dup_n	ext/fts2/fts2.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_dup_n	ext/fts3/fts3.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_format	ext/fts1/fts1.c	/^static char *string_format(const char *zFormat,$/;"	f	file:
string_format	ext/fts2/fts2.c	/^static char *string_format(const char *zFormat,$/;"	f	file:
string_format	ext/fts3/fts3.c	/^static char *string_format(const char *zFormat,$/;"	f	file:
subreport	tool/spaceanal.tcl	/^proc subreport {title where} {$/;"	p
substExpr	src/select.c	/^static void substExpr($/;"	f	file:
substExprList	src/select.c	/^static void substExprList($/;"	f	file:
substSelect	src/select.c	/^static void substSelect($/;"	f	file:
substrFunc	src/func.c	/^static void substrFunc($/;"	f	file:
substrId	tool/mkkeywordhash.c	/^  int substrId;        \/* Id to another keyword this keyword is embedded in *\/$/;"	m	struct:Keyword	file:
substrOffset	tool/mkkeywordhash.c	/^  int substrOffset;    \/* Offset into substrId for start of this keyword *\/$/;"	m	struct:Keyword	file:
subsym	tool/lemon.c	/^  struct symbol **subsym;  \/* Array of constituent symbols *\/$/;"	m	struct:symbol	typeref:struct:symbol::symbol	file:
sumFinalize	src/func.c	/^static void sumFinalize(sqlite3_context *context){$/;"	f	file:
sumStep	src/func.c	/^static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
swapMixedEndianFloat	src/vdbeaux.c	1925;"	d	file:
swapMixedEndianFloat	src/vdbeaux.c	1927;"	d	file:
symbol	tool/lemon.c	/^struct symbol {$/;"	s	file:
symbols	tool/lemon.c	/^  struct symbol **symbols; \/* Sorted array of pointers to symbols *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
syncJournal	src/pager.c	/^static int syncJournal(Pager *pPager){$/;"	f	file:
sync_flags	src/pager.c	/^  u8 sync_flags;              \/* One of SYNC_NORMAL or SYNC_FULL *\/$/;"	m	struct:Pager	file:
synthCollSeq	src/callback.c	/^static int synthCollSeq(sqlite3 *db, CollSeq *pColl){$/;"	f	file:
szMaster	src/mem3.c	/^  u32 szMaster;$/;"	m	struct:__anon22	file:
szOsFile	sqlite3.h	/^  int szOsFile;            \/* Size of subclassed sqlite3_file *\/$/;"	m	struct:sqlite3_vfs
szPage	src/mem4.c	/^  int szPage;$/;"	m	struct:__anon18	file:
t1CountCtx	src/test1.c	/^struct t1CountCtx {$/;"	s	file:
t1CountCtx	src/test1.c	/^typedef struct t1CountCtx t1CountCtx;$/;"	t	typeref:struct:t1CountCtx	file:
t1CountFinalize	src/test1.c	/^static void t1CountFinalize(sqlite3_context *context){$/;"	f	file:
t1CountStep	src/test1.c	/^static void t1CountStep($/;"	f	file:
t1ErrorName	src/test1.c	152;"	d	file:
t1_ifnullFunc	src/test1.c	/^static void t1_ifnullFunc($/;"	f	file:
t4Get4byte	src/test3.c	/^static u32 t4Get4byte(unsigned char *p){$/;"	f	file:
table	src/sqliteInt.h	/^  char *table;            \/* The table or view to which the trigger applies *\/$/;"	m	struct:Trigger
tableOfTrigger	src/trigger.c	/^static Table *tableOfTrigger(Trigger *pTrigger){$/;"	f	file:
table_column_metadata	src/sqlite3ext.h	/^  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*);$/;"	m	struct:sqlite3_api_routines
tablesize	tool/lemon.c	/^  int tablesize;           \/* Size of the parse tables *\/$/;"	m	struct:lemon	file:
target	src/sqliteInt.h	/^  Token target;        \/* Valid for DELETE, UPDATE, INSERT steps *\/$/;"	m	struct:TriggerStep
targetSrcList	src/trigger.c	/^static SrcList *targetSrcList($/;"	f	file:
tbl	tool/lemon.c	/^  struct s_x1node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x1	typeref:struct:s_x1::s_x1node	file:
tbl	tool/lemon.c	/^  struct s_x2node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x2	typeref:struct:s_x2::s_x2node	file:
tbl	tool/lemon.c	/^  struct s_x3node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x3	typeref:struct:s_x3::s_x3node	file:
tbl	tool/lemon.c	/^  struct s_x4node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x4	typeref:struct:s_x4::s_x4node	file:
tblHash	src/sqliteInt.h	/^  Hash tblHash;        \/* All tables indexed by name *\/$/;"	m	struct:Schema
tclCollateNeeded	src/tclsqlite.c	/^static void tclCollateNeeded($/;"	f	file:
tclScriptEvent	src/test_thread.c	/^static int tclScriptEvent(Tcl_Event *evPtr, int flags){$/;"	f	file:
tclScriptThread	src/test_thread.c	/^static Tcl_ThreadCreateType tclScriptThread(ClientData pSqlThread){$/;"	f	file:
tclSqlCollate	src/tclsqlite.c	/^static int tclSqlCollate($/;"	f	file:
tclSqlFunc	src/tclsqlite.c	/^static void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){$/;"	f	file:
tcl_client_argc	src/test7.c	/^static int tcl_client_argc($/;"	f	file:
tcl_client_argv	src/test7.c	/^static int tcl_client_argv($/;"	f	file:
tcl_client_colname	src/test7.c	/^static int tcl_client_colname($/;"	f	file:
tcl_client_compile	src/test7.c	/^static int tcl_client_compile($/;"	f	file:
tcl_client_create	src/test7.c	/^static int tcl_client_create($/;"	f	file:
tcl_client_error	src/test7.c	/^static int tcl_client_error($/;"	f	file:
tcl_client_finalize	src/test7.c	/^static int tcl_client_finalize($/;"	f	file:
tcl_client_halt	src/test7.c	/^static int tcl_client_halt($/;"	f	file:
tcl_client_reset	src/test7.c	/^static int tcl_client_reset($/;"	f	file:
tcl_client_result	src/test7.c	/^static int tcl_client_result($/;"	f	file:
tcl_client_step	src/test7.c	/^static int tcl_client_step($/;"	f	file:
tcl_client_swap	src/test7.c	/^static int tcl_client_swap($/;"	f	file:
tcl_client_wait	src/test7.c	/^static int tcl_client_wait($/;"	f	file:
tcl_thread_argc	src/test4.c	/^static int tcl_thread_argc($/;"	f	file:
tcl_thread_argv	src/test4.c	/^static int tcl_thread_argv($/;"	f	file:
tcl_thread_colname	src/test4.c	/^static int tcl_thread_colname($/;"	f	file:
tcl_thread_compile	src/test4.c	/^static int tcl_thread_compile($/;"	f	file:
tcl_thread_create	src/test4.c	/^static int tcl_thread_create($/;"	f	file:
tcl_thread_db_get	src/test4.c	/^static int tcl_thread_db_get($/;"	f	file:
tcl_thread_error	src/test4.c	/^static int tcl_thread_error($/;"	f	file:
tcl_thread_finalize	src/test4.c	/^static int tcl_thread_finalize($/;"	f	file:
tcl_thread_halt	src/test4.c	/^static int tcl_thread_halt($/;"	f	file:
tcl_thread_result	src/test4.c	/^static int tcl_thread_result($/;"	f	file:
tcl_thread_step	src/test4.c	/^static int tcl_thread_step($/;"	f	file:
tcl_thread_stmt_get	src/test4.c	/^static int tcl_thread_stmt_get($/;"	f	file:
tcl_thread_swap	src/test4.c	/^static int tcl_thread_swap($/;"	f	file:
tcl_thread_wait	src/test4.c	/^static int tcl_thread_wait($/;"	f	file:
tcl_variable_type	src/test1.c	/^static int tcl_variable_type($/;"	f	file:
tclvarBestIndex	src/test_tclvar.c	/^static int tclvarBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
tclvarClose	src/test_tclvar.c	/^static int tclvarClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarColumn	src/test_tclvar.c	/^static int tclvarColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
tclvarConnect	src/test_tclvar.c	/^static int tclvarConnect($/;"	f	file:
tclvarDisconnect	src/test_tclvar.c	/^static int tclvarDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
tclvarEof	src/test_tclvar.c	/^static int tclvarEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarFilter	src/test_tclvar.c	/^static int tclvarFilter($/;"	f	file:
tclvarModule	src/test_tclvar.c	/^static sqlite3_module tclvarModule = {$/;"	v	file:
tclvarNext	src/test_tclvar.c	/^static int tclvarNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarOpen	src/test_tclvar.c	/^static int tclvarOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
tclvarRowid	src/test_tclvar.c	/^static int tclvarRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
tclvar_cursor	src/test_tclvar.c	/^struct tclvar_cursor {$/;"	s	file:
tclvar_cursor	src/test_tclvar.c	/^typedef struct tclvar_cursor tclvar_cursor;$/;"	t	typeref:struct:tclvar_cursor	file:
tclvar_vtab	src/test_tclvar.c	/^struct tclvar_vtab {$/;"	s	file:
tclvar_vtab	src/test_tclvar.c	/^typedef struct tclvar_vtab tclvar_vtab;$/;"	t	typeref:struct:tclvar_vtab	file:
tcons	parse.y	/^tcons ::= CHECK LP expr(E) RP onconf. {sqlite3AddCheckConstraint(pParse,E);}$/;"	l
tcons	parse.y	/^tcons ::= CONSTRAINT nm.$/;"	l
tcons	parse.y	/^tcons ::= FOREIGN KEY LP idxlist(FA) RP$/;"	l
tcons	parse.y	/^tcons ::= PRIMARY KEY LP idxlist(X) autoinc(I) RP onconf(R).$/;"	l
tcons	parse.y	/^tcons ::= UNIQUE LP idxlist(X) RP onconf(R).$/;"	l
tcons	src/parse.y	/^tcons ::= CHECK LP expr(E) RP onconf. {sqlite3AddCheckConstraint(pParse,E);}$/;"	l
tcons	src/parse.y	/^tcons ::= CONSTRAINT nm.$/;"	l
tcons	src/parse.y	/^tcons ::= FOREIGN KEY LP idxlist(FA) RP$/;"	l
tcons	src/parse.y	/^tcons ::= PRIMARY KEY LP idxlist(X) autoinc(I) RP onconf(R).$/;"	l
tcons	src/parse.y	/^tcons ::= UNIQUE LP idxlist(X) RP onconf(R).$/;"	l
tempFile	src/pager.c	/^  u8 tempFile;                \/* zFilename is a temporary file *\/$/;"	m	struct:Pager	file:
temp_store	src/sqliteInt.h	/^  u8 temp_store;                \/* 1: file 2: memory 0: default *\/$/;"	m	struct:sqlite3
term	ext/fts2/fts2.c	/^  DataBuffer term;                \/* previous encoded term *\/$/;"	m	struct:LeafWriter	file:
term	ext/fts2/fts2.c	/^  DataBuffer term;               \/* Last term written to block "last". *\/$/;"	m	struct:InteriorWriter	file:
term	ext/fts2/fts2.c	/^  DataBuffer term;           \/* Leftmost term in block's subtree. *\/$/;"	m	struct:InteriorBlock	file:
term	ext/fts2/fts2.c	/^  DataBuffer term;          \/* copy of current term. *\/$/;"	m	struct:LeafReader	file:
term	ext/fts2/fts2.c	/^  DataBuffer term;          \/* previous term, for decoding term delta. *\/$/;"	m	struct:InteriorReader	file:
term	ext/fts3/fts3.c	/^  DataBuffer term;                \/* previous encoded term *\/$/;"	m	struct:LeafWriter	file:
term	ext/fts3/fts3.c	/^  DataBuffer term;               \/* Last term written to block "last". *\/$/;"	m	struct:InteriorWriter	file:
term	ext/fts3/fts3.c	/^  DataBuffer term;           \/* Leftmost term in block's subtree. *\/$/;"	m	struct:InteriorBlock	file:
term	ext/fts3/fts3.c	/^  DataBuffer term;          \/* copy of current term. *\/$/;"	m	struct:LeafReader	file:
term	ext/fts3/fts3.c	/^  DataBuffer term;          \/* previous term, for decoding term delta. *\/$/;"	m	struct:InteriorReader	file:
termDataCmp	ext/fts2/fts2.c	/^static int termDataCmp(const void *av, const void *bv){$/;"	f	file:
termDataCmp	ext/fts3/fts3.c	/^static int termDataCmp(const void *av, const void *bv){$/;"	f	file:
termSelect	ext/fts2/fts2.c	/^static int termSelect(fulltext_vtab *v, int iColumn,$/;"	f	file:
termSelect	ext/fts3/fts3.c	/^static int termSelect(fulltext_vtab *v, int iColumn,$/;"	f	file:
term_delete	ext/fts1/fts1.c	/^static int term_delete(fulltext_vtab *v, sqlite_int64 rowid){$/;"	f	file:
term_insert	ext/fts1/fts1.c	/^static int term_insert(fulltext_vtab *v, sqlite_int64 *piRowid,$/;"	f	file:
term_select	ext/fts1/fts1.c	/^static int term_select(fulltext_vtab *v, const char *pTerm, int nTerm,$/;"	f	file:
term_select_all	ext/fts1/fts1.c	/^static int term_select_all($/;"	f	file:
term_update	ext/fts1/fts1.c	/^static int term_update(fulltext_vtab *v, sqlite_int64 rowid,$/;"	f	file:
testAsyncDelay	src/test_async.c	/^static int testAsyncDelay($/;"	f	file:
testAsyncEnable	src/test_async.c	/^static int testAsyncEnable($/;"	f	file:
testAsyncHalt	src/test_async.c	/^static int testAsyncHalt($/;"	f	file:
testAsyncStart	src/test_async.c	/^static int testAsyncStart($/;"	f	file:
testAsyncWait	src/test_async.c	/^static int testAsyncWait($/;"	f	file:
testCreateCollationCmp	src/test1.c	/^static int testCreateCollationCmp($/;"	f	file:
testCreateCollationDel	src/test1.c	/^static void testCreateCollationDel(void *pCtx){$/;"	f	file:
testFunc	ext/fts2/fts2_tokenizer.c	/^static void testFunc($/;"	f	file:
testFunc	ext/fts3/fts3_tokenizer.c	/^static void testFunc($/;"	f	file:
testFunc	src/test1.c	/^static void testFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
testHexToInt	src/test1.c	/^static int testHexToInt(int h){$/;"	f	file:
testThreadLockingBehavior	src/os_unix.c	/^static void testThreadLockingBehavior(int fd_orig){$/;"	f	file:
test_auxdata	src/func.c	/^static void test_auxdata($/;"	f	file:
test_bind	src/test1.c	/^static int test_bind($/;"	f	file:
test_bind_blob	src/test1.c	/^static int test_bind_blob($/;"	f	file:
test_bind_double	src/test1.c	/^static int test_bind_double($/;"	f	file:
test_bind_int	src/test1.c	/^static int test_bind_int($/;"	f	file:
test_bind_int64	src/test1.c	/^static int test_bind_int64($/;"	f	file:
test_bind_null	src/test1.c	/^static int test_bind_null($/;"	f	file:
test_bind_parameter_count	src/test1.c	/^static int test_bind_parameter_count($/;"	f	file:
test_bind_parameter_index	src/test1.c	/^static int test_bind_parameter_index($/;"	f	file:
test_bind_parameter_name	src/test1.c	/^static int test_bind_parameter_name($/;"	f	file:
test_bind_text	src/test1.c	/^static int test_bind_text($/;"	f	file:
test_bind_text16	src/test1.c	/^static int test_bind_text16($/;"	f	file:
test_bind_zeroblob	src/test1.c	/^static int test_bind_zeroblob($/;"	f	file:
test_blob_read	src/test1.c	/^static int test_blob_read($/;"	f	file:
test_blob_write	src/test1.c	/^static int test_blob_write($/;"	f	file:
test_breakpoint	src/test1.c	/^static int test_breakpoint($/;"	f	file:
test_busy_timeout	src/test1.c	/^static int test_busy_timeout($/;"	f	file:
test_changes	src/test1.c	/^static int test_changes($/;"	f	file:
test_clear_bindings	src/test1.c	/^static int test_clear_bindings($/;"	f	file:
test_collate	src/test1.c	/^static int test_collate($/;"	f	file:
test_collate_func	src/test1.c	/^static int test_collate_func($/;"	f	file:
test_collate_needed	src/test1.c	/^static int test_collate_needed($/;"	f	file:
test_collate_needed_cb	src/test1.c	/^static void test_collate_needed_cb($/;"	f	file:
test_column_blob	src/test1.c	/^static int test_column_blob($/;"	f	file:
test_column_count	src/test1.c	/^static int test_column_count($/;"	f	file:
test_column_double	src/test1.c	/^static int test_column_double($/;"	f	file:
test_column_int64	src/test1.c	/^static int test_column_int64($/;"	f	file:
test_column_type	src/test1.c	/^static int test_column_type($/;"	f	file:
test_complete16	src/test1.c	/^static int test_complete16($/;"	f	file:
test_create_aggregate	src/test1.c	/^static int test_create_aggregate($/;"	f	file:
test_create_collation_v2	src/test1.c	/^static int test_create_collation_v2($/;"	f	file:
test_create_function	src/test1.c	/^static int test_create_function($/;"	f	file:
test_data_count	src/test1.c	/^static int test_data_count($/;"	f	file:
test_destructor	src/func.c	/^static void test_destructor($/;"	f	file:
test_destructor_count	src/func.c	/^static void test_destructor_count($/;"	f	file:
test_destructor_count_var	src/func.c	/^static int test_destructor_count_var = 0;$/;"	v	file:
test_enable_load	src/test1.c	/^static int test_enable_load($/;"	f	file:
test_enable_shared	src/test1.c	/^static int test_enable_shared($/;"	f	file:
test_errcode	src/test1.c	/^static int test_errcode($/;"	f	file:
test_errmsg	src/test1.c	/^static int test_errmsg($/;"	f	file:
test_errmsg16	src/test1.c	/^static int test_errmsg16($/;"	f	file:
test_error	src/func.c	/^static void test_error($/;"	f	file:
test_errstr	src/test1.c	/^static int test_errstr($/;"	f	file:
test_exec	src/test1.c	/^static int test_exec($/;"	f	file:
test_exec_nr	src/test1.c	/^static int test_exec_nr($/;"	f	file:
test_exec_printf	src/test1.c	/^static int test_exec_printf($/;"	f	file:
test_expired	src/test1.c	/^static int test_expired($/;"	f	file:
test_extended_result_codes	src/test1.c	/^static int test_extended_result_codes($/;"	f	file:
test_finalize	src/test1.c	/^static int test_finalize($/;"	f	file:
test_free	src/test_malloc.c	/^static int test_free($/;"	f	file:
test_function	src/test1.c	/^static int test_function($/;"	f	file:
test_function_utf16be	src/test1.c	/^static void test_function_utf16be($/;"	f	file:
test_function_utf16le	src/test1.c	/^static void test_function_utf16le($/;"	f	file:
test_function_utf8	src/test1.c	/^static void test_function_utf8($/;"	f	file:
test_get_table_printf	src/test1.c	/^static int test_get_table_printf($/;"	f	file:
test_global_recover	src/test1.c	/^static int test_global_recover($/;"	f	file:
test_interrupt	src/test1.c	/^static int test_interrupt($/;"	f	file:
test_io_trace	src/test1.c	/^static int test_io_trace($/;"	f	file:
test_key	src/test1.c	/^static int test_key($/;"	f	file:
test_last_rowid	src/test1.c	/^static int test_last_rowid($/;"	f	file:
test_libversion_number	src/test1.c	/^static int test_libversion_number($/;"	f	file:
test_load_extension	src/test1.c	/^static int test_load_extension($/;"	f	file:
test_malloc	src/test_malloc.c	/^static int test_malloc($/;"	f	file:
test_memdebug_backtrace	src/test_malloc.c	/^static int test_memdebug_backtrace($/;"	f	file:
test_memdebug_dump	src/test_malloc.c	/^static int test_memdebug_dump($/;"	f	file:
test_memdebug_fail	src/test_malloc.c	/^static int test_memdebug_fail($/;"	f	file:
test_memdebug_pending	src/test_malloc.c	/^static int test_memdebug_pending($/;"	f	file:
test_memdebug_settitle	src/test_malloc.c	/^static int test_memdebug_settitle($/;"	f	file:
test_memget	src/test_malloc.c	/^static int test_memget($/;"	f	file:
test_memory_highwater	src/test_malloc.c	/^static int test_memory_highwater($/;"	f	file:
test_memory_used	src/test_malloc.c	/^static int test_memory_used($/;"	f	file:
test_memset	src/test_malloc.c	/^static int test_memset($/;"	f	file:
test_mprintf_n	src/test1.c	/^static int test_mprintf_n($/;"	f	file:
test_mprintf_z	src/test1.c	/^static int test_mprintf_z($/;"	f	file:
test_open	src/test1.c	/^static int test_open($/;"	f	file:
test_open16	src/test1.c	/^static int test_open16($/;"	f	file:
test_pager_refcounts	src/test1.c	/^static int test_pager_refcounts($/;"	f	file:
test_pagesize	src/test2.c	/^static int test_pagesize = 1024;$/;"	v	file:
test_prepare	src/test1.c	/^static int test_prepare($/;"	f	file:
test_prepare16	src/test1.c	/^static int test_prepare16($/;"	f	file:
test_prepare16_v2	src/test1.c	/^static int test_prepare16_v2($/;"	f	file:
test_prepare_v2	src/test1.c	/^static int test_prepare_v2($/;"	f	file:
test_printf	src/test1.c	/^static int test_printf($/;"	f	file:
test_realloc	src/test_malloc.c	/^static int test_realloc($/;"	f	file:
test_register_func	src/test1.c	/^static int test_register_func($/;"	f	file:
test_rekey	src/test1.c	/^static int test_rekey($/;"	f	file:
test_release_memory	src/test1.c	/^static int test_release_memory($/;"	f	file:
test_reset	src/test1.c	/^static int test_reset($/;"	f	file:
test_sleep	src/test1.c	/^static int test_sleep($/;"	f	file:
test_snprintf_int	src/test1.c	/^static int test_snprintf_int($/;"	f	file:
test_soft_heap_limit	src/test1.c	/^static int test_soft_heap_limit($/;"	f	file:
test_stack_used	src/test1.c	/^static int test_stack_used($/;"	f	file:
test_step	src/test1.c	/^static int test_step($/;"	f	file:
test_stmt_int	src/test1.c	/^static int test_stmt_int($/;"	f	file:
test_stmt_utf16	src/test1.c	/^static int test_stmt_utf16($/;"	f	file:
test_stmt_utf8	src/test1.c	/^static int test_stmt_utf8($/;"	f	file:
test_table_column_metadata	src/test1.c	/^static int test_table_column_metadata($/;"	f	file:
test_thread_cleanup	src/test1.c	/^static int test_thread_cleanup($/;"	f	file:
test_transfer_bind	src/test1.c	/^static int test_transfer_bind($/;"	f	file:
test_translate	src/test5.c	/^static int test_translate($/;"	f	file:
test_translate_selftest	src/test5.c	/^static int test_translate_selftest($/;"	f	file:
test_value_overhead	src/test5.c	/^static int test_value_overhead($/;"	f	file:
testbrokenext_init	src/test_loadext.c	/^int testbrokenext_init($/;"	f
testloadext_init	src/test_loadext.c	/^int testloadext_init($/;"	f
textToPointer	src/test_malloc.c	/^static int textToPointer(const char *z, void **pp){$/;"	f	file:
tgetent	configure	/^tgetent ();$/;"	f
threadLockingTest	src/os_unix.c	/^static void *threadLockingTest(void *pArg){$/;"	f	file:
threadTestData	src/os_unix.c	/^struct threadTestData {$/;"	s	file:
thread_cleanup	src/sqlite3ext.h	/^  void  (*thread_cleanup)(void);$/;"	m	struct:sqlite3_api_routines
thread_cnt	test/threadtest1.c	/^int thread_cnt = 0;$/;"	v
thread_main	src/test4.c	/^static void *thread_main(void *pArg){$/;"	f	file:
thread_spawn	test/thread_common.tcl	/^proc thread_spawn {varname args} {$/;"	p
thread_wait	src/test4.c	/^static void thread_wait(Thread *p){$/;"	f	file:
threadid	src/os_unix.c	142;"	d	file:
threadid	src/os_unix.c	144;"	d	file:
threadsOverrideEachOthersLocks	src/os_unix.c	/^int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;$/;"	v
threadsOverrideEachOthersLocks	src/os_unix.c	/^static int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;$/;"	v	file:
threadset	src/test4.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
threadset	src/test7.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
tid	src/os_unix.c	/^  pthread_t tid;            \/* The thread that "owns" this unixFile *\/$/;"	m	struct:unixFile	file:
tid	src/os_unix.c	/^  pthread_t tid;   \/* Thread ID or zero if threads can override each other *\/$/;"	m	struct:lockKey	file:
timeDiff	src/shell.c	/^static int timeDiff(struct timeval *pStart, struct timeval *pEnd){$/;"	f	file:
timeFunc	src/date.c	/^static void timeFunc($/;"	f	file:
tkCREATE	src/complete.c	47;"	d	file:
tkEND	src/complete.c	50;"	d	file:
tkEXPLAIN	src/complete.c	46;"	d	file:
tkOTHER	src/complete.c	45;"	d	file:
tkSEMI	src/complete.c	43;"	d	file:
tkTEMP	src/complete.c	48;"	d	file:
tkTRIGGER	src/complete.c	49;"	d	file:
tkWS	src/complete.c	44;"	d	file:
tkt2213Function	src/test1.c	/^static void tkt2213Function($/;"	f	file:
tmpCheckReservedLock	src/test_onefile.c	/^static int tmpCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
tmpClose	src/test_onefile.c	/^static int tmpClose(sqlite3_file *pFile){$/;"	f	file:
tmpDeviceCharacteristics	src/test_onefile.c	/^static int tmpDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
tmpFileControl	src/test_onefile.c	/^static int tmpFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
tmpFileSize	src/test_onefile.c	/^static int tmpFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
tmpLock	src/test_onefile.c	/^static int tmpLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpRead	src/test_onefile.c	/^static int tmpRead($/;"	f	file:
tmpSectorSize	src/test_onefile.c	/^static int tmpSectorSize(sqlite3_file *pFile){$/;"	f	file:
tmpSync	src/test_onefile.c	/^static int tmpSync(sqlite3_file *pFile, int flags){$/;"	f	file:
tmpTruncate	src/test_onefile.c	/^static int tmpTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
tmpUnlock	src/test_onefile.c	/^static int tmpUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpWrite	src/test_onefile.c	/^static int tmpWrite($/;"	f	file:
tmp_file	src/test_onefile.c	/^struct tmp_file {$/;"	s	file:
tmp_file	src/test_onefile.c	/^typedef struct tmp_file tmp_file;$/;"	t	typeref:struct:tmp_file	file:
tmp_io_methods	src/test_onefile.c	/^static sqlite3_io_methods tmp_io_methods = {$/;"	v	file:
tnum	src/sqliteInt.h	/^  int tnum;        \/* Page containing root of this index in database file *\/$/;"	m	struct:Index
tnum	src/sqliteInt.h	/^  int tnum;        \/* Root BTree node for this table (see note above) *\/$/;"	m	struct:Table
token	src/sqliteInt.h	/^  Token token;           \/* An operand token *\/$/;"	m	struct:Expr
tokenListToIdList	ext/fts1/fts1.c	/^static void tokenListToIdList(char **azIn){$/;"	f	file:
tokenListToIdList	ext/fts2/fts2.c	/^static void tokenListToIdList(char **azIn){$/;"	f	file:
tokenListToIdList	ext/fts3/fts3.c	/^static void tokenListToIdList(char **azIn){$/;"	f	file:
tokendest	tool/lemon.c	/^  char *tokendest;         \/* Code to execute to destroy token data *\/$/;"	m	struct:lemon	file:
tokendestln	tool/lemon.c	/^  int  tokendestln;        \/* Line number for token destroyer code *\/$/;"	m	struct:lemon	file:
tokenizeSegment	ext/fts1/fts1.c	/^static int tokenizeSegment($/;"	f	file:
tokenizeSegment	ext/fts2/fts2.c	/^static int tokenizeSegment($/;"	f	file:
tokenizeSegment	ext/fts3/fts3.c	/^static int tokenizeSegment($/;"	f	file:
tokenizeString	ext/fts1/fts1.c	/^static char **tokenizeString(const char *z, int *pnToken){$/;"	f	file:
tokenizeString	ext/fts2/fts2.c	/^static char **tokenizeString(const char *z, int *pnToken){$/;"	f	file:
tokenizeString	ext/fts3/fts3.c	/^static char **tokenizeString(const char *z, int *pnToken){$/;"	f	file:
tokenlineno	tool/lemon.c	/^  int tokenlineno;      \/* Linenumber at which current token starts *\/$/;"	m	struct:pstate	file:
tokenprefix	tool/lemon.c	/^  char *tokenprefix;       \/* A prefix added to token names in the .h file *\/$/;"	m	struct:lemon	file:
tokenstart	tool/lemon.c	/^  char *tokenstart;     \/* Text of current token *\/$/;"	m	struct:pstate	file:
tokentype	tool/lemon.c	/^  char *tokentype;         \/* Type of terminal symbols in the parser stack *\/$/;"	m	struct:lemon	file:
tooBig	src/sqliteInt.h	/^  u8   tooBig;         \/* Becomes true if string size exceeds limits *\/$/;"	m	struct:StrAccum
top	src/sqliteInt.h	/^  int top;              \/* First instruction of interior of the loop *\/$/;"	m	struct:WhereLevel
topAddr	src/sqliteInt.h	/^    int topAddr;           \/* Top of the IN loop *\/$/;"	m	struct:WhereLevel::InLoop
totalFinalize	src/func.c	/^static void totalFinalize(sqlite3_context *context){$/;"	f	file:
total_changes	src/func.c	/^static void total_changes($/;"	f	file:
total_changes	src/sqlite3ext.h	/^  int  (*total_changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
tplt_linedir	tool/lemon.c	/^PRIVATE void tplt_linedir(out,lineno,filename)$/;"	f
tplt_open	tool/lemon.c	/^PRIVATE FILE *tplt_open(lemp)$/;"	f
tplt_print	tool/lemon.c	/^PRIVATE void tplt_print(out,lemp,str,strln,lineno)$/;"	f
tplt_xfer	tool/lemon.c	/^PRIVATE void tplt_xfer(name,in,out,lineno)$/;"	f
tr_tm	src/sqliteInt.h	/^  u8 tr_tm;               \/* One of TRIGGER_BEFORE, TRIGGER_AFTER *\/$/;"	m	struct:Trigger
trace	src/mutex_unix.c	/^  int trace;                 \/* True to trace changes *\/$/;"	m	struct:sqlite3_mutex	file:
trace	src/sqlite3ext.h	/^  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);$/;"	m	struct:sqlite3_api_routines
trace	src/vdbeInt.h	/^  FILE *trace;        \/* Write an execution trace here, if not NULL *\/$/;"	m	struct:Vdbe
trans_opt	parse.y	/^trans_opt ::= .$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION nm.$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION.$/;"	l
trans_opt	src/parse.y	/^trans_opt ::= .$/;"	l
trans_opt	src/parse.y	/^trans_opt ::= TRANSACTION nm.$/;"	l
trans_opt	src/parse.y	/^trans_opt ::= TRANSACTION.$/;"	l
transferJoinMarkings	src/where.c	/^static void transferJoinMarkings(Expr *pDerived, Expr *pBase){$/;"	f	file:
transferOwnership	src/os_unix.c	/^static int transferOwnership(unixFile *pFile){$/;"	f	file:
transferOwnership	src/os_unix.c	769;"	d	file:
transfer_bindings	src/sqlite3ext.h	/^  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
translate_code	tool/lemon.c	/^PRIVATE void translate_code(struct lemon *lemp, struct rule *rp){$/;"	f
trigHash	src/sqliteInt.h	/^  Hash trigHash;       \/* All triggers indexed by name *\/$/;"	m	struct:Schema
trigStack	src/sqliteInt.h	/^  TriggerStack *trigStack;  \/* Trigger actions being coded *\/$/;"	m	struct:Parse
trimFunc	src/func.c	/^static void trimFunc($/;"	f	file:
trimSnippetOffsetsForNear	ext/fts3/fts3.c	/^static void trimSnippetOffsetsForNear(Query *pQuery, Snippet *pSnippet){$/;"	f	file:
trimWhiteSpace	ext/fts1/fts1.c	/^static void trimWhiteSpace(StringBuffer *p){$/;"	f	file:
trimWhiteSpace	ext/fts2/fts2.c	/^static void trimWhiteSpace(StringBuffer *p){$/;"	f	file:
trimWhiteSpace	ext/fts3/fts3.c	/^static void trimWhiteSpace(StringBuffer *p){$/;"	f	file:
type	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	m	struct:AttachKey	file:
type	parse.y	/^type ::= .$/;"	l
type	parse.y	/^type ::= typetoken(X).                   {sqlite3AddColumnType(pParse,&X);}$/;"	l
type	src/parse.y	/^type ::= .$/;"	l
type	src/parse.y	/^type ::= typetoken(X).                   {sqlite3AddColumnType(pParse,&X);}$/;"	l
type	src/printf.c	/^  etByte type;             \/* Conversion paradigm *\/$/;"	m	struct:et_info	file:
type	src/sqliteInt.h	/^  u8 type;              \/* One of the SQLITE_COLL_... values below *\/$/;"	m	struct:CollSeq
type	src/vdbeInt.h	/^  u8  type;           \/* One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc *\/$/;"	m	struct:Mem
type	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	m	struct:s_options	typeref:enum:s_options::__anon5	file:
type	tool/lemon.c	/^  } type;                  \/* Symbols are all either TERMINALS or NTs *\/$/;"	m	struct:symbol	typeref:enum:symbol::__anon7	file:
type	tool/lemon.c	/^  } type;$/;"	m	struct:action	typeref:enum:action::e_action	file:
typeofFunc	src/func.c	/^static void typeofFunc($/;"	f	file:
tz	src/date.c	/^  int tz;          \/* Timezone offset in minutes *\/$/;"	m	struct:DateTime	file:
u	src/mem3.c	/^  } u;$/;"	m	struct:Mem3Block	typeref:union:Mem3Block::__anon19	file:
u	src/vdbeInt.h	/^  } u;$/;"	m	struct:Mem	typeref:union:Mem::__anon17
u1	src/sqliteInt.h	/^  } u1;$/;"	m	struct:sqlite3	typeref:union:sqlite3::__anon13
u16	src/sqliteInt.h	/^typedef UINT16_TYPE u16;           \/* 2-byte unsigned integer *\/$/;"	t
u32	src/sqliteInt.h	/^typedef UINT32_TYPE u32;           \/* 4-byte unsigned integer *\/$/;"	t
u64	src/sqliteInt.h	/^typedef sqlite_uint64 u64;         \/* 8-byte unsigned integer *\/$/;"	t
u8	src/sqliteInt.h	/^typedef UINT8_TYPE u8;             \/* 1-byte unsigned integer *\/$/;"	t
uint32	src/test_md5.c	44;"	d	file:
unLockFlag	src/os_unix.c	/^  unsigned char unLockFlag;         \/* 1 = unlock, 0 = lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
unaligned_string_counter	src/test1.c	/^static int unaligned_string_counter = 0;$/;"	v	file:
unicodeToMbcs	src/os_win.c	/^static char *unicodeToMbcs(const WCHAR *zWideFilename){$/;"	f	file:
unicodeToUtf8	src/os_win.c	/^static char *unicodeToUtf8(const WCHAR *zWideFilename){$/;"	f	file:
uniqueCnt	src/vdbeInt.h	/^  unsigned uniqueCnt;     \/* Used by OP_MakeRecord when P2!=0 *\/$/;"	m	struct:Vdbe
unixAccess	src/os_unix.c	/^static int unixAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
unixCheckReservedLock	src/os_unix.c	/^static int unixCheckReservedLock(sqlite3_file *id){$/;"	f	file:
unixClose	src/os_unix.c	/^static int unixClose(sqlite3_file *id){$/;"	f	file:
unixCurrentTime	src/os_unix.c	/^static int unixCurrentTime(sqlite3_vfs *pVfs, double *prNow){$/;"	f	file:
unixDelete	src/os_unix.c	/^static int unixDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
unixDeviceCharacteristics	src/os_unix.c	/^static int unixDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
unixDlClose	src/os_unix.c	/^static void unixDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
unixDlClose	src/os_unix.c	2633;"	d	file:
unixDlError	src/os_unix.c	/^static void unixDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
unixDlError	src/os_unix.c	2631;"	d	file:
unixDlOpen	src/os_unix.c	/^static void *unixDlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
unixDlOpen	src/os_unix.c	2630;"	d	file:
unixDlSym	src/os_unix.c	/^static void *unixDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
unixDlSym	src/os_unix.c	2632;"	d	file:
unixFile	src/os_unix.c	/^struct unixFile {$/;"	s	file:
unixFile	src/os_unix.c	/^typedef struct unixFile unixFile;$/;"	t	typeref:struct:unixFile	file:
unixFileControl	src/os_unix.c	/^static int unixFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
unixFileSize	src/os_unix.c	/^static int unixFileSize(sqlite3_file *id, i64 *pSize){$/;"	f	file:
unixFullPathname	src/os_unix.c	/^static int unixFullPathname($/;"	f	file:
unixGetTempname	src/os_unix.c	/^static int unixGetTempname(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
unixLock	src/os_unix.c	/^static int unixLock(sqlite3_file *id, int locktype){$/;"	f	file:
unixOpen	src/os_unix.c	/^static int unixOpen($/;"	f	file:
unixRandomness	src/os_unix.c	/^static int unixRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
unixRead	src/os_unix.c	/^static int unixRead($/;"	f	file:
unixSectorSize	src/os_unix.c	/^static int unixSectorSize(sqlite3_file *id){$/;"	f	file:
unixSleep	src/os_unix.c	/^static int unixSleep(sqlite3_vfs *pVfs, int microseconds){$/;"	f	file:
unixSync	src/os_unix.c	/^static int unixSync(sqlite3_file *id, int flags){$/;"	f	file:
unixTruncate	src/os_unix.c	/^static int unixTruncate(sqlite3_file *id, i64 nByte){$/;"	f	file:
unixUnlock	src/os_unix.c	/^static int unixUnlock(sqlite3_file *id, int locktype){$/;"	f	file:
unixWrite	src/os_unix.c	/^static int unixWrite($/;"	f	file:
unlikely	src/sqliteInt.h	27;"	d
unlikely	src/sqliteInt.h	30;"	d
unlinkAsyncFile	src/test_async.c	/^static int unlinkAsyncFile(AsyncFileData *pData){$/;"	f	file:
unlinkHashChain	src/pager.c	/^static void unlinkHashChain(Pager *pPager, PgHdr *pPg){$/;"	f	file:
unlinkPage	src/pager.c	/^static void unlinkPage(PgHdr *pPg){$/;"	f	file:
unlockAllTables	src/btree.c	/^static void unlockAllTables(Btree *p){$/;"	f	file:
unlockAllTables	src/btree.c	85;"	d	file:
unlockBtreeIfUnused	src/btree.c	/^static void unlockBtreeIfUnused(BtShared *pBt){$/;"	f	file:
unlockReadLock	src/os_os2.c	/^static int unlockReadLock( os2File *id ){$/;"	f	file:
unlockReadLock	src/os_win.c	/^static int unlockReadLock(winFile *pFile){$/;"	f	file:
unsupportedLockingStyle	src/os_unix.c	/^        unsupportedLockingStyle      \/* indicates unsupported file system *\/$/;"	e	enum:__anon15	file:
updateAccumulator	src/select.c	/^static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
updateConf	src/sqliteInt.h	/^  u8 updateConf;    \/* How to resolve conflicts that occur on UPDATE *\/$/;"	m	struct:FKey
updateMaxBlobsize	src/vdbe.c	/^static void updateMaxBlobsize(Mem *p){$/;"	f	file:
updateVirtualTable	src/update.c	/^static void updateVirtualTable($/;"	f	file:
update_hook	src/sqlite3ext.h	/^  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,sqlite_int64),void*);$/;"	m	struct:sqlite3_api_routines
upperFunc	src/func.c	/^static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
usable	sqlite3.h	/^     unsigned char usable;     \/* True if this constraint is usable *\/$/;"	m	struct:sqlite3_index_info::sqlite3_index_constraint
usableSize	src/btreeInt.h	/^  u16 usableSize;       \/* Number of usable bytes on each page *\/$/;"	m	struct:BtShared
usage	src/shell.c	/^static void usage(int showDetail){$/;"	f	file:
usage	tool/memleak3.tcl	/^proc usage {} {$/;"	p
useCnt	tool/lemon.c	/^  int useCnt;              \/* Number of times used *\/$/;"	m	struct:symbol	file:
useEvalObjv	src/tclsqlite.c	/^  int useEvalObjv;      \/* True if it is safe to use Tcl_EvalObjv *\/$/;"	m	struct:SqlFunc	file:
useJournal	src/pager.c	/^  u8 useJournal;              \/* Use a rollback journal on this file *\/$/;"	m	struct:Pager	file:
useMalloc	src/sqliteInt.h	/^  u8   useMalloc;      \/* True if zText is enlargable using realloc *\/$/;"	m	struct:StrAccum
useRandomRowid	src/vdbeInt.h	/^  Bool useRandomRowid;  \/* Generate new record numbers semi-randomly *\/$/;"	m	struct:Cursor
useSortingIdx	src/sqliteInt.h	/^  u8 useSortingIdx;       \/* In direct mode, reference the sorting index rather$/;"	m	struct:AggInfo
user_data	src/sqlite3ext.h	/^  void * (*user_data)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
usesEphm	src/sqliteInt.h	/^  u8 usesEphm;           \/* True if uses an OpenEphemeral opcode *\/$/;"	m	struct:Select
utf8ToMbcs	src/os_win.c	/^static char *utf8ToMbcs(const char *zFilename){$/;"	f	file:
utf8ToUnicode	src/os_win.c	/^static WCHAR *utf8ToUnicode(const char *zFilename){$/;"	f	file:
utf8_to_utf8	src/test_hexio.c	/^static int utf8_to_utf8($/;"	f	file:
valid	src/shell.c	/^  int valid;        \/* Is there legit data in here? *\/$/;"	m	struct:previous_mode_data	file:
validHMS	src/date.c	/^  char validHMS;   \/* True if h,m,s are valid *\/$/;"	m	struct:DateTime	file:
validJD	src/date.c	/^  char validJD;    \/* True if rJD is valid *\/$/;"	m	struct:DateTime	file:
validTZ	src/date.c	/^  char validTZ;    \/* True if tz is valid *\/$/;"	m	struct:DateTime	file:
validYMD	src/date.c	/^  char validYMD;   \/* True if Y,M,D are valid *\/$/;"	m	struct:DateTime	file:
value	parse.c	/^  struct {int value; int mask;} yy405;$/;"	m	struct:__anon25::__anon26	file:
value_blob	src/sqlite3ext.h	/^  const void * (*value_blob)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes	src/sqlite3ext.h	/^  int  (*value_bytes)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes16	src/sqlite3ext.h	/^  int  (*value_bytes16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_double	src/sqlite3ext.h	/^  double  (*value_double)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int	src/sqlite3ext.h	/^  int  (*value_int)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int64	src/sqlite3ext.h	/^  sqlite_int64  (*value_int64)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_numeric_type	src/sqlite3ext.h	/^  int  (*value_numeric_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text	src/sqlite3ext.h	/^  const unsigned char * (*value_text)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16	src/sqlite3ext.h	/^  const void * (*value_text16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16be	src/sqlite3ext.h	/^  const void * (*value_text16be)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16le	src/sqlite3ext.h	/^  const void * (*value_text16le)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_type	src/sqlite3ext.h	/^  int  (*value_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
vardest	tool/lemon.c	/^  char *vardest;           \/* Code for the default non-terminal destructor *\/$/;"	m	struct:lemon	file:
vardestln	tool/lemon.c	/^  int  vardestln;          \/* Line number for default non-term destructor code*\/$/;"	m	struct:lemon	file:
vartype	tool/lemon.c	/^  char *vartype;           \/* The default type of non-terminal symbols *\/$/;"	m	struct:lemon	file:
vdbeCommit	src/vdbeaux.c	/^static int vdbeCommit(sqlite3 *db){$/;"	f	file:
vdbeUnbind	src/vdbeapi.c	/^static int vdbeUnbind(Vdbe *p, int i){$/;"	f	file:
verbose	test/threadtest1.c	/^static int verbose = 0;$/;"	v	file:
versionFunc	src/func.c	/^static void versionFunc($/;"	f	file:
vfsFlags	src/pager.c	/^  u32 vfsFlags;               \/* Flags for sqlite3_vfs.xOpen() *\/$/;"	m	struct:Pager	file:
vfsList	src/os.c	/^static sqlite3_vfs *vfsList = 0;$/;"	v	file:
vfsUnlink	src/os.c	/^static void vfsUnlink(sqlite3_vfs *pVfs){$/;"	f	file:
vfs_find	src/sqlite3ext.h	/^  sqlite3_vfs *(*vfs_find)(const char*);$/;"	m	struct:sqlite3_api_routines
vfs_register	src/sqlite3ext.h	/^  int (*vfs_register)(sqlite3_vfs*,int);$/;"	m	struct:sqlite3_api_routines
vfs_unlink_test	src/test1.c	/^static int vfs_unlink_test($/;"	f	file:
vfs_unregister	src/sqlite3ext.h	/^  int (*vfs_unregister)(sqlite3_vfs*);$/;"	m	struct:sqlite3_api_routines
vmprintf	src/sqlite3ext.h	/^  char *(*vmprintf)(const char*,va_list);$/;"	m	struct:sqlite3_api_routines
vtabCallConstructor	src/vtab.c	/^static int vtabCallConstructor($/;"	f	file:
vtabarg	parse.y	/^vtabarg ::= .                       {sqlite3VtabArgInit(pParse);}$/;"	l
vtabarg	parse.y	/^vtabarg ::= vtabarg vtabargtoken.$/;"	l
vtabarg	src/parse.y	/^vtabarg ::= .                       {sqlite3VtabArgInit(pParse);}$/;"	l
vtabarg	src/parse.y	/^vtabarg ::= vtabarg vtabargtoken.$/;"	l
vtabarglist	parse.y	/^vtabarglist ::= vtabarg.$/;"	l
vtabarglist	parse.y	/^vtabarglist ::= vtabarglist COMMA vtabarg.$/;"	l
vtabarglist	src/parse.y	/^vtabarglist ::= vtabarg.$/;"	l
vtabarglist	src/parse.y	/^vtabarglist ::= vtabarglist COMMA vtabarg.$/;"	l
vtabargtoken	parse.y	/^vtabargtoken ::= ANY(X).            {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtabargtoken	parse.y	/^vtabargtoken ::= lp anylist RP(X).  {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtabargtoken	src/parse.y	/^vtabargtoken ::= ANY(X).            {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtabargtoken	src/parse.y	/^vtabargtoken ::= lp anylist RP(X).  {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vxprintf	src/printf.c	/^static void vxprintf($/;"	f	file:
walkExprList	src/expr.c	/^static int walkExprList(ExprList *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
walkExprTree	src/expr.c	/^static int walkExprTree(Expr *pExpr, int (*xFunc)(void*,Expr*), void *pArg){$/;"	f	file:
walkSelectExpr	src/expr.c	/^static int walkSelectExpr(Select *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
wantToLock	src/btreeInt.h	/^  int wantToLock;    \/* Number of nested calls to sqlite3BtreeEnter() *\/$/;"	m	struct:Btree
whereClauseClear	src/where.c	/^static void whereClauseClear(WhereClause *pWC){$/;"	f	file:
whereClauseInit	src/where.c	/^static void whereClauseInit($/;"	f	file:
whereClauseInsert	src/where.c	/^static int whereClauseInsert(WhereClause *pWC, Expr *p, int flags){$/;"	f	file:
whereInfoFree	src/where.c	/^static void whereInfoFree(WhereInfo *pWInfo){$/;"	f	file:
whereSplit	src/where.c	/^static void whereSplit(WhereClause *pWC, Expr *pExpr, int op){$/;"	f	file:
whereTempTriggers	src/alter.c	/^static char *whereTempTriggers(Parse *pParse, Table *pTab){$/;"	f	file:
wildcard	tool/lemon.c	/^  struct symbol *wildcard; \/* Token that matches anything *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
winAccess	src/os_win.c	/^static int winAccess($/;"	f	file:
winCheckReservedLock	src/os_win.c	/^static int winCheckReservedLock(sqlite3_file *id){$/;"	f	file:
winClose	src/os_win.c	/^static int winClose(sqlite3_file *id){$/;"	f	file:
winCurrentTime	src/os_win.c	/^int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){$/;"	f
winDelete	src/os_win.c	/^static int winDelete($/;"	f	file:
winDeviceCharacteristics	src/os_win.c	/^static int winDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
winDlClose	src/os_win.c	/^void winDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
winDlClose	src/os_win.c	1445;"	d	file:
winDlError	src/os_win.c	/^static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
winDlError	src/os_win.c	1443;"	d	file:
winDlOpen	src/os_win.c	/^static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
winDlOpen	src/os_win.c	1442;"	d	file:
winDlSym	src/os_win.c	/^void *winDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
winDlSym	src/os_win.c	1444;"	d	file:
winFile	src/os_win.c	/^struct winFile {$/;"	s	file:
winFile	src/os_win.c	/^typedef struct winFile winFile;$/;"	t	typeref:struct:winFile	file:
winFileControl	src/os_win.c	/^static int winFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
winFileSize	src/os_win.c	/^static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){$/;"	f	file:
winFullPathname	src/os_win.c	/^static int winFullPathname($/;"	f	file:
winGetTempname	src/os_win.c	/^static int winGetTempname(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winIoMethod	src/os_win.c	/^static const sqlite3_io_methods winIoMethod = {$/;"	v	file:
winLock	src/os_win.c	/^static int winLock(sqlite3_file *id, int locktype){$/;"	f	file:
winOpen	src/os_win.c	/^static int winOpen($/;"	f	file:
winRandomness	src/os_win.c	/^static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winRead	src/os_win.c	/^static int winRead($/;"	f	file:
winSectorSize	src/os_win.c	/^static int winSectorSize(sqlite3_file *id){$/;"	f	file:
winSleep	src/os_win.c	/^static int winSleep(sqlite3_vfs *pVfs, int microsec){$/;"	f	file:
winSync	src/os_win.c	/^static int winSync(sqlite3_file *id, int flags){$/;"	f	file:
winTruncate	src/os_win.c	/^static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){$/;"	f	file:
winUnlock	src/os_win.c	/^static int winUnlock(sqlite3_file *id, int locktype){$/;"	f	file:
winWrite	src/os_win.c	/^static int winWrite($/;"	f	file:
winceCreateLock	src/os_win.c	/^static BOOL winceCreateLock(const char *zFilename, winFile *pFile){$/;"	f	file:
winceDestroyLock	src/os_win.c	/^static void winceDestroyLock(winFile *pFile){$/;"	f	file:
winceLock	src/os_win.c	/^typedef struct winceLock {$/;"	s	file:
winceLock	src/os_win.c	/^} winceLock;$/;"	t	typeref:struct:winceLock	file:
winceLockFile	src/os_win.c	/^static BOOL winceLockFile($/;"	f	file:
winceLockFileEx	src/os_win.c	/^static BOOL winceLockFileEx($/;"	f	file:
winceMutexAcquire	src/os_win.c	/^static void winceMutexAcquire(HANDLE h){$/;"	f	file:
winceMutexRelease	src/os_win.c	331;"	d	file:
winceUnlockFile	src/os_win.c	/^static BOOL winceUnlockFile($/;"	f	file:
wordBoundary	ext/fts1/fts1.c	/^static int wordBoundary($/;"	f	file:
wordBoundary	ext/fts2/fts2.c	/^static int wordBoundary($/;"	f	file:
wordBoundary	ext/fts3/fts3.c	/^static int wordBoundary($/;"	f	file:
worker	test/threadtest2.c	/^void *worker(void *workerArg){$/;"	f
worker_bee	test/threadtest1.c	/^static void *worker_bee(void *pArg){$/;"	f	file:
working_64bit_int	src/test1.c	/^static int working_64bit_int($/;"	f	file:
wrFlag	src/btreeInt.h	/^  u8 wrFlag;                \/* True if writable *\/$/;"	m	struct:BtCursor
writableSchema	src/shell.c	/^  int writableSchema;    \/* True if PRAGMA writable_schema=ON *\/$/;"	m	struct:callback_data	file:
write32bits	src/pager.c	/^static int write32bits(sqlite3_file *fd, i64 offset, u32 val){$/;"	f	file:
writeJournalHdr	src/pager.c	/^static int writeJournalHdr(Pager *pPager){$/;"	f	file:
writeListAppend	src/test6.c	/^static int writeListAppend($/;"	f	file:
writeListSync	src/test6.c	/^static int writeListSync(CrashFile *pFile, int isCrash){$/;"	f	file:
writeMask	src/sqliteInt.h	/^  u32 writeMask;       \/* Start a write transaction on these databases *\/$/;"	m	struct:Parse
writeMasterJournal	src/pager.c	/^static int writeMasterJournal(Pager *pPager, const char *zMaster){$/;"	f	file:
writeRuleText	tool/lemon.c	/^static void writeRuleText(FILE *out, struct rule *rp){$/;"	f	file:
writeZeroSegment	ext/fts2/fts2.c	/^static int writeZeroSegment(fulltext_vtab *v, fts2Hash *pTerms){$/;"	f	file:
writeZeroSegment	ext/fts3/fts3.c	/^static int writeZeroSegment(fulltext_vtab *v, fts3Hash *pTerms){$/;"	f	file:
write_history	src/shell.c	43;"	d	file:
writerHaltNow	src/test_async.c	/^  volatile int writerHaltNow;       \/* Writer thread halts after next op *\/$/;"	m	struct:TestAsyncStaticData	file:
writerHaltWhenIdle	src/test_async.c	/^  volatile int writerHaltWhenIdle;  \/* Writer thread halts when queue empty *\/$/;"	m	struct:TestAsyncStaticData	file:
writerMutex	src/test_async.c	/^  pthread_mutex_t writerMutex; \/* Prevents multiple writer threads *\/$/;"	m	struct:TestAsyncStaticData	file:
writerMutexHolder	src/test_async.c	/^  pthread_t writerMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
x	tool/lemon.c	/^  } x;$/;"	m	struct:action	typeref:union:action::__anon9	file:
x1a	tool/lemon.c	/^static struct s_x1 *x1a;$/;"	v	typeref:struct:s_x1	file:
x1node	tool/lemon.c	/^} x1node;$/;"	t	typeref:struct:s_x1node	file:
x2a	tool/lemon.c	/^static struct s_x2 *x2a;$/;"	v	typeref:struct:s_x2	file:
x2node	tool/lemon.c	/^} x2node;$/;"	t	typeref:struct:s_x2node	file:
x3a	tool/lemon.c	/^static struct s_x3 *x3a;$/;"	v	typeref:struct:s_x3	file:
x3node	tool/lemon.c	/^} x3node;$/;"	t	typeref:struct:s_x3node	file:
x4a	tool/lemon.c	/^static struct s_x4 *x4a;$/;"	v	typeref:struct:s_x4	file:
x4node	tool/lemon.c	/^} x4node;$/;"	t	typeref:struct:s_x4node	file:
xAccess	sqlite3.h	/^  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags);$/;"	m	struct:sqlite3_vfs
xAuth	src/sqliteInt.h	/^  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);$/;"	m	struct:sqlite3
xBegin	sqlite3.h	/^  int (*xBegin)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xBestIndex	sqlite3.h	/^  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);$/;"	m	struct:sqlite3_module
xBusy	src/test_thread.c	/^static int xBusy(void *pArg, int nBusy){$/;"	f	file:
xCheckReservedLock	sqlite3.h	/^  int (*xCheckReservedLock)(sqlite3_file*);$/;"	m	struct:sqlite3_io_methods
xClose	ext/fts1/fts1_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	ext/fts2/fts2_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	ext/fts3/fts3_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	sqlite3.h	/^  int (*xClose)(sqlite3_file*);$/;"	m	struct:sqlite3_io_methods
xClose	sqlite3.h	/^  int (*xClose)(sqlite3_vtab_cursor*);$/;"	m	struct:sqlite3_module
xCmp	src/sqliteInt.h	/^  int (*xCmp)(void*,int, const void*, int, const void*);$/;"	m	struct:CollSeq
xCodec	src/pager.c	/^  void *(*xCodec)(void*,void*,Pgno,int); \/* Routine for en\/decoding data *\/$/;"	m	struct:Pager	file:
xCollNeeded	src/sqliteInt.h	/^  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);$/;"	m	struct:sqlite3
xCollNeeded16	src/sqliteInt.h	/^  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);$/;"	m	struct:sqlite3
xColumn	sqlite3.h	/^  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);$/;"	m	struct:sqlite3_module
xCommit	sqlite3.h	/^  int (*xCommit)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xCommitCallback	src/sqliteInt.h	/^  int (*xCommitCallback)(void*);    \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xCompare	src/btreeInt.h	/^  int (*xCompare)(void*,int,const void*,int,const void*); \/* Key comp func *\/$/;"	m	struct:BtCursor
xConnect	sqlite3.h	/^  int (*xConnect)(sqlite3*, void *pAux,$/;"	m	struct:sqlite3_module
xCreate	ext/fts1/fts1_tokenizer.h	/^  int (*xCreate)(int argc, const char *const*argv,$/;"	m	struct:sqlite3_tokenizer_module
xCreate	ext/fts2/fts2_tokenizer.h	/^  int (*xCreate)($/;"	m	struct:sqlite3_tokenizer_module
xCreate	ext/fts3/fts3_tokenizer.h	/^  int (*xCreate)($/;"	m	struct:sqlite3_tokenizer_module
xCreate	sqlite3.h	/^  int (*xCreate)(sqlite3*, void *pAux,$/;"	m	struct:sqlite3_module
xCurrentTime	sqlite3.h	/^  int (*xCurrentTime)(sqlite3_vfs*, double*);$/;"	m	struct:sqlite3_vfs
xDel	src/sqliteInt.h	/^  void (*xDel)(void*);  \/* Destructor for pUser *\/$/;"	m	struct:CollSeq
xDel	src/vdbeInt.h	/^  void (*xDel)(void *);  \/* If not null, call this function to delete Mem.z *\/$/;"	m	struct:Mem
xDelete	sqlite3.h	/^  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);$/;"	m	struct:sqlite3_vfs
xDelete	src/vdbeInt.h	/^    void (*xDelete)(void *);      \/* Destructor for the aux data *\/$/;"	m	struct:VdbeFunc::AuxData
xDestroy	ext/fts1/fts1_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	ext/fts2/fts2_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	ext/fts3/fts3_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	sqlite3.h	/^  int (*xDestroy)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xDestroy	src/sqliteInt.h	/^  void (*xDestroy)(void *);            \/* Module destructor function *\/$/;"	m	struct:Module
xDestructor	src/pager.c	/^  void (*xDestructor)(DbPage*,int); \/* Call this routine when freeing pages *\/$/;"	m	struct:Pager	file:
xDeviceCharacteristics	sqlite3.h	/^  int (*xDeviceCharacteristics)(sqlite3_file*);$/;"	m	struct:sqlite3_io_methods
xDisconnect	sqlite3.h	/^  int (*xDisconnect)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xDlClose	sqlite3.h	/^  void (*xDlClose)(sqlite3_vfs*, void*);$/;"	m	struct:sqlite3_vfs
xDlError	sqlite3.h	/^  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);$/;"	m	struct:sqlite3_vfs
xDlOpen	sqlite3.h	/^  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);$/;"	m	struct:sqlite3_vfs
xDlSym	sqlite3.h	/^  void *(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol);$/;"	m	struct:sqlite3_vfs
xEof	sqlite3.h	/^  int (*xEof)(sqlite3_vtab_cursor*);$/;"	m	struct:sqlite3_module
xFileControl	sqlite3.h	/^  int (*xFileControl)(sqlite3_file*, int op, void *pArg);$/;"	m	struct:sqlite3_io_methods
xFileSize	sqlite3.h	/^  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);$/;"	m	struct:sqlite3_io_methods
xFilter	sqlite3.h	/^  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,$/;"	m	struct:sqlite3_module
xFinalize	src/sqliteInt.h	/^  void (*xFinalize)(sqlite3_context*);                \/* Aggregate finializer *\/$/;"	m	struct:FuncDef
xFindFunction	sqlite3.h	/^  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,$/;"	m	struct:sqlite3_module
xFree	ext/fts1/fts1_hash.h	/^  void (*xFree)(void *);  \/* free() function to use *\/$/;"	m	struct:fts1Hash
xFree	ext/fts2/fts2_hash.h	/^  void (*xFree)(void *);  \/* free() function to use *\/$/;"	m	struct:fts2Hash
xFree	ext/icu/icu.c	/^static void xFree(void *p){$/;"	f	file:
xFreeAux	src/sqliteInt.h	/^  void (*xFreeAux)(void*);  \/* Routine to free pAux *\/$/;"	m	struct:Db
xFreeSchema	src/btreeInt.h	/^  void (*xFreeSchema)(void*);  \/* Destructor for BtShared.pSchema *\/$/;"	m	struct:BtShared
xFullPathname	sqlite3.h	/^  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);$/;"	m	struct:sqlite3_vfs
xFunc	src/sqliteInt.h	/^  int (*xFunc)(void *,int);  \/* The busy callback *\/$/;"	m	struct:BusyHandler
xFunc	src/sqliteInt.h	/^  void (*xFunc)(sqlite3_context*,int,sqlite3_value**); \/* Regular function *\/$/;"	m	struct:FuncDef
xGetTempname	sqlite3.h	/^  int (*xGetTempname)(sqlite3_vfs*, int nOut, char *zOut);$/;"	m	struct:sqlite3_vfs
xLock	sqlite3.h	/^  int (*xLock)(sqlite3_file*, int);$/;"	m	struct:sqlite3_io_methods
xMalloc	ext/fts1/fts1_hash.h	/^  void *(*xMalloc)(int);  \/* malloc() function to use *\/$/;"	m	struct:fts1Hash
xMalloc	ext/fts2/fts2_hash.h	/^  void *(*xMalloc)(int);  \/* malloc() function to use *\/$/;"	m	struct:fts2Hash
xNext	ext/fts1/fts1_tokenizer.h	/^  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,$/;"	m	struct:sqlite3_tokenizer_module
xNext	ext/fts2/fts2_tokenizer.h	/^  int (*xNext)($/;"	m	struct:sqlite3_tokenizer_module
xNext	ext/fts3/fts3_tokenizer.h	/^  int (*xNext)($/;"	m	struct:sqlite3_tokenizer_module
xNext	sqlite3.h	/^  int (*xNext)(sqlite3_vtab_cursor*);$/;"	m	struct:sqlite3_module
xOp	src/test4.c	/^  void (*xOp)(Thread*);  \/* next operation to do *\/$/;"	m	struct:Thread	file:
xOp	src/test7.c	/^  void (*xOp)(Thread*);    \/* next operation to do *\/$/;"	m	struct:Thread	file:
xOpen	ext/fts1/fts1_tokenizer.h	/^  int (*xOpen)(sqlite3_tokenizer *pTokenizer,$/;"	m	struct:sqlite3_tokenizer_module
xOpen	ext/fts2/fts2_tokenizer.h	/^  int (*xOpen)($/;"	m	struct:sqlite3_tokenizer_module
xOpen	ext/fts3/fts3_tokenizer.h	/^  int (*xOpen)($/;"	m	struct:sqlite3_tokenizer_module
xOpen	sqlite3.h	/^  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,$/;"	m	struct:sqlite3_vfs
xOpen	sqlite3.h	/^  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);$/;"	m	struct:sqlite3_module
xProfile	src/sqliteInt.h	/^  void (*xProfile)(void*,const char*,u64);  \/* Profiling function *\/$/;"	m	struct:sqlite3
xProgress	src/sqliteInt.h	/^  int (*xProgress)(void *);     \/* The progress callback *\/$/;"	m	struct:sqlite3
xRandomness	sqlite3.h	/^  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);$/;"	m	struct:sqlite3_vfs
xRead	sqlite3.h	/^  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);$/;"	m	struct:sqlite3_io_methods
xReiniter	src/pager.c	/^  void (*xReiniter)(DbPage*,int);   \/* Call this routine when reloading pages *\/$/;"	m	struct:Pager	file:
xRename	sqlite3.h	/^  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);$/;"	m	struct:sqlite3_module
xRollback	sqlite3.h	/^  int (*xRollback)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xRollbackCallback	src/sqliteInt.h	/^  void (*xRollbackCallback)(void*); \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xRowid	sqlite3.h	/^  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);$/;"	m	struct:sqlite3_module
xSectorSize	sqlite3.h	/^  int (*xSectorSize)(sqlite3_file*);$/;"	m	struct:sqlite3_io_methods
xSleep	sqlite3.h	/^  int (*xSleep)(sqlite3_vfs*, int microseconds);$/;"	m	struct:sqlite3_vfs
xStep	src/sqliteInt.h	/^  void (*xStep)(sqlite3_context*,int,sqlite3_value**); \/* Aggregate step *\/$/;"	m	struct:FuncDef
xSync	sqlite3.h	/^  int (*xSync)(sqlite3_file*, int flags);$/;"	m	struct:sqlite3_io_methods
xSync	sqlite3.h	/^  int (*xSync)(sqlite3_vtab *pVTab);$/;"	m	struct:sqlite3_module
xTrace	src/sqliteInt.h	/^  void (*xTrace)(void*,const char*);        \/* Trace function *\/$/;"	m	struct:sqlite3
xTruncate	sqlite3.h	/^  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);$/;"	m	struct:sqlite3_io_methods
xUnlock	sqlite3.h	/^  int (*xUnlock)(sqlite3_file*, int);$/;"	m	struct:sqlite3_io_methods
xUpdate	sqlite3.h	/^  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);$/;"	m	struct:sqlite3_module
xUpdateCallback	src/sqliteInt.h	/^  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);$/;"	m	struct:sqlite3
xWrite	sqlite3.h	/^  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);$/;"	m	struct:sqlite3_io_methods
xferCompatibleCollation	src/insert.c	/^static int xferCompatibleCollation(const char *z1, const char *z2){$/;"	f	file:
xferCompatibleIndex	src/insert.c	/^static int xferCompatibleIndex(Index *pDest, Index *pSrc){$/;"	f	file:
xferOptimization	src/insert.c	/^static int xferOptimization($/;"	f	file:
yy0	parse.c	/^  sqlite3ParserTOKENTYPE yy0;$/;"	m	union:__anon25	file:
yy172	parse.c	/^  Expr* yy172;$/;"	m	union:__anon25	file:
yy174	parse.c	/^  ExprList* yy174;$/;"	m	union:__anon25	file:
yy219	parse.c	/^  Select* yy219;$/;"	m	union:__anon25	file:
yy234	parse.c	/^  struct LimitVal yy234;$/;"	m	union:__anon25	typeref:struct:__anon25::LimitVal	file:
yy243	parse.c	/^  TriggerStep* yy243;$/;"	m	union:__anon25	file:
yy370	parse.c	/^  struct TrigEvent yy370;$/;"	m	union:__anon25	typeref:struct:__anon25::TrigEvent	file:
yy373	parse.c	/^  SrcList* yy373;$/;"	m	union:__anon25	file:
yy405	parse.c	/^  struct {int value; int mask;} yy405;$/;"	m	union:__anon25	typeref:struct:__anon25::__anon26	file:
yy410	parse.c	/^  Token yy410;$/;"	m	union:__anon25	file:
yy432	parse.c	/^  IdList* yy432;$/;"	m	union:__anon25	file:
yy46	parse.c	/^  int yy46;$/;"	m	union:__anon25	file:
yy72	parse.c	/^  struct LikeOp yy72;$/;"	m	union:__anon25	typeref:struct:__anon25::LikeOp	file:
yyFallback	lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyFallback	parse.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyFallback	tool/lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyGrowStack	lempar.c	/^static void yyGrowStack(yyParser *p){$/;"	f	file:
yyGrowStack	parse.c	/^static void yyGrowStack(yyParser *p){$/;"	f	file:
yyGrowStack	tool/lempar.c	/^static void yyGrowStack(yyParser *p){$/;"	f	file:
yyParser	lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	lempar.c	/^typedef struct yyParser yyParser;$/;"	t	typeref:struct:yyParser	file:
yyParser	parse.c	/^struct yyParser {$/;"	s	file:
yyParser	parse.c	/^typedef struct yyParser yyParser;$/;"	t	typeref:struct:yyParser	file:
yyParser	tool/lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	tool/lempar.c	/^typedef struct yyParser yyParser;$/;"	t	typeref:struct:yyParser	file:
yyRuleInfo	lempar.c	/^} yyRuleInfo[] = {$/;"	v	typeref:struct:__anon4	file:
yyRuleInfo	parse.c	/^} yyRuleInfo[] = {$/;"	v	typeref:struct:__anon27	file:
yyRuleInfo	tool/lempar.c	/^} yyRuleInfo[] = {$/;"	v	typeref:struct:__anon11	file:
yyRuleName	lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyRuleName	parse.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyRuleName	tool/lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyStackEntry	lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	typeref:struct:yyStackEntry	file:
yyStackEntry	parse.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	parse.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	typeref:struct:yyStackEntry	file:
yyStackEntry	tool/lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	tool/lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	typeref:struct:yyStackEntry	file:
yyStackOverflow	lempar.c	/^static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){$/;"	f	file:
yyStackOverflow	parse.c	/^static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){$/;"	f	file:
yyStackOverflow	tool/lempar.c	/^static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){$/;"	f	file:
yyTokenName	lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTokenName	parse.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTokenName	tool/lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTraceFILE	lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTraceFILE	parse.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTraceFILE	tool/lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTracePrompt	lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTracePrompt	parse.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTracePrompt	tool/lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yy_accept	lempar.c	/^static void yy_accept($/;"	f	file:
yy_accept	parse.c	/^static void yy_accept($/;"	f	file:
yy_accept	tool/lempar.c	/^static void yy_accept($/;"	f	file:
yy_action	parse.c	/^static const YYACTIONTYPE yy_action[] = {$/;"	v	file:
yy_default	parse.c	/^static const YYACTIONTYPE yy_default[] = {$/;"	v	file:
yy_destructor	lempar.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_destructor	parse.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_destructor	tool/lempar.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_find_reduce_action	lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_reduce_action	parse.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_reduce_action	tool/lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_shift_action	lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_find_shift_action	parse.c	/^static int yy_find_shift_action($/;"	f	file:
yy_find_shift_action	tool/lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_lookahead	parse.c	/^static const YYCODETYPE yy_lookahead[] = {$/;"	v	file:
yy_parse_failed	lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_parse_failed	parse.c	/^static void yy_parse_failed($/;"	f	file:
yy_parse_failed	tool/lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_pop_parser_stack	lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_pop_parser_stack	parse.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_pop_parser_stack	tool/lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_reduce	lempar.c	/^static void yy_reduce($/;"	f	file:
yy_reduce	parse.c	/^static void yy_reduce($/;"	f	file:
yy_reduce	tool/lempar.c	/^static void yy_reduce($/;"	f	file:
yy_reduce_ofst	parse.c	/^static const short yy_reduce_ofst[] = {$/;"	v	file:
yy_shift	lempar.c	/^static void yy_shift($/;"	f	file:
yy_shift	parse.c	/^static void yy_shift($/;"	f	file:
yy_shift	tool/lempar.c	/^static void yy_shift($/;"	f	file:
yy_shift_ofst	parse.c	/^static const short yy_shift_ofst[] = {$/;"	v	file:
yy_syntax_error	lempar.c	/^static void yy_syntax_error($/;"	f	file:
yy_syntax_error	parse.c	/^static void yy_syntax_error($/;"	f	file:
yy_syntax_error	tool/lempar.c	/^static void yy_syntax_error($/;"	f	file:
yyerrcnt	lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyerrcnt	parse.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyerrcnt	tool/lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyidx	lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidx	parse.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidx	tool/lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yystack	lempar.c	/^  yyStackEntry *yystack;        \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystack	parse.c	/^  yyStackEntry *yystack;        \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystack	tool/lempar.c	/^  yyStackEntry *yystack;        \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystksz	lempar.c	/^  int yystksz;                  \/* Current side of the stack *\/$/;"	m	struct:yyParser	file:
yystksz	parse.c	/^  int yystksz;                  \/* Current side of the stack *\/$/;"	m	struct:yyParser	file:
yystksz	tool/lempar.c	/^  int yystksz;                  \/* Current side of the stack *\/$/;"	m	struct:yyParser	file:
z	ext/fts1/fts1.c	/^  const char *z;       \/* Pointer to token text.  Not '\\000' terminated *\/$/;"	m	struct:Token	file:
z	ext/fts2/fts2.c	/^  const char *z;       \/* Pointer to token text.  Not '\\000' terminated *\/$/;"	m	struct:Token	file:
z	ext/fts3/fts3.c	/^  const char *z;       \/* Pointer to token text.  Not '\\000' terminated *\/$/;"	m	struct:FtsToken	file:
z	src/sqliteInt.h	/^  const unsigned char *z; \/* Text of the token.  Not NULL-terminated! *\/$/;"	m	struct:Token
z	src/test1.c	/^  char *z;     \/* The space *\/$/;"	m	struct:dstr	file:
z	src/vdbe.h	/^    char *z;               \/* Pointer to data for string (char array) types *\/$/;"	m	union:VdbeOp::__anon23
z	src/vdbeInt.h	/^  char *z;            \/* String or BLOB value *\/$/;"	m	struct:Mem
zAlias	src/sqliteInt.h	/^    char *zAlias;     \/* The "B" part of a "A AS B" phrase.  zName is the "A" *\/$/;"	m	struct:SrcList::SrcList_item
zAlloc	src/test_onefile.c	/^  char *zAlloc;$/;"	m	struct:tmp_file	file:
zArg	src/test4.c	/^  char *zArg;            \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zArg	src/test7.c	/^  char *zArg;              \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zAuth	src/tclsqlite.c	/^  char *zAuth;               \/* The authorization callback routine *\/$/;"	m	struct:SqliteDb	file:
zAuthContext	src/sqliteInt.h	/^  const char *zAuthContext;   \/* Put saved Parse.zAuthContext here *\/$/;"	m	struct:AuthContext
zAuthContext	src/sqliteInt.h	/^  const char *zAuthContext; \/* The 6th parameter to db->xAuth callbacks *\/$/;"	m	struct:Parse
zBase	src/sqliteInt.h	/^  char *zBase;     \/* A base allocation.  Not from malloc. *\/$/;"	m	struct:StrAccum
zBuf	src/journal.c	/^  char *zBuf;                     \/* Space to buffer journal writes *\/$/;"	m	struct:JournalFile	file:
zBuf	src/test6.c	/^  u8 *zBuf;                    \/* Pointer to copy of written data *\/$/;"	m	struct:WriteBuffer	file:
zBuf	src/test_async.c	/^  char *zBuf;         \/* Data to write to file (or NULL if op!=ASYNC_WRITE) *\/$/;"	m	struct:AsyncWrite	file:
zBuffer	ext/fts2/fts2_icu.c	/^  char *zBuffer;$/;"	m	struct:IcuCursor	file:
zBuffer	ext/fts3/fts3_icu.c	/^  char *zBuffer;$/;"	m	struct:IcuCursor	file:
zBusy	src/tclsqlite.c	/^  char *zBusy;               \/* The busy callback routine *\/$/;"	m	struct:SqliteDb	file:
zCol	src/sqliteInt.h	/^    char *zCol;        \/* Name of column in zTo.  If 0 use PRIMARY KEY *\/$/;"	m	struct:FKey::sColMap
zColAff	src/sqliteInt.h	/^  char *zColAff;     \/* String defining the affinity of each column *\/$/;"	m	struct:Table
zColAff	src/sqliteInt.h	/^  char *zColAff;   \/* String defining the affinity of each column *\/$/;"	m	struct:Index
zColl	src/sqliteInt.h	/^  char *zColl;     \/* Collating sequence.  If NULL, use the default *\/$/;"	m	struct:Column
zComment	src/vdbe.h	/^  char *zComment;     \/* Comment to improve readability *\/$/;"	m	struct:VdbeOp
zCommit	src/tclsqlite.c	/^  char *zCommit;             \/* The commit hook callback routine *\/$/;"	m	struct:SqliteDb	file:
zCrashFile	src/test6.c	/^  char zCrashFile[500];        \/* Crash during an xSync() on this file *\/ $/;"	m	struct:CrashGlobal	file:
zData	src/test6.c	/^  u8 *zData;                           \/* Buffer containing file contents *\/$/;"	m	struct:CrashFile	file:
zDatabase	src/analyze.c	/^  const char *zDatabase;$/;"	m	struct:analysisInfo	file:
zDatabase	src/sqliteInt.h	/^    char *zDatabase;  \/* Name of database holding this table *\/$/;"	m	struct:SrcList::SrcList_item
zDb	ext/fts1/fts1.c	/^  const char *zDb;                 \/* logical database name *\/$/;"	m	struct:fulltext_vtab	file:
zDb	ext/fts1/fts1.c	/^  const char *zDb;         \/* Logical database name *\/$/;"	m	struct:TableSpec	file:
zDb	ext/fts2/fts2.c	/^  const char *zDb;                 \/* logical database name *\/$/;"	m	struct:fulltext_vtab	file:
zDb	ext/fts2/fts2.c	/^  const char *zDb;         \/* Logical database name *\/$/;"	m	struct:TableSpec	file:
zDb	ext/fts3/fts3.c	/^  const char *zDb;                 \/* logical database name *\/$/;"	m	struct:fulltext_vtab	file:
zDb	ext/fts3/fts3.c	/^  const char *zDb;         \/* Logical database name *\/$/;"	m	struct:TableSpec	file:
zDb	src/sqliteInt.h	/^  const char *zDb;    \/* Make sure all objects are contained in this database *\/$/;"	m	struct:DbFixer
zDbFilename	src/shell.c	/^  const char *zDbFilename;    \/* name of the database file *\/$/;"	m	struct:callback_data	file:
zDeleteOnClose	src/os_win.c	/^  WCHAR *zDeleteOnClose;  \/* Name of file to delete when closing *\/$/;"	m	struct:winFile	file:
zDestTable	src/shell.c	/^  char *zDestTable;      \/* Name of destination table when MODE_Insert *\/$/;"	m	struct:callback_data	file:
zDirectory	src/pager.c	/^  char *zDirectory;           \/* Directory hold database and journal files *\/$/;"	m	struct:Pager	file:
zErr	src/test4.c	/^  char *zErr;           \/* operation error *\/$/;"	m	struct:Thread	file:
zErr	src/test7.c	/^  char *zErr;              \/* operation error *\/$/;"	m	struct:Thread	file:
zErrMsg	sqlite3.h	/^  char *zErrMsg;                  \/* Error message from sqlite3_mprintf() *\/$/;"	m	struct:sqlite3_vtab
zErrMsg	src/btreeInt.h	/^  char *zErrMsg;    \/* An error message.  NULL if no errors seen. *\/$/;"	m	struct:IntegrityCk
zErrMsg	src/sqliteInt.h	/^  char *zErrMsg;                \/* Most recent error message (UTF-8 encoded) *\/$/;"	m	struct:sqlite3
zErrMsg	src/sqliteInt.h	/^  char *zErrMsg;       \/* An error message *\/$/;"	m	struct:Parse
zErrMsg	src/table.c	/^  char *zErrMsg;$/;"	m	struct:TabResult	file:
zErrMsg	src/vdbeInt.h	/^  char *zErrMsg;          \/* Error message written here *\/$/;"	m	struct:Vdbe
zErrMsg16	src/sqliteInt.h	/^  char *zErrMsg16;              \/* Most recent error message (UTF-16 encoded) *\/$/;"	m	struct:sqlite3
zFile	test/threadtest1.c	/^  const char *zFile;  \/* Filename - used for error reporting *\/$/;"	m	struct:QueryResult	file:
zFilename	src/pager.c	/^  char *zFilename;            \/* Name of the database file *\/$/;"	m	struct:Pager	file:
zFilename	src/test4.c	/^  char *zFilename;       \/* Name of database file *\/$/;"	m	struct:Thread	file:
zFilename	src/test7.c	/^  char *zFilename;         \/* Name of database file *\/$/;"	m	struct:Thread	file:
zHdr	tool/mkkeywordhash.c	/^static const char zHdr[] = $/;"	v	file:
zHelp	src/shell.c	/^static char zHelp[] =$/;"	v	file:
zIn	src/test_server.c	/^  const char *zIn;             \/* Input filename or SQL statement *\/$/;"	m	struct:SqlMessage	file:
zInput	ext/fts1/fts1_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zInput	ext/fts2/fts2_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zInput	ext/fts3/fts3_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zJournal	src/journal.c	/^  const char *zJournal;           \/* Name of the journal file *\/$/;"	m	struct:JournalFile	file:
zJournal	src/pager.c	/^  char *zJournal;             \/* Name of the journal file *\/$/;"	m	struct:Pager	file:
zLocale	ext/fts2/fts2_icu.c	/^  char *zLocale;$/;"	m	struct:IcuTokenizer	file:
zLocale	ext/fts3/fts3_icu.c	/^  char *zLocale;$/;"	m	struct:IcuTokenizer	file:
zLogName	src/test8.c	/^  char *zLogName;         \/* Name of the log table *\/$/;"	m	struct:echo_vtab	file:
zMagicHeader	src/btree.c	/^static const char zMagicHeader[] = SQLITE_FILE_HEADER;$/;"	v	file:
zMainloop	src/tclsqlite.c	/^static char zMainloop[] = $/;"	v	file:
zMainloop	src/tclsqlite.c	/^static char zMainloop[] =$/;"	v	file:
zName	ext/fts1/fts1.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	ext/fts1/fts1.c	/^  const char *zName;       \/* Name of the full-text index *\/$/;"	m	struct:TableSpec	file:
zName	ext/fts2/fts2.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	ext/fts2/fts2.c	/^  const char *zName;       \/* Name of the full-text index *\/$/;"	m	struct:TableSpec	file:
zName	ext/fts3/fts3.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	ext/fts3/fts3.c	/^  const char *zName;       \/* Name of the full-text index *\/$/;"	m	struct:TableSpec	file:
zName	sqlite3.h	/^  const char *zName;       \/* Name of this virtual file system *\/$/;"	m	struct:sqlite3_vfs
zName	src/build.c	/^  const char *zName;   \/* Name of the table *\/$/;"	m	struct:TableLock	file:
zName	src/sqliteInt.h	/^    char *zName;           \/* Token associated with this expression *\/$/;"	m	struct:ExprList::ExprList_item
zName	src/sqliteInt.h	/^    char *zName;      \/* Name of the identifier *\/$/;"	m	struct:IdList::IdList_item
zName	src/sqliteInt.h	/^    char *zName;      \/* Name of the table *\/$/;"	m	struct:SrcList::SrcList_item
zName	src/sqliteInt.h	/^  char *zName;          \/* Name of the collating sequence, UTF-8 encoded *\/$/;"	m	struct:CollSeq
zName	src/sqliteInt.h	/^  char *zName;         \/* Name of this database *\/$/;"	m	struct:Db
zName	src/sqliteInt.h	/^  char *zName;     \/* Name of the table *\/$/;"	m	struct:Table
zName	src/sqliteInt.h	/^  char *zName;     \/* Name of this column *\/$/;"	m	struct:Column
zName	src/sqliteInt.h	/^  char *zName;     \/* Name of this index *\/$/;"	m	struct:Index
zName	src/sqliteInt.h	/^  char zName[1];       \/* SQL name of the function.  MUST BE LAST *\/$/;"	m	struct:FuncDef
zName	src/sqliteInt.h	/^  const char *zName;                   \/* Name passed to create_module() *\/$/;"	m	struct:Module
zName	src/tclsqlite.c	/^  char *zName;          \/* Name of this function *\/$/;"	m	struct:SqlFunc	file:
zName	src/test6.c	/^  char *zName;$/;"	m	struct:CrashFile	file:
zName	src/test_async.c	/^  char *zName;               \/* Underlying OS filename - used for debugging *\/$/;"	m	struct:AsyncFileData	file:
zName	src/test_onefile.c	/^  const char *zName;$/;"	m	struct:fs_real_file	file:
zName	tool/mkkeywordhash.c	/^  char *zName;         \/* The keyword name *\/$/;"	m	struct:Keyword	file:
zNeededCollation	src/test1.c	/^static char zNeededCollation[200];$/;"	v	file:
zNull	src/tclsqlite.c	/^  char *zNull;               \/* Text to substitute for an SQL NULL value *\/$/;"	m	struct:SqliteDb	file:
zOffset	ext/fts1/fts1.c	/^  char *zOffset;  \/* Text rendering of aMatch[] *\/$/;"	m	struct:Snippet	file:
zOffset	ext/fts2/fts2.c	/^  char *zOffset;  \/* Text rendering of aMatch[] *\/$/;"	m	struct:Snippet	file:
zOffset	ext/fts3/fts3.c	/^  char *zOffset;  \/* Text rendering of aMatch[] *\/$/;"	m	struct:Snippet	file:
zOptions	src/shell.c	/^static const char zOptions[] = $/;"	v	file:
zOut	src/test_server.c	/^  const char *zOut;            \/* Tail of the SQL statement *\/$/;"	m	struct:SqlMessage	file:
zProfile	src/tclsqlite.c	/^  char *zProfile;            \/* The profile callback routine *\/$/;"	m	struct:SqliteDb	file:
zProgress	src/tclsqlite.c	/^  char *zProgress;           \/* The progress callback routine *\/$/;"	m	struct:SqliteDb	file:
zScript	src/tclsqlite.c	/^  char *zScript;        \/* The script to be run *\/$/;"	m	struct:SqlCollate	file:
zScript	src/test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:EvalEvent	file:
zScript	src/test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:SqlThread	file:
zShellStatic	src/shell.c	/^static const char *zShellStatic = 0;$/;"	v	file:
zShort	src/vdbeInt.h	/^  char zShort[NBFS];  \/* Space for short strings *\/$/;"	m	struct:Mem
zSnippet	ext/fts1/fts1.c	/^  char *zSnippet; \/* Snippet text *\/$/;"	m	struct:Snippet	file:
zSnippet	ext/fts2/fts2.c	/^  char *zSnippet; \/* Snippet text *\/$/;"	m	struct:Snippet	file:
zSnippet	ext/fts3/fts3.c	/^  char *zSnippet; \/* Snippet text *\/$/;"	m	struct:Snippet	file:
zSql	src/sqliteInt.h	/^  const char *zSql;    \/* All SQL text *\/$/;"	m	struct:Parse
zSql	src/tclsqlite.c	/^  const char *zSql;        \/* Text of the SQL statement *\/$/;"	m	struct:SqlPreparedStmt	file:
zSql	src/vdbeInt.h	/^  char *zSql;           \/* Text of the SQL statement that generated this *\/$/;"	m	struct:Vdbe
zStaticErr	src/test4.c	/^  char *zStaticErr;     \/* Static error message *\/$/;"	m	struct:Thread	file:
zStaticErr	src/test7.c	/^  char *zStaticErr;        \/* Static error message *\/$/;"	m	struct:Thread	file:
zStmtJrnl	src/pager.c	/^  char *zStmtJrnl;            \/* Name of the statement journal file *\/$/;"	m	struct:Pager	file:
zTableName	src/test8.c	/^  char *zTableName;       \/* Name of the real table *\/$/;"	m	struct:echo_vtab	file:
zTail	src/sqliteInt.h	/^  const char *zTail;   \/* All SQL text past the last semicolon parsed *\/$/;"	m	struct:Parse
zText	src/sqliteInt.h	/^  char *zText;     \/* The string collected so far *\/$/;"	m	struct:StrAccum
zThis	src/test8.c	/^  char *zThis;            \/* Name of the echo table *\/$/;"	m	struct:echo_vtab	file:
zTitle	src/mem2.c	/^  char zTitle[100];  \/* The title text *\/$/;"	m	struct:__anon16	file:
zTo	src/sqliteInt.h	/^  char *zTo;        \/* Name of table that the key points to *\/$/;"	m	struct:FKey
zToken	ext/fts1/fts1_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zToken	ext/fts2/fts2_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zToken	ext/fts3/fts3_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zTokenType	tool/mkkeywordhash.c	/^  char *zTokenType;    \/* Token value for this keyword *\/$/;"	m	struct:Keyword	file:
zTrace	src/tclsqlite.c	/^  char *zTrace;              \/* The trace callback routine *\/$/;"	m	struct:SqliteDb	file:
zType	src/sqliteInt.h	/^  char *zType;     \/* Data type for this column *\/$/;"	m	struct:Column
zType	src/sqliteInt.h	/^  const char *zType;  \/* Type of the container - used for error messages *\/$/;"	m	struct:DbFixer
zVarname	src/test_thread.c	/^  char *zVarname;          \/* Varname in parent script *\/$/;"	m	struct:SqlThread	file:
zeroData	src/btreeInt.h	/^  u8 zeroData;         \/* True if table stores keys only *\/$/;"	m	struct:MemPage
zeroPage	src/btree.c	/^static void zeroPage(MemPage *pPage, int flags){$/;"	f	file:
zeroblobFunc	src/func.c	/^static void zeroblobFunc($/;"	f	file:
zeroed	src/vdbeInt.h	/^  Bool zeroed;          \/* True if zeroed out and ready for reuse *\/$/;"	m	struct:Cursor
