!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ADDR	vdbe.h	130;"	d
ASYNC_CLOSE	test_async.c	294;"	d	file:
ASYNC_DELETE	test_async.c	295;"	d	file:
ASYNC_NOOP	test_async.c	290;"	d	file:
ASYNC_OPENEXCLUSIVE	test_async.c	296;"	d	file:
ASYNC_SYNC	test_async.c	292;"	d	file:
ASYNC_TRACE	test_async.c	141;"	d	file:
ASYNC_TRUNCATE	test_async.c	293;"	d	file:
ASYNC_UNLOCK	test_async.c	297;"	d	file:
ASYNC_WRITE	test_async.c	291;"	d	file:
AggInfo	sqliteInt.h	/^struct AggInfo {$/;"	s
AggInfo	sqliteInt.h	/^typedef struct AggInfo AggInfo;$/;"	t	typeref:struct:AggInfo
AggInfo_col	sqliteInt.h	/^  struct AggInfo_col {    \/* For each column used in source tables *\/$/;"	s	struct:AggInfo
AggInfo_func	sqliteInt.h	/^  struct AggInfo_func {   \/* For each aggregate function *\/$/;"	s	struct:AggInfo
AreFileApisANSI	os_win.c	69;"	d	file:
Argv0	shell.c	/^static char *Argv0;$/;"	v	file:
ArraySize	shell.c	356;"	d	file:
ArraySize	sqliteInt.h	333;"	d
AsyncFile	test_async.c	/^struct AsyncFile {$/;"	s	file:
AsyncFile	test_async.c	/^typedef struct AsyncFile AsyncFile;$/;"	t	typeref:struct:AsyncFile	file:
AsyncFileData	test_async.c	/^struct AsyncFileData {$/;"	s	file:
AsyncFileData	test_async.c	/^typedef struct AsyncFileData AsyncFileData;$/;"	t	typeref:struct:AsyncFileData	file:
AsyncFileLock	test_async.c	/^struct AsyncFileLock {$/;"	s	file:
AsyncFileLock	test_async.c	/^typedef struct AsyncFileLock AsyncFileLock;$/;"	t	typeref:struct:AsyncFileLock	file:
AsyncLock	test_async.c	/^struct AsyncLock {$/;"	s	file:
AsyncLock	test_async.c	/^typedef struct AsyncLock AsyncLock;$/;"	t	typeref:struct:AsyncLock	file:
AsyncWrite	test_async.c	/^struct AsyncWrite {$/;"	s	file:
AsyncWrite	test_async.c	/^typedef struct AsyncWrite AsyncWrite;$/;"	t	typeref:struct:AsyncWrite	file:
AuthContext	sqliteInt.h	/^struct AuthContext {$/;"	s
AuthContext	sqliteInt.h	/^typedef struct AuthContext AuthContext;$/;"	t	typeref:struct:AuthContext
AuxData	vdbeInt.h	/^  struct AuxData {$/;"	s	struct:VdbeFunc
BEGIN_TIMER	shell.c	100;"	d	file:
BEGIN_TIMER	shell.c	104;"	d	file:
BLOBSIZE	test_onefile.c	90;"	d	file:
BLOCKSIZE	test_onefile.c	89;"	d	file:
BMS	where.c	26;"	d	file:
BTREE_AUTOVACUUM_FULL	btree.h	35;"	d
BTREE_AUTOVACUUM_INCR	btree.h	36;"	d
BTREE_AUTOVACUUM_NONE	btree.h	34;"	d
BTREE_CREATE	btree.h	77;"	d
BTREE_INTKEY	btree.h	120;"	d
BTREE_LEAFDATA	btree.h	122;"	d
BTREE_MEMORY	btree.h	74;"	d
BTREE_NO_READLOCK	btree.h	73;"	d
BTREE_OMIT_JOURNAL	btree.h	72;"	d
BTREE_PRIVATE	btree.h	82;"	d
BTREE_READONLY	btree.h	75;"	d
BTREE_READWRITE	btree.h	76;"	d
BTREE_ZERODATA	btree.h	121;"	d
Bitmask	sqliteInt.h	/^typedef u64 Bitmask;$/;"	t
Bool	vdbeInt.h	/^typedef unsigned char Bool;$/;"	t
BtCursor	btree.h	/^typedef struct BtCursor BtCursor;$/;"	t	typeref:struct:BtCursor
BtCursor	btreeInt.h	/^struct BtCursor {$/;"	s
BtLock	btreeInt.h	/^struct BtLock {$/;"	s
BtLock	btreeInt.h	/^typedef struct BtLock BtLock;$/;"	t	typeref:struct:BtLock
BtShared	btree.h	/^typedef struct BtShared BtShared;$/;"	t	typeref:struct:BtShared
BtShared	btreeInt.h	/^struct BtShared {$/;"	s
Btree	btree.h	/^typedef struct Btree Btree;$/;"	t	typeref:struct:Btree
Btree	btreeInt.h	/^struct Btree {$/;"	s
BtreeMutexArray	btree.h	/^struct BtreeMutexArray {$/;"	s
BtreeMutexArray	btree.h	/^typedef struct BtreeMutexArray BtreeMutexArray;$/;"	t	typeref:struct:BtreeMutexArray
BusyHandler	sqliteInt.h	/^struct BusyHandler {$/;"	s
BusyHandler	sqliteInt.h	/^typedef struct BusyHandler BusyHandler;$/;"	t	typeref:struct:BusyHandler
ByteRangeLockPB2	os_unix.c	/^struct ByteRangeLockPB2$/;"	s	file:
CACHE_STALE	vdbeInt.h	107;"	d
CHECK_FOR_INTERRUPT	vdbe.c	461;"	d	file:
CHECK_PAGE	pager.c	875;"	d	file:
CHECK_PAGE	pager.c	885;"	d	file:
CHECK_THREADID	os_unix.c	165;"	d	file:
CHECK_THREADID	os_unix.c	169;"	d	file:
CODEC1	pager.c	304;"	d	file:
CODEC1	pager.c	307;"	d	file:
CODEC2	pager.c	305;"	d	file:
CODEC2	pager.c	308;"	d	file:
COLNAME_COLUMN	vdbe.h	121;"	d
COLNAME_DATABASE	vdbe.h	119;"	d
COLNAME_DECLTYPE	vdbe.h	118;"	d
COLNAME_N	vdbe.h	122;"	d
COLNAME_NAME	vdbe.h	117;"	d
COLNAME_TABLE	vdbe.h	120;"	d
CURSOR_FAULT	btreeInt.h	482;"	d
CURSOR_INVALID	btreeInt.h	479;"	d
CURSOR_REQUIRESEEK	btreeInt.h	481;"	d
CURSOR_VALID	btreeInt.h	480;"	d
CellInfo	btreeInt.h	/^struct CellInfo {$/;"	s
CellInfo	btreeInt.h	/^typedef struct CellInfo CellInfo;$/;"	t	typeref:struct:CellInfo
Cleanup	vdbeaux.c	/^static void Cleanup(Vdbe *p){$/;"	f	file:
CollSeq	sqliteInt.h	/^struct CollSeq {$/;"	s
CollSeq	sqliteInt.h	/^typedef struct CollSeq CollSeq;$/;"	t	typeref:struct:CollSeq
Column	sqliteInt.h	/^struct Column {$/;"	s
Column	sqliteInt.h	/^typedef struct Column Column;$/;"	t	typeref:struct:Column
Context	test_md5.c	/^struct Context {$/;"	s	file:
Context	vdbeInt.h	/^struct Context {$/;"	s
Context	vdbeInt.h	/^typedef struct Context Context;$/;"	t	typeref:struct:Context
CountCtx	func.c	/^struct CountCtx {$/;"	s	file:
CountCtx	func.c	/^typedef struct CountCtx CountCtx;$/;"	t	typeref:struct:CountCtx	file:
CrashFile	test6.c	/^struct CrashFile {$/;"	s	file:
CrashFile	test6.c	/^typedef struct CrashFile CrashFile;$/;"	t	typeref:struct:CrashFile	file:
CrashFileVtab	test6.c	/^static const sqlite3_io_methods CrashFileVtab = {$/;"	v	file:
CrashGlobal	test6.c	/^struct CrashGlobal {$/;"	s	file:
CrashGlobal	test6.c	/^typedef struct CrashGlobal CrashGlobal;$/;"	t	typeref:struct:CrashGlobal	file:
Cursor	vdbeInt.h	/^struct Cursor {$/;"	s
Cursor	vdbeInt.h	/^typedef struct Cursor Cursor;$/;"	t	typeref:struct:Cursor
D	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
DATABASE_FILE	test_onefile.c	125;"	d	file:
DB_Empty	sqliteInt.h	444;"	d
DB_SchemaLoaded	sqliteInt.h	442;"	d
DB_UnresetViews	sqliteInt.h	443;"	d
DEBUGONLY	sqliteInt.h	1664;"	d
DEBUGONLY	sqliteInt.h	1667;"	d
DEVSYM_MAX_PATHNAME	test_devsym.c	25;"	d	file:
DEVSYM_VFS_NAME	test_devsym.c	30;"	d	file:
DO_OS_MALLOC_TEST	os.c	38;"	d	file:
DO_OS_MALLOC_TEST	os.c	44;"	d	file:
DateTime	date.c	/^struct DateTime {$/;"	s	file:
DateTime	date.c	/^typedef struct DateTime DateTime;$/;"	t	typeref:struct:DateTime	file:
Db	sqliteInt.h	/^struct Db {$/;"	s
Db	sqliteInt.h	/^typedef struct Db Db;$/;"	t	typeref:struct:Db
DbBusyHandler	tclsqlite.c	/^static int DbBusyHandler(void *cd, int nTries){$/;"	f	file:
DbClearProperty	sqliteInt.h	430;"	d
DbCommitHandler	tclsqlite.c	/^static int DbCommitHandler(void *cd){$/;"	f	file:
DbDeleteCmd	tclsqlite.c	/^static void DbDeleteCmd(void *db){$/;"	f	file:
DbFixer	sqliteInt.h	/^struct DbFixer {$/;"	s
DbFixer	sqliteInt.h	/^typedef struct DbFixer DbFixer;$/;"	t	typeref:struct:DbFixer
DbHasAnyProperty	sqliteInt.h	428;"	d
DbHasProperty	sqliteInt.h	427;"	d
DbMain	tclsqlite.c	/^static int DbMain(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbObjCmd	tclsqlite.c	/^static int DbObjCmd(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbPage	pager.h	/^typedef struct PgHdr DbPage;$/;"	t	typeref:struct:PgHdr
DbProfileHandler	tclsqlite.c	/^static void DbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm){$/;"	f	file:
DbProgressHandler	tclsqlite.c	/^static int DbProgressHandler(void *cd){$/;"	f	file:
DbRollbackHandler	tclsqlite.c	/^static void DbRollbackHandler(void *clientData){$/;"	f	file:
DbSetProperty	sqliteInt.h	429;"	d
DbTraceHandler	tclsqlite.c	/^static void DbTraceHandler(void *cd, const char *zSql){$/;"	f	file:
DbUpdateHandler	tclsqlite.c	/^static void DbUpdateHandler($/;"	f	file:
Deephemeralize	vdbe.c	154;"	d	file:
DevsymGlobal	test_devsym.c	/^struct DevsymGlobal {$/;"	s	file:
DigestToBase16	test_md5.c	/^static void DigestToBase16(unsigned char *digest, char *zBuf){$/;"	f	file:
ENABLE_FILE_LOCKING	test_async.c	107;"	d	file:
ENC	sqliteInt.h	552;"	d
END_TIMER	shell.c	101;"	d	file:
END_TIMER	shell.c	105;"	d	file:
EP_Agg	sqliteInt.h	1083;"	d
EP_Dequoted	sqliteInt.h	1088;"	d
EP_Distinct	sqliteInt.h	1086;"	d
EP_Error	sqliteInt.h	1085;"	d
EP_ExpCollate	sqliteInt.h	1090;"	d
EP_FromJoin	sqliteInt.h	1082;"	d
EP_InfixFunc	sqliteInt.h	1089;"	d
EP_Resolved	sqliteInt.h	1084;"	d
EP_VarSelect	sqliteInt.h	1087;"	d
EXCLUSIVE_LOCK	os.h	152;"	d
EXTRA_SIZE	btreeInt.h	304;"	d
EchoModule	test8.c	/^struct EchoModule {$/;"	s	file:
EchoModule	test8.c	/^typedef struct EchoModule EchoModule;$/;"	t	typeref:struct:EchoModule	file:
EvalEvent	test_thread.c	/^struct EvalEvent {$/;"	s	file:
EvalEvent	test_thread.c	/^typedef struct EvalEvent EvalEvent;$/;"	t	typeref:struct:EvalEvent	file:
ExpandBlob	vdbe.c	162;"	d	file:
Expr	sqliteInt.h	/^struct Expr {$/;"	s
Expr	sqliteInt.h	/^typedef struct Expr Expr;$/;"	t	typeref:struct:Expr
ExprClearProperty	sqliteInt.h	1099;"	d
ExprHasAnyProperty	sqliteInt.h	1097;"	d
ExprHasProperty	sqliteInt.h	1096;"	d
ExprList	sqliteInt.h	/^struct ExprList {$/;"	s
ExprList	sqliteInt.h	/^typedef struct ExprList ExprList;$/;"	t	typeref:struct:ExprList
ExprList_item	sqliteInt.h	/^  struct ExprList_item {$/;"	s	struct:ExprList
ExprMaskSet	where.c	/^struct ExprMaskSet {$/;"	s	file:
ExprMaskSet	where.c	/^typedef struct ExprMaskSet ExprMaskSet;$/;"	t	typeref:struct:ExprMaskSet	file:
ExprSetProperty	sqliteInt.h	1098;"	d
F1	test_md5.c	70;"	d	file:
F2	test_md5.c	71;"	d	file:
F3	test_md5.c	72;"	d	file:
F4	test_md5.c	73;"	d	file:
FILEHANDLEID	pager.c	55;"	d	file:
FKey	sqliteInt.h	/^struct FKey {$/;"	s
FKey	sqliteInt.h	/^typedef struct FKey FKey;$/;"	t	typeref:struct:FKey
FLAG_INTERN	printf.c	102;"	d	file:
FLAG_SIGNED	printf.c	101;"	d	file:
FLAG_STRING	printf.c	103;"	d	file:
FORCE_ALIGNMENT	pager.c	132;"	d	file:
FOREGUARD	mem2.c	84;"	d	file:
FS_VFS_NAME	test_onefile.c	95;"	d	file:
FaultInjector	fault.c	/^static struct FaultInjector {$/;"	s	file:
Fifo	vdbeInt.h	/^struct Fifo {$/;"	s
Fifo	vdbeInt.h	/^typedef struct Fifo Fifo;$/;"	t	typeref:struct:Fifo
FifoPage	vdbeInt.h	/^struct FifoPage {$/;"	s
FifoPage	vdbeInt.h	/^typedef struct FifoPage FifoPage;$/;"	t	typeref:struct:FifoPage
FuncDef	sqliteInt.h	/^struct FuncDef {$/;"	s
FuncDef	sqliteInt.h	/^typedef struct FuncDef FuncDef;$/;"	t	typeref:struct:FuncDef
GetTempPathA	os_win.c	311;"	d	file:
GetVarint	vdbe.c	141;"	d	file:
GetVarint	vdbeaux.c	2105;"	d	file:
GlogUpperToLower	func.c	416;"	d	file:
GlogUpperToLower	func.c	418;"	d	file:
HANDLE_TO_WINFILE	os_win.c	317;"	d	file:
HAS_TIMER	shell.c	102;"	d	file:
HAS_TIMER	shell.c	106;"	d	file:
HAVE_FULLFSYNC	os_unix.c	907;"	d	file:
HAVE_FULLFSYNC	os_unix.c	909;"	d	file:
Hash	hash.h	/^struct Hash {$/;"	s
Hash	hash.h	/^typedef struct Hash Hash;$/;"	t	typeref:struct:Hash
HashElem	hash.h	/^struct HashElem {$/;"	s
HashElem	hash.h	/^typedef struct HashElem HashElem;$/;"	t	typeref:struct:HashElem
INCL_DOSDATETIME	os.h	79;"	d
INCL_DOSERRORS	os.h	81;"	d
INCL_DOSFILEMGR	os.h	80;"	d
INCL_DOSMISC	os.h	82;"	d
INCL_DOSMODULEMGR	os.h	84;"	d
INCL_DOSPROCESS	os.h	83;"	d
INCL_DOSSEMAPHORES	os.h	85;"	d
INT16_TYPE	sqliteInt.h	257;"	d
INT8_TYPE	sqliteInt.h	263;"	d
INVALID_SET_FILE_POINTER	os_win.c	623;"	d	file:
IN_DECLARE_VTAB	sqliteInt.h	1452;"	d
IN_DECLARE_VTAB	sqliteInt.h	1454;"	d
IN_INDEX_EPH	sqliteInt.h	2044;"	d
IN_INDEX_INDEX	sqliteInt.h	2045;"	d
IN_INDEX_ROWID	sqliteInt.h	2043;"	d
IOTRACE	sqliteInt.h	2080;"	d
IOTRACE	sqliteInt.h	2083;"	d
ISAUTOVACUUM	btreeInt.h	607;"	d
ISAUTOVACUUM	btreeInt.h	609;"	d
IdChar	complete.c	30;"	d	file:
IdChar	complete.c	34;"	d	file:
IdChar	tokenize.c	115;"	d	file:
IdChar	tokenize.c	97;"	d	file:
IdList	sqliteInt.h	/^struct IdList {$/;"	s
IdList	sqliteInt.h	/^typedef struct IdList IdList;$/;"	t	typeref:struct:IdList
IdList_item	sqliteInt.h	/^  struct IdList_item {$/;"	s	struct:IdList
IgnorableOrderby	sqliteInt.h	1356;"	d
InLoop	sqliteInt.h	/^  struct InLoop {$/;"	s	struct:WhereLevel
Incrblob	vdbeblob.c	/^struct Incrblob {$/;"	s	file:
Incrblob	vdbeblob.c	/^typedef struct Incrblob Incrblob;$/;"	t	typeref:struct:Incrblob	file:
IncrblobChannel	tclsqlite.c	/^struct IncrblobChannel {$/;"	s	file:
IncrblobChannel	tclsqlite.c	/^typedef struct IncrblobChannel IncrblobChannel;$/;"	t	typeref:struct:IncrblobChannel	file:
IncrblobChannelType	tclsqlite.c	/^static Tcl_ChannelType IncrblobChannelType = {$/;"	v	file:
Index	sqliteInt.h	/^struct Index {$/;"	s
Index	sqliteInt.h	/^typedef struct Index Index;$/;"	t	typeref:struct:Index
InitData	sqliteInt.h	/^} InitData;$/;"	t	typeref:struct:__anon3
IntegrityCk	btreeInt.h	/^struct IntegrityCk {$/;"	s
IntegrityCk	btreeInt.h	/^typedef struct IntegrityCk IntegrityCk;$/;"	t	typeref:struct:IntegrityCk
IsHiddenColumn	sqliteInt.h	803;"	d
IsHiddenColumn	sqliteInt.h	806;"	d
IsVirtual	sqliteInt.h	802;"	d
IsVirtual	sqliteInt.h	805;"	d
JOURNAL_FILE	test_onefile.c	126;"	d	file:
JOURNAL_HDR_SZ	pager.c	474;"	d	file:
JOURNAL_PG_SZ	pager.c	467;"	d	file:
JT_CROSS	sqliteInt.h	1193;"	d
JT_ERROR	sqliteInt.h	1198;"	d
JT_INNER	sqliteInt.h	1192;"	d
JT_LEFT	sqliteInt.h	1195;"	d
JT_NATURAL	sqliteInt.h	1194;"	d
JT_OUTER	sqliteInt.h	1197;"	d
JT_RIGHT	sqliteInt.h	1196;"	d
JournalFile	journal.c	/^struct JournalFile {$/;"	s	file:
JournalFile	journal.c	/^typedef struct JournalFile JournalFile;$/;"	t	typeref:struct:JournalFile	file:
JournalFileMethods	journal.c	/^static struct sqlite3_io_methods JournalFileMethods = {$/;"	v	typeref:struct:sqlite3_io_methods	file:
KeyClass	sqliteInt.h	/^typedef struct KeyClass KeyClass;$/;"	t	typeref:struct:KeyClass
KeyInfo	sqliteInt.h	/^struct KeyInfo {$/;"	s
KeyInfo	sqliteInt.h	/^typedef struct KeyInfo KeyInfo;$/;"	t	typeref:struct:KeyInfo
LINKVAR	test_config.c	422;"	d	file:
LOCKFILE_FAIL_IMMEDIATELY	os_win.c	756;"	d	file:
LONGDOUBLE_TYPE	sqliteInt.h	169;"	d
LONGDOUBLE_TYPE	sqliteInt.h	266;"	d
LockFile	os_win.c	313;"	d	file:
LockFileEx	os_win.c	315;"	d	file:
M	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
MASTER_NAME	sqliteInt.h	316;"	d
MASTER_ROOT	sqliteInt.h	322;"	d
MAX	test_async.c	130;"	d	file:
MAX	test_onefile.c	244;"	d	file:
MAX_6BYTE	vdbeaux.c	1839;"	d	file:
MAX_PATHNAME	os_unix.c	76;"	d	file:
MAX_PREPARED_STMTS	tclsqlite.c	42;"	d	file:
MAX_ROWID	vdbe.c	3095;"	d	file:
MD5Context	test_md5.c	/^typedef struct Context MD5Context;$/;"	t	typeref:struct:Context	file:
MD5Final	test_md5.c	/^static void MD5Final(unsigned char digest[16], MD5Context *pCtx){$/;"	f	file:
MD5Init	test_md5.c	/^static void MD5Init(MD5Context *ctx){$/;"	f	file:
MD5STEP	test_md5.c	76;"	d	file:
MD5Transform	test_md5.c	/^static void MD5Transform(uint32 buf[4], const uint32 in[16]){$/;"	f	file:
MD5Update	test_md5.c	/^void MD5Update(MD5Context *pCtx, const unsigned char *buf, unsigned int len){$/;"	f	file:
MEMDB	pager.c	483;"	d	file:
MEMDB	pager.c	485;"	d	file:
MEM_Agg	vdbeInt.h	167;"	d
MEM_Blob	vdbeInt.h	155;"	d
MEM_Dyn	vdbeInt.h	163;"	d
MEM_Ephem	vdbeInt.h	165;"	d
MEM_Int	vdbeInt.h	153;"	d
MEM_Null	vdbeInt.h	151;"	d
MEM_Real	vdbeInt.h	154;"	d
MEM_Short	vdbeInt.h	166;"	d
MEM_Static	vdbeInt.h	164;"	d
MEM_Str	vdbeInt.h	152;"	d
MEM_Term	vdbeInt.h	162;"	d
MEM_Zero	vdbeInt.h	168;"	d
MEM_Zero	vdbeInt.h	171;"	d
MEM_Zero	vdbeInt.h	172;"	d
MIN	test_async.c	129;"	d	file:
MIN	test_onefile.c	243;"	d	file:
MODE_Column	shell.c	332;"	d	file:
MODE_Csv	shell.c	338;"	d	file:
MODE_Explain	shell.c	340;"	d	file:
MODE_Html	shell.c	335;"	d	file:
MODE_Insert	shell.c	336;"	d	file:
MODE_Line	shell.c	331;"	d	file:
MODE_List	shell.c	333;"	d	file:
MODE_NUM_OF	shell.c	339;"	d	file:
MODE_Semi	shell.c	334;"	d	file:
MODE_Tcl	shell.c	337;"	d	file:
MSG_Close	test_server.c	244;"	d	file:
MSG_Done	test_server.c	245;"	d	file:
MSG_Finalize	test_server.c	243;"	d	file:
MSG_Open	test_server.c	239;"	d	file:
MSG_Prepare	test_server.c	240;"	d	file:
MSG_Reset	test_server.c	242;"	d	file:
MSG_Step	test_server.c	241;"	d	file:
MX_CELL	btreeInt.h	227;"	d
MX_CELL_SIZE	btreeInt.h	221;"	d
MX_CLOSE_ATTEMPT	os_win.c	600;"	d	file:
MX_DELETION_ATTEMPTS	os_win.c	1196;"	d	file:
MX_SMALL	mem3.c	40;"	d	file:
Md5_Init	test_md5.c	/^int Md5_Init(Tcl_Interp *interp){$/;"	f
Md5_Register	test_md5.c	/^int Md5_Register(sqlite3 *db){$/;"	f
Mem	vdbe.h	/^typedef struct Mem Mem;$/;"	t	typeref:struct:Mem
Mem	vdbeInt.h	/^struct Mem {$/;"	s
Mem3Block	mem3.c	/^struct Mem3Block {$/;"	s	file:
Mem3Block	mem3.c	/^typedef struct Mem3Block Mem3Block;$/;"	t	typeref:struct:Mem3Block	file:
MemBlockHdr	mem2.c	/^struct MemBlockHdr {$/;"	s	file:
MemPage	btreeInt.h	/^struct MemPage {$/;"	s
MemPage	btreeInt.h	/^typedef struct MemPage MemPage;$/;"	t	typeref:struct:MemPage
Module	sqliteInt.h	/^struct Module {$/;"	s
Module	sqliteInt.h	/^typedef struct Module Module;$/;"	t	typeref:struct:Module
NB	btree.c	4646;"	d	file:
NBFS	vdbeInt.h	102;"	d
NCSIZE	mem2.c	90;"	d	file:
NDEBUG	sqliteInt.h	149;"	d
NDELAY	main.c	322;"	d	file:
NN	btree.c	4645;"	d	file:
NO_LOCK	os.h	148;"	d
NULL_DISTINCT_FOR_UNIQUE	sqliteInt.h	204;"	d
NUM_PREPARED_STMTS	tclsqlite.c	41;"	d	file:
N_HASH	mem3.c	46;"	d	file:
N_SORT_BUCKET	pager.c	2895;"	d	file:
N_SORT_BUCKET	pager.c	2898;"	d	file:
N_SORT_BUCKET	pager.c	2899;"	d	file:
N_SORT_BUCKET_ALLOC	pager.c	2894;"	d	file:
N_THREAD	test4.c	56;"	d	file:
N_THREAD	test7.c	79;"	d	file:
NameContext	sqliteInt.h	/^struct NameContext {$/;"	s
NameContext	sqliteInt.h	/^typedef struct NameContext NameContext;$/;"	t	typeref:struct:NameContext
OE_Abort	sqliteInt.h	877;"	d
OE_Cascade	sqliteInt.h	885;"	d
OE_Default	sqliteInt.h	887;"	d
OE_Fail	sqliteInt.h	878;"	d
OE_Ignore	sqliteInt.h	879;"	d
OE_None	sqliteInt.h	875;"	d
OE_Replace	sqliteInt.h	880;"	d
OE_Restrict	sqliteInt.h	882;"	d
OE_Rollback	sqliteInt.h	876;"	d
OE_SetDflt	sqliteInt.h	884;"	d
OE_SetNull	sqliteInt.h	883;"	d
OMIT_TEMPDB	sqliteInt.h	187;"	d
OMIT_TEMPDB	sqliteInt.h	189;"	d
OPFLAG_APPEND	sqliteInt.h	1472;"	d
OPFLAG_ISUPDATE	sqliteInt.h	1471;"	d
OPFLAG_LASTROWID	sqliteInt.h	1470;"	d
OPFLAG_NCHANGE	sqliteInt.h	1469;"	d
ORDERBY_MAX	sqliteInt.h	1249;"	d
ORDERBY_MIN	sqliteInt.h	1248;"	d
ORDERBY_NORMAL	sqliteInt.h	1247;"	d
OSTRACE1	os_common.h	41;"	d
OSTRACE1	os_common.h	51;"	d
OSTRACE2	os_common.h	42;"	d
OSTRACE2	os_common.h	52;"	d
OSTRACE3	os_common.h	43;"	d
OSTRACE3	os_common.h	53;"	d
OSTRACE4	os_common.h	44;"	d
OSTRACE4	os_common.h	54;"	d
OSTRACE5	os_common.h	45;"	d
OSTRACE5	os_common.h	55;"	d
OSTRACE6	os_common.h	46;"	d
OSTRACE6	os_common.h	56;"	d
OSTRACE7	os_common.h	48;"	d
OSTRACE7	os_common.h	57;"	d
OS_OS2	os.h	35;"	d
OS_OS2	os.h	36;"	d
OS_OS2	os.h	47;"	d
OS_OS2	os.h	51;"	d
OS_OS2	os.h	55;"	d
OS_OS2	os.h	59;"	d
OS_OTHER	os.h	38;"	d
OS_OTHER	os.h	42;"	d
OS_UNIX	os.h	31;"	d
OS_UNIX	os.h	32;"	d
OS_UNIX	os.h	46;"	d
OS_UNIX	os.h	50;"	d
OS_UNIX	os.h	54;"	d
OS_UNIX	os.h	58;"	d
OS_WIN	os.h	33;"	d
OS_WIN	os.h	34;"	d
OS_WIN	os.h	45;"	d
OS_WIN	os.h	49;"	d
OS_WIN	os.h	53;"	d
OS_WIN	os.h	63;"	d
OS_WINCE	os_win.c	68;"	d	file:
OS_WINCE	os_win.c	71;"	d	file:
O_BINARY	os_unix.c	124;"	d	file:
O_LARGEFILE	os_unix.c	114;"	d	file:
O_LARGEFILE	os_unix.c	117;"	d	file:
O_LARGEFILE	os_unix.c	118;"	d	file:
O_NOFOLLOW	os_unix.c	121;"	d	file:
Op	vdbeInt.h	/^typedef struct VdbeOp Op;$/;"	t	typeref:struct:VdbeOp
OpenCounter	os_common.h	124;"	d
OpenCounter	os_common.h	126;"	d
P4_COLLSEQ	vdbe.h	92;"	d
P4_DYNAMIC	vdbe.h	90;"	d
P4_FUNCDEF	vdbe.h	93;"	d
P4_INT32	vdbe.h	102;"	d
P4_INT64	vdbe.h	101;"	d
P4_KEYINFO	vdbe.h	94;"	d
P4_KEYINFO_HANDOFF	vdbe.h	111;"	d
P4_MEM	vdbe.h	96;"	d
P4_MPRINTF	vdbe.h	99;"	d
P4_NOTUSED	vdbe.h	89;"	d
P4_REAL	vdbe.h	100;"	d
P4_STATIC	vdbe.h	91;"	d
P4_TRANSIENT	vdbe.h	97;"	d
P4_VDBEFUNC	vdbe.h	95;"	d
P4_VTAB	vdbe.h	98;"	d
PACKAGE_VERSION	tclsqlite.c	2436;"	d	file:
PAGERID	pager.c	54;"	d	file:
PAGERTRACE1	pager.c	39;"	d	file:
PAGERTRACE2	pager.c	40;"	d	file:
PAGERTRACE3	pager.c	41;"	d	file:
PAGERTRACE4	pager.c	42;"	d	file:
PAGERTRACE5	pager.c	43;"	d	file:
PAGER_EXCLUSIVE	pager.c	108;"	d	file:
PAGER_INCR	pager.c	419;"	d	file:
PAGER_INCR	pager.c	421;"	d	file:
PAGER_LOCKINGMODE_EXCLUSIVE	pager.h	51;"	d
PAGER_LOCKINGMODE_NORMAL	pager.h	50;"	d
PAGER_LOCKINGMODE_QUERY	pager.h	49;"	d
PAGER_MAX_PGNO	pager.c	501;"	d	file:
PAGER_MJ_PGNO	pager.c	496;"	d	file:
PAGER_NO_READLOCK	pager.h	44;"	d
PAGER_OMIT_JOURNAL	pager.h	43;"	d
PAGER_RESERVED	pager.c	107;"	d	file:
PAGER_SHARED	pager.c	106;"	d	file:
PAGER_SYNCED	pager.c	109;"	d	file:
PAGER_UNLOCK	pager.c	105;"	d	file:
PENDING_BYTE	os.h	212;"	d
PENDING_BYTE	os.h	215;"	d
PENDING_BYTE_PAGE	btreeInt.h	512;"	d
PENDING_BYTE_PAGE	btreeInt.h	514;"	d
PENDING_LOCK	os.h	151;"	d
PGHDR_TO_DATA	pager.c	315;"	d	file:
PGHDR_TO_EXTRA	pager.c	316;"	d	file:
PGHDR_TO_HIST	pager.c	317;"	d	file:
PTF_INTKEY	btreeInt.h	253;"	d
PTF_LEAF	btreeInt.h	256;"	d
PTF_LEAFDATA	btreeInt.h	255;"	d
PTF_ZERODATA	btreeInt.h	254;"	d
PTRMAP_BTREE	btreeInt.h	589;"	d
PTRMAP_FREEPAGE	btreeInt.h	586;"	d
PTRMAP_ISPAGE	btreeInt.h	552;"	d
PTRMAP_OVERFLOW1	btreeInt.h	587;"	d
PTRMAP_OVERFLOW2	btreeInt.h	588;"	d
PTRMAP_PAGENO	btreeInt.h	550;"	d
PTRMAP_PTROFFSET	btreeInt.h	551;"	d
PTRMAP_ROOTPAGE	btreeInt.h	585;"	d
Pager	pager.c	/^struct Pager {$/;"	s	file:
Pager	pager.h	/^typedef struct Pager Pager;$/;"	t	typeref:struct:Pager
PagerLruLink	pager.c	/^struct PagerLruLink {$/;"	s	file:
PagerLruLink	pager.c	/^typedef struct PagerLruLink PagerLruLink;$/;"	t	typeref:struct:PagerLruLink	file:
PagerLruList	pager.c	/^struct PagerLruList {$/;"	s	file:
PagerLruList	pager.c	/^typedef struct PagerLruList PagerLruList;$/;"	t	typeref:struct:PagerLruList	file:
Parse	sqliteInt.h	/^struct Parse {$/;"	s
Parse	sqliteInt.h	/^typedef struct Parse Parse;$/;"	t	typeref:struct:Parse
PgHdr	pager.c	/^struct PgHdr {$/;"	s	file:
PgHdr	pager.c	/^typedef struct PgHdr PgHdr;$/;"	t	typeref:struct:PgHdr	file:
PgHistory	pager.c	/^struct PgHistory {$/;"	s	file:
PgHistory	pager.c	/^typedef struct PgHistory PgHistory;$/;"	t	typeref:struct:PgHistory	file:
Pgno	pager.h	/^typedef unsigned int Pgno;$/;"	t
QueryCoder	expr.c	/^struct QueryCoder {$/;"	s	file:
QueryCoder	expr.c	/^typedef struct QueryCoder QueryCoder;$/;"	t	typeref:struct:QueryCoder	file:
READ_LOCK	btreeInt.h	532;"	d
READ_UTF16BE	utf.c	119;"	d	file:
READ_UTF16LE	utf.c	108;"	d	file:
REARGUARD	mem2.c	85;"	d	file:
REFINFO	pager.c	549;"	d	file:
REFINFO	pager.c	551;"	d	file:
REGISTER_TRACE	vdbe.c	429;"	d	file:
REGISTER_TRACE	vdbe.c	431;"	d	file:
RESERVED_BYTE	os.h	218;"	d
RESERVED_LOCK	os.h	150;"	d
ROUND8	btreeInt.h	215;"	d
Release	vdbe.c	116;"	d	file:
SAVE_SZ	build.c	238;"	d	file:
SCHEMA	test_schema.c	23;"	d	file:
SCHEMA_TABLE	sqliteInt.h	327;"	d
SET_FULLSYNC	os.h	96;"	d
SET_THREADID	os_unix.c	164;"	d	file:
SET_THREADID	os_unix.c	168;"	d	file:
SHARED_FIRST	os.h	219;"	d
SHARED_LOCK	os.h	149;"	d
SHARED_SIZE	os.h	220;"	d
SQLITE_AFF_INTEGER	sqliteInt.h	713;"	d
SQLITE_AFF_MASK	sqliteInt.h	722;"	d
SQLITE_AFF_NONE	sqliteInt.h	711;"	d
SQLITE_AFF_NUMERIC	sqliteInt.h	712;"	d
SQLITE_AFF_REAL	sqliteInt.h	714;"	d
SQLITE_AFF_TEXT	sqliteInt.h	710;"	d
SQLITE_ASCII	sqliteInt.h	240;"	d
SQLITE_ASYNC_TWO_FILEHANDLES	test_async.c	258;"	d	file:
SQLITE_BIGENDIAN	sqliteInt.h	286;"	d
SQLITE_BIGENDIAN	sqliteInt.h	290;"	d
SQLITE_BIG_DBL	sqliteInt.h	171;"	d
SQLITE_BIG_DBL	sqliteInt.h	178;"	d
SQLITE_BUSY_RESERVED_LOCK	pager.c	125;"	d	file:
SQLITE_COLL_BINARY	sqliteInt.h	685;"	d
SQLITE_COLL_NOCASE	sqliteInt.h	686;"	d
SQLITE_COLL_REVERSE	sqliteInt.h	687;"	d
SQLITE_COLL_USER	sqliteInt.h	688;"	d
SQLITE_CORE	loadext.c	18;"	d	file:
SQLITE_CORRUPT_BKPT	sqliteInt.h	1663;"	d
SQLITE_CORRUPT_BKPT	sqliteInt.h	1666;"	d
SQLITE_CountRows	sqliteInt.h	566;"	d
SQLITE_DEFAULT_AUTOVACUUM	btree.h	31;"	d
SQLITE_DEFAULT_CACHE_SIZE	sqliteLimit.h	101;"	d
SQLITE_DEFAULT_FILE_FORMAT	sqliteInt.h	214;"	d
SQLITE_DEFAULT_FILE_PERMISSIONS	os_unix.c	70;"	d	file:
SQLITE_DEFAULT_PAGE_SIZE	sqliteLimit.h	139;"	d
SQLITE_DEFAULT_PAGE_SIZE	sqliteLimit.h	142;"	d
SQLITE_DEFAULT_PAGE_SIZE	sqliteLimit.h	143;"	d
SQLITE_DEFAULT_SECTOR_SIZE	os.h	103;"	d
SQLITE_DEFAULT_TEMP_CACHE_SIZE	sqliteLimit.h	104;"	d
SQLITE_EBCDIC	sqliteInt.h	238;"	d
SQLITE_EXTENSION_INIT1	sqlite3ext.h	347;"	d
SQLITE_EXTENSION_INIT2	sqlite3ext.h	348;"	d
SQLITE_FAULTINJECTOR_COUNT	sqliteInt.h	2018;"	d
SQLITE_FAULTINJECTOR_MALLOC	sqliteInt.h	2017;"	d
SQLITE_FILE_HEADER	btreeInt.h	246;"	d
SQLITE_FUNC_CASE	sqliteInt.h	632;"	d
SQLITE_FUNC_EPHEM	sqliteInt.h	633;"	d
SQLITE_FUNC_LIKE	sqliteInt.h	631;"	d
SQLITE_FullColNames	sqliteInt.h	564;"	d
SQLITE_FullFSync	sqliteInt.h	579;"	d
SQLITE_HASH_BINARY	hash.h	76;"	d
SQLITE_HASH_STRING	hash.h	75;"	d
SQLITE_INTEGRITY_CHECK_ERROR_MAX	pragma.c	823;"	d	file:
SQLITE_IgnoreChecks	sqliteInt.h	576;"	d
SQLITE_InTrans	sqliteInt.h	562;"	d
SQLITE_InternChanges	sqliteInt.h	563;"	d
SQLITE_JUMPIFNULL	sqliteInt.h	728;"	d
SQLITE_LITTLEENDIAN	sqliteInt.h	287;"	d
SQLITE_LITTLEENDIAN	sqliteInt.h	291;"	d
SQLITE_LegacyFileFmt	sqliteInt.h	578;"	d
SQLITE_LoadExtension	sqliteInt.h	580;"	d
SQLITE_MAGIC_BUSY	sqliteInt.h	594;"	d
SQLITE_MAGIC_CLOSED	sqliteInt.h	592;"	d
SQLITE_MAGIC_ERROR	sqliteInt.h	595;"	d
SQLITE_MAGIC_OPEN	sqliteInt.h	591;"	d
SQLITE_MAGIC_SICK	sqliteInt.h	593;"	d
SQLITE_MAX_ATTACHED	sqliteLimit.h	115;"	d
SQLITE_MAX_COLUMN	sqliteInt.h	70;"	d
SQLITE_MAX_COLUMN	sqliteInt.h	82;"	d
SQLITE_MAX_COLUMN	sqliteLimit.h	47;"	d
SQLITE_MAX_COMPOUND_SELECT	sqliteInt.h	73;"	d
SQLITE_MAX_COMPOUND_SELECT	sqliteInt.h	85;"	d
SQLITE_MAX_COMPOUND_SELECT	sqliteLimit.h	78;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	sqliteLimit.h	154;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	sqliteLimit.h	157;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	sqliteLimit.h	158;"	d
SQLITE_MAX_EXPR_DEPTH	sqliteInt.h	72;"	d
SQLITE_MAX_EXPR_DEPTH	sqliteInt.h	84;"	d
SQLITE_MAX_EXPR_DEPTH	sqliteLimit.h	66;"	d
SQLITE_MAX_FILE_FORMAT	sqliteInt.h	212;"	d
SQLITE_MAX_FUNCTION_ARG	sqliteInt.h	75;"	d
SQLITE_MAX_FUNCTION_ARG	sqliteInt.h	87;"	d
SQLITE_MAX_FUNCTION_ARG	sqliteLimit.h	93;"	d
SQLITE_MAX_LENGTH	sqliteInt.h	69;"	d
SQLITE_MAX_LENGTH	sqliteInt.h	81;"	d
SQLITE_MAX_LENGTH	sqliteLimit.h	26;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	sqliteInt.h	79;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	sqliteInt.h	91;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	sqliteLimit.h	178;"	d
SQLITE_MAX_PAGE_COUNT	sqliteInt.h	78;"	d
SQLITE_MAX_PAGE_COUNT	sqliteInt.h	90;"	d
SQLITE_MAX_PAGE_COUNT	sqliteLimit.h	170;"	d
SQLITE_MAX_PAGE_SIZE	sqliteInt.h	77;"	d
SQLITE_MAX_PAGE_SIZE	sqliteInt.h	89;"	d
SQLITE_MAX_PAGE_SIZE	sqliteLimit.h	131;"	d
SQLITE_MAX_SQL_LENGTH	sqliteInt.h	71;"	d
SQLITE_MAX_SQL_LENGTH	sqliteInt.h	83;"	d
SQLITE_MAX_SQL_LENGTH	sqliteLimit.h	55;"	d
SQLITE_MAX_VARIABLE_NUMBER	sqliteInt.h	76;"	d
SQLITE_MAX_VARIABLE_NUMBER	sqliteInt.h	88;"	d
SQLITE_MAX_VARIABLE_NUMBER	sqliteLimit.h	123;"	d
SQLITE_MAX_VDBE_OP	sqliteInt.h	74;"	d
SQLITE_MAX_VDBE_OP	sqliteInt.h	86;"	d
SQLITE_MAX_VDBE_OP	sqliteLimit.h	86;"	d
SQLITE_MIXED_ENDIAN_64BIT_FLOAT	sqliteInt.h	175;"	d
SQLITE_MUTEX_NOOP	mutex.h	51;"	d
SQLITE_MUTEX_NOOP	mutex.h	53;"	d
SQLITE_MUTEX_NOOP	mutex.h	57;"	d
SQLITE_MUTEX_NOOP	mutex.h	61;"	d
SQLITE_MUTEX_NOOP	mutex.h	65;"	d
SQLITE_MUTEX_NOOP_DEBUG	mutex.h	54;"	d
SQLITE_MUTEX_OS2	mutex.h	66;"	d
SQLITE_MUTEX_PTHREADS	mutex.h	58;"	d
SQLITE_MUTEX_W32	mutex.h	62;"	d
SQLITE_NULLEQUAL	sqliteInt.h	729;"	d
SQLITE_N_BTREE_META	btree.h	24;"	d
SQLITE_NoReadlock	sqliteInt.h	574;"	d
SQLITE_NullCallback	sqliteInt.h	569;"	d
SQLITE_OMIT_DATETIME_FUNCS	sqliteInt.h	173;"	d
SQLITE_OMIT_TRACE	sqliteInt.h	174;"	d
SQLITE_OS2_THREADS	os_os2.c	50;"	d	file:
SQLITE_PRINT_BUF_SIZE	printf.c	191;"	d	file:
SQLITE_ReadUncommitted	sqliteInt.h	577;"	d
SQLITE_RecoveryMode	sqliteInt.h	582;"	d
SQLITE_SKIP_UTF8	sqliteInt.h	1649;"	d
SQLITE_SO_ASC	sqliteInt.h	693;"	d
SQLITE_SO_DESC	sqliteInt.h	694;"	d
SQLITE_STOREP2	sqliteInt.h	730;"	d
SQLITE_SharedCache	sqliteInt.h	583;"	d
SQLITE_ShortColNames	sqliteInt.h	565;"	d
SQLITE_SqlTrace	sqliteInt.h	571;"	d
SQLITE_TEMPNAME_SIZE	os.h	74;"	d
SQLITE_TEMPNAME_SIZE	os.h	87;"	d
SQLITE_TEMPNAME_SIZE	os.h	89;"	d
SQLITE_TEMP_FILE_PREFIX	os.h	128;"	d
SQLITE_THREADSAFE	sqliteInt.h	114;"	d
SQLITE_THREADSAFE	sqliteInt.h	116;"	d
SQLITE_THREAD_OVERRIDE_LOCK	os_unix.c	394;"	d	file:
SQLITE_UNIX_THREADS	os_unix.c	63;"	d	file:
SQLITE_UTF16NATIVE	sqliteInt.h	288;"	d
SQLITE_UTF16NATIVE	sqliteInt.h	292;"	d
SQLITE_VdbeListing	sqliteInt.h	572;"	d
SQLITE_VdbeTrace	sqliteInt.h	561;"	d
SQLITE_Vtab	sqliteInt.h	584;"	d
SQLITE_W32_THREADS	os_win.c	55;"	d	file:
SQLITE_WriteSchema	sqliteInt.h	573;"	d
SRT_Callback	sqliteInt.h	1358;"	d
SRT_Discard	sqliteInt.h	1353;"	d
SRT_EphemTab	sqliteInt.h	1362;"	d
SRT_Except	sqliteInt.h	1351;"	d
SRT_Exists	sqliteInt.h	1352;"	d
SRT_Mem	sqliteInt.h	1359;"	d
SRT_Set	sqliteInt.h	1360;"	d
SRT_Subroutine	sqliteInt.h	1363;"	d
SRT_Table	sqliteInt.h	1361;"	d
SRT_Union	sqliteInt.h	1350;"	d
STRICMP	build.c	918;"	d	file:
SWAP	where.c	382;"	d	file:
Schema	sqliteInt.h	/^struct Schema {$/;"	s
Schema	sqliteInt.h	/^typedef struct Schema Schema;$/;"	t	typeref:struct:Schema
Select	sqliteInt.h	/^struct Select {$/;"	s
Select	sqliteInt.h	/^typedef struct Select Select;$/;"	t	typeref:struct:Select
SelectDest	sqliteInt.h	/^struct SelectDest {$/;"	s
SelectDest	sqliteInt.h	/^typedef struct SelectDest SelectDest;$/;"	t	typeref:struct:SelectDest
ServerState	test_server.c	/^static struct ServerState {$/;"	s	file:
Set	vdbeInt.h	/^struct Set {$/;"	s
Set	vdbeInt.h	/^typedef struct Set Set;$/;"	t	typeref:struct:Set
SimulateDiskfullError	os_common.h	103;"	d
SimulateDiskfullError	os_common.h	116;"	d
SimulateIOError	os_common.h	115;"	d
SimulateIOError	os_common.h	94;"	d
SqlCollate	tclsqlite.c	/^struct SqlCollate {$/;"	s	file:
SqlCollate	tclsqlite.c	/^typedef struct SqlCollate SqlCollate;$/;"	t	typeref:struct:SqlCollate	file:
SqlFunc	tclsqlite.c	/^struct SqlFunc {$/;"	s	file:
SqlFunc	tclsqlite.c	/^typedef struct SqlFunc SqlFunc;$/;"	t	typeref:struct:SqlFunc	file:
SqlMessage	test_server.c	/^struct SqlMessage {$/;"	s	file:
SqlMessage	test_server.c	/^typedef struct SqlMessage SqlMessage;$/;"	t	typeref:struct:SqlMessage	file:
SqlPreparedStmt	tclsqlite.c	/^struct SqlPreparedStmt {$/;"	s	file:
SqlPreparedStmt	tclsqlite.c	/^typedef struct SqlPreparedStmt SqlPreparedStmt;$/;"	t	typeref:struct:SqlPreparedStmt	file:
SqlThread	test_thread.c	/^struct SqlThread {$/;"	s	file:
SqlThread	test_thread.c	/^typedef struct SqlThread SqlThread;$/;"	t	typeref:struct:SqlThread	file:
Sqlite3_Init	tclsqlite.c	/^EXTERN int Sqlite3_Init(Tcl_Interp *interp){$/;"	f
Sqlite3_SafeInit	tclsqlite.c	/^EXTERN int Sqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
SqliteDb	tclsqlite.c	/^struct SqliteDb {$/;"	s	file:
SqliteDb	tclsqlite.c	/^typedef struct SqliteDb SqliteDb;$/;"	t	typeref:struct:SqliteDb	file:
SqliteDb	test1.c	/^struct SqliteDb {$/;"	s	file:
Sqlite_Init	tclsqlite.c	/^EXTERN int Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Sqlite_SafeInit	tclsqlite.c	/^EXTERN int Sqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqliteconfig_Init	test_config.c	/^int Sqliteconfig_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest1_Init	test1.c	/^int Sqlitetest1_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest2_Init	test2.c	/^int Sqlitetest2_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest3_Init	test3.c	/^int Sqlitetest3_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest4_Init	test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest4_Init	test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest5_Init	test5.c	/^int Sqlitetest5_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest6_Init	test6.c	/^int Sqlitetest6_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest7_Init	test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest7_Init	test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest8_Init	test8.c	/^int Sqlitetest8_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest9_Init	test9.c	/^int Sqlitetest9_Init(Tcl_Interp *interp){$/;"	f
SqlitetestOnefile_Init	test_onefile.c	/^  int SqlitetestOnefile_Init() {return fs_register();}$/;"	f
SqlitetestThread_Init	test_thread.c	/^int SqlitetestThread_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_autoext_Init	test_autoext.c	/^int Sqlitetest_autoext_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_hexio_Init	test_hexio.c	/^int Sqlitetest_hexio_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_malloc_Init	test_malloc.c	/^int Sqlitetest_malloc_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestasync_Init	test_async.c	/^int Sqlitetestasync_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestschema_Init	test_schema.c	/^int Sqlitetestschema_Init(Tcl_Interp *interp){$/;"	f
Sqlitetesttclvar_Init	test_tclvar.c	/^int Sqlitetesttclvar_Init(Tcl_Interp *interp){$/;"	f
SrcList	sqliteInt.h	/^struct SrcList {$/;"	s
SrcList	sqliteInt.h	/^typedef struct SrcList SrcList;$/;"	t	typeref:struct:SrcList
SrcList_item	sqliteInt.h	/^  struct SrcList_item {$/;"	s	struct:SrcList
StmtToDb	test1.c	158;"	d	file:
StrAccum	sqliteInt.h	/^struct StrAccum {$/;"	s
StrAccum	sqliteInt.h	/^typedef struct StrAccum StrAccum;$/;"	t	typeref:struct:StrAccum
Stringify	vdbe.c	122;"	d	file:
SumCtx	func.c	/^struct SumCtx {$/;"	s	file:
SumCtx	func.c	/^typedef struct SumCtx SumCtx;$/;"	t	typeref:struct:SumCtx	file:
TCLSH_MAIN	tclsqlite.c	/^int TCLSH_MAIN(int argc, char **argv){$/;"	f
TCLSH_MAIN	tclsqlite.c	2514;"	d	file:
TCL_STORAGE_CLASS	tclsqlite.c	37;"	d	file:
TCL_STORAGE_CLASS	tclsqlite.c	38;"	d	file:
TEMP_MASTER_NAME	sqliteInt.h	317;"	d
TEMP_STORE	sqliteInt.h	222;"	d
TERM_CODED	where.c	95;"	d	file:
TERM_COPIED	where.c	96;"	d	file:
TERM_DYNAMIC	where.c	93;"	d	file:
TERM_OR_OK	where.c	97;"	d	file:
TERM_VIRTUAL	where.c	94;"	d	file:
TIMER_ELAPSED	os_common.h	76;"	d
TIMER_ELAPSED	os_common.h	80;"	d
TIMER_END	os_common.h	75;"	d
TIMER_END	os_common.h	79;"	d
TIMER_START	os_common.h	74;"	d
TIMER_START	os_common.h	78;"	d
TRACE	btreeInt.h	490;"	d
TRACE	btreeInt.h	492;"	d
TRACE_IDX_INPUTS	where.c	/^static void TRACE_IDX_INPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_INPUTS	where.c	1194;"	d	file:
TRACE_IDX_OUTPUTS	where.c	/^static void TRACE_IDX_OUTPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_OUTPUTS	where.c	1195;"	d	file:
TRANS_NONE	btreeInt.h	345;"	d
TRANS_READ	btreeInt.h	346;"	d
TRANS_WRITE	btreeInt.h	347;"	d
TRIGGER_AFTER	sqliteInt.h	1512;"	d
TRIGGER_BEFORE	sqliteInt.h	1511;"	d
TabResult	table.c	/^typedef struct TabResult {$/;"	s	file:
TabResult	table.c	/^} TabResult;$/;"	t	typeref:struct:TabResult	file:
Table	sqliteInt.h	/^struct Table {$/;"	s
Table	sqliteInt.h	/^typedef struct Table Table;$/;"	t	typeref:struct:Table
TableLock	build.c	/^struct TableLock {$/;"	s	file:
TableLock	sqliteInt.h	/^typedef struct TableLock TableLock;$/;"	t	typeref:struct:TableLock
Tcl_InitStubs	tclsqlite.c	2426;"	d	file:
Tcl_InitStubs	tclsqlite.c	2427;"	d	file:
Tclsqlite3_Init	tclsqlite.c	/^EXTERN int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite3_SafeInit	tclsqlite.c	/^EXTERN int Tclsqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Tclsqlite_Init	tclsqlite.c	/^EXTERN int Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite_SafeInit	tclsqlite.c	/^EXTERN int Tclsqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
TestAsyncDebugData	test_async.c	/^static struct TestAsyncDebugData {$/;"	s	file:
TestAsyncStaticData	test_async.c	/^static struct TestAsyncStaticData {$/;"	s	file:
TestCollationX	test1.c	/^struct TestCollationX {$/;"	s	file:
TestCollationX	test1.c	/^typedef struct TestCollationX TestCollationX;$/;"	t	typeref:struct:TestCollationX	file:
Thread	test4.c	/^struct Thread {$/;"	s	file:
Thread	test4.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Thread	test7.c	/^struct Thread {$/;"	s	file:
Thread	test7.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Token	sqliteInt.h	/^struct Token {$/;"	s
Token	sqliteInt.h	/^typedef struct Token Token;$/;"	t	typeref:struct:Token
Trigger	sqliteInt.h	/^struct Trigger {$/;"	s
Trigger	sqliteInt.h	/^typedef struct Trigger Trigger;$/;"	t	typeref:struct:Trigger
TriggerStack	sqliteInt.h	/^struct TriggerStack {$/;"	s
TriggerStack	sqliteInt.h	/^typedef struct TriggerStack TriggerStack;$/;"	t	typeref:struct:TriggerStack
TriggerStep	sqliteInt.h	/^struct TriggerStep {$/;"	s
TriggerStep	sqliteInt.h	/^typedef struct TriggerStep TriggerStep;$/;"	t	typeref:struct:TriggerStep
UINT16_TYPE	sqliteInt.h	254;"	d
UINT32_TYPE	sqliteInt.h	251;"	d
UINT8_TYPE	sqliteInt.h	260;"	d
UPDATE_MAX_BLOBSIZE	vdbe.c	107;"	d	file:
UPDATE_MAX_BLOBSIZE	vdbe.c	109;"	d	file:
UTF_TRANSLATION_NEEDED	tclsqlite.c	51;"	d	file:
UnlockFile	os_win.c	314;"	d	file:
UpperToLower	util.c	176;"	d	file:
VDBE_MAGIC_DEAD	vdbeInt.h	350;"	d
VDBE_MAGIC_HALT	vdbeInt.h	349;"	d
VDBE_MAGIC_INIT	vdbeInt.h	347;"	d
VDBE_MAGIC_RUN	vdbeInt.h	348;"	d
Vdbe	vdbe.h	/^typedef struct Vdbe Vdbe;$/;"	t	typeref:struct:Vdbe
Vdbe	vdbeInt.h	/^struct Vdbe {$/;"	s
VdbeComment	vdbe.h	178;"	d
VdbeComment	vdbe.h	180;"	d
VdbeFunc	vdbe.h	/^typedef struct VdbeFunc VdbeFunc;$/;"	t	typeref:struct:VdbeFunc
VdbeFunc	vdbeInt.h	/^struct VdbeFunc {$/;"	s
VdbeOp	vdbe.h	/^struct VdbeOp {$/;"	s
VdbeOp	vdbe.h	/^typedef struct VdbeOp VdbeOp;$/;"	t	typeref:struct:VdbeOp
VdbeOpList	vdbe.h	/^struct VdbeOpList {$/;"	s
VdbeOpList	vdbe.h	/^typedef struct VdbeOpList VdbeOpList;$/;"	t	typeref:struct:VdbeOpList
WHERETRACE	where.c	33;"	d	file:
WHERETRACE	where.c	35;"	d	file:
WHERE_BTM_LIMIT	where.c	175;"	d	file:
WHERE_COLUMN_EQ	where.c	171;"	d	file:
WHERE_COLUMN_IN	where.c	173;"	d	file:
WHERE_COLUMN_RANGE	where.c	172;"	d	file:
WHERE_IDX_ONLY	where.c	176;"	d	file:
WHERE_ORDERBY	where.c	177;"	d	file:
WHERE_REVERSE	where.c	178;"	d	file:
WHERE_ROWID_EQ	where.c	169;"	d	file:
WHERE_ROWID_RANGE	where.c	170;"	d	file:
WHERE_TOP_LIMIT	where.c	174;"	d	file:
WHERE_UNIQUE	where.c	179;"	d	file:
WHERE_VIRTUALTABLE	where.c	180;"	d	file:
WO_EQ	where.c	150;"	d	file:
WO_GE	where.c	154;"	d	file:
WO_GT	where.c	153;"	d	file:
WO_IN	where.c	149;"	d	file:
WO_ISNULL	where.c	156;"	d	file:
WO_LE	where.c	152;"	d	file:
WO_LT	where.c	151;"	d	file:
WO_MATCH	where.c	155;"	d	file:
WRITE_LOCK	btreeInt.h	533;"	d
WRITE_UTF16BE	utf.c	96;"	d	file:
WRITE_UTF16LE	utf.c	84;"	d	file:
WRITE_UTF8	utf.c	64;"	d	file:
WhereClause	where.c	/^struct WhereClause {$/;"	s	file:
WhereClause	where.c	/^typedef struct WhereClause WhereClause;$/;"	t	typeref:struct:WhereClause	file:
WhereInfo	sqliteInt.h	/^struct WhereInfo {$/;"	s
WhereInfo	sqliteInt.h	/^typedef struct WhereInfo WhereInfo;$/;"	t	typeref:struct:WhereInfo
WhereLevel	sqliteInt.h	/^struct WhereLevel {$/;"	s
WhereLevel	sqliteInt.h	/^typedef struct WhereLevel WhereLevel;$/;"	t	typeref:struct:WhereLevel
WhereTerm	where.c	/^struct WhereTerm {$/;"	s	file:
WhereTerm	where.c	/^typedef struct WhereTerm WhereTerm;$/;"	t	typeref:struct:WhereTerm	file:
WriteBuffer	test6.c	/^struct WriteBuffer {$/;"	s	file:
WriteBuffer	test6.c	/^typedef struct WriteBuffer WriteBuffer;$/;"	t	typeref:struct:WriteBuffer	file:
Y	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
_AFPFSSetLock	os_unix.c	/^static int _AFPFSSetLock($/;"	f	file:
_BTREE_H_	btree.h	19;"	d
_FILE_OFFSET_BITS	os_unix.c	36;"	d	file:
_FILE_OFFSET_BITS	sqliteInt.h	56;"	d
_LARGEFILE_SOURCE	os_unix.c	38;"	d	file:
_LARGEFILE_SOURCE	sqliteInt.h	58;"	d
_LARGE_FILE	os_unix.c	34;"	d	file:
_LARGE_FILE	sqliteInt.h	54;"	d
_OvflCell	btreeInt.h	/^  struct _OvflCell {   \/* Cells that will not fit on aData[] *\/$/;"	s	struct:MemPage
_PAGER_H_	pager.h	20;"	d
_SQLITE3EXT_H_	sqlite3ext.h	21;"	d
_SQLITEINT_H_	sqliteInt.h	17;"	d
_SQLITE_HASH_H_	hash.h	18;"	d
_SQLITE_OS_C_	os.c	16;"	d	file:
_SQLITE_OS_C_	os.c	18;"	d	file:
_SQLITE_OS_H_	os.h	21;"	d
_SQLITE_VDBE_H_	vdbe.h	21;"	d
_VDBEINT_H_	vdbeInt.h	19;"	d
_XOPEN_SOURCE	sqliteInt.h	134;"	d
_all_whitespace	shell.c	/^static int _all_whitespace(const char *z){$/;"	f	file:
_contains_semicolon	shell.c	/^static int _contains_semicolon(const char *z, int N){$/;"	f	file:
_ht	hash.h	/^  struct _ht {            \/* the hash table *\/$/;"	s	struct:Hash
_is_command_terminator	shell.c	/^static int _is_command_terminator(const char *zLine){$/;"	f	file:
_page_ref	pager.c	/^static void _page_ref(PgHdr *pPg){$/;"	f	file:
_storeTypeInfo	vdbe.c	/^static void _storeTypeInfo(Mem *pMem){$/;"	f	file:
a	sqliteInt.h	/^  WhereLevel a[1];     \/* Information about each nest loop in the WHERE *\/$/;"	m	struct:WhereInfo
a	sqliteInt.h	/^  } *a;                  \/* One entry for each expression *\/$/;"	m	struct:ExprList	typeref:struct:ExprList::ExprList_item
a	sqliteInt.h	/^  } *a;$/;"	m	struct:IdList	typeref:struct:IdList::IdList_item
a	sqliteInt.h	/^  } a[1];             \/* One entry for each identifier on the list *\/$/;"	m	struct:SrcList	typeref:struct:SrcList::SrcList_item
a	where.c	/^  WhereTerm *a;            \/* Each a[] describes a term of the WHERE cluase *\/$/;"	m	struct:WhereClause	file:
aBtree	btree.h	/^  Btree *aBtree[SQLITE_MAX_ATTACHED+1];$/;"	m	struct:BtreeMutexArray
aCol	sqliteInt.h	/^  Column *aCol;    \/* Information about each column *\/$/;"	m	struct:Table
aCol	sqliteInt.h	/^  } *aCol;          \/* One entry for each of nCol column s *\/$/;"	m	struct:FKey	typeref:struct:FKey::sColMap
aCol	sqliteInt.h	/^  } *aCol;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_col
aCol	test8.c	/^  char **aCol;            \/* Array of size nCol. Column names *\/$/;"	m	struct:echo_vtab	file:
aColName	vdbeInt.h	/^  Mem *aColName;      \/* Column names to return *\/$/;"	m	struct:Vdbe
aColl	sqliteInt.h	/^  CollSeq *aColl[1];  \/* Collating sequence for each term of the key *\/$/;"	m	struct:KeyInfo
aCollSeq	sqliteInt.h	/^  Hash aCollSeq;                \/* All collating sequences *\/$/;"	m	struct:sqlite3
aData	btreeInt.h	/^  u8 *aData;           \/* Pointer to disk image of the page data *\/$/;"	m	struct:MemPage
aDb	sqliteInt.h	/^  Db *aDb;                      \/* All backends *\/$/;"	m	struct:sqlite3
aDbStatic	sqliteInt.h	/^  Db aDbStatic[2];              \/* Static space for the 2 default backends *\/$/;"	m	struct:sqlite3
aDigits	printf.c	/^static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";$/;"	v	file:
aExt	loadext.c	/^  void **aExt;     \/* Pointers to the extension init functions *\/$/;"	m	struct:__anon13	file:
aExtension	sqliteInt.h	/^  void **aExtension;            \/* Array of shared libraray handles *\/$/;"	m	struct:sqlite3
aFKey	sqliteInt.h	/^  Hash aFKey;          \/* Foreign keys indexed by to-table *\/$/;"	m	struct:Schema
aFault	fault.c	/^} aFault[SQLITE_FAULTINJECTOR_COUNT];$/;"	v	typeref:struct:FaultInjector	file:
aFunc	sqliteInt.h	/^  Hash aFunc;                   \/* All functions that can be in SQL exprs *\/$/;"	m	struct:sqlite3
aFunc	sqliteInt.h	/^  } *aFunc;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_func
aHash	pager.c	/^  PgHdr **aHash;              \/* Hash table to map page number to PgHdr *\/$/;"	m	struct:Pager	file:
aInJournal	pager.c	/^  u8 *aInJournal;             \/* One bit for each page in the database file *\/$/;"	m	struct:Pager	file:
aInLoop	sqliteInt.h	/^  } *aInLoop;           \/* Information about each nested IN operator *\/$/;"	m	struct:WhereLevel	typeref:struct:WhereLevel::InLoop
aInStmt	pager.c	/^  u8 *aInStmt;                \/* One bit for each page in the database *\/$/;"	m	struct:Pager	file:
aIndex	test8.c	/^  int *aIndex;            \/* Array of size nCol. True if column has an index *\/$/;"	m	struct:echo_vtab	file:
aJournalMagic	pager.c	/^static const unsigned char aJournalMagic[] = {$/;"	v	file:
aLabel	vdbeInt.h	/^  int *aLabel;        \/* Space to hold the labels *\/$/;"	m	struct:Vdbe
aLock	test_async.c	/^  Hash aLock;                  \/* Files locked *\/$/;"	m	struct:TestAsyncStaticData	file:
aMem	vdbeInt.h	/^  Mem *aMem;              \/* The memory locations *\/$/;"	m	struct:Vdbe
aModule	sqliteInt.h	/^  Hash aModule;                 \/* populated by sqlite3_create_module() *\/$/;"	m	struct:sqlite3
aMutex	vdbeInt.h	/^  BtreeMutexArray aMutex; \/* An array of Btree used here and needing locks *\/$/;"	m	struct:Vdbe
aOffset	vdbeInt.h	/^  u32 *aOffset;         \/* Cached offsets to the start of each columns data *\/$/;"	m	struct:Cursor
aOp	vdbeInt.h	/^  Op *aOp;            \/* Space to hold the virtual machine's program *\/$/;"	m	struct:Vdbe
aOverflow	btreeInt.h	/^  Pgno *aOverflow;          \/* Cache of overflow page locations *\/$/;"	m	struct:BtCursor
aOvfl	btreeInt.h	/^  } aOvfl[5];$/;"	m	struct:MemPage	typeref:struct:MemPage::_OvflCell
aPadding	os_unix.c	/^  char aPadding[32];$/;"	m	struct:unixFile	file:
aPending	os_unix.c	/^  int *aPending;        \/* Malloced space holding fd's awaiting a close() *\/$/;"	m	struct:openCnt	file:
aPool	mem3.c	/^  Mem3Block aPool[SQLITE_MEMORY_SIZE\/sizeof(Mem3Block)+2];$/;"	m	struct:__anon11	file:
aPrefix	printf.c	/^static const char aPrefix[] = "-x0\\000X0";$/;"	v	file:
aRow	vdbeInt.h	/^  u8 *aRow;             \/* Data for the current row, if all on one page *\/$/;"	m	struct:Cursor
aSlot	vdbeInt.h	/^  i64 aSlot[1];      \/* One or more slots for rowid values *\/$/;"	m	struct:FifoPage
aSortOrder	sqliteInt.h	/^  u8 *aSortOrder;     \/* If defined an aSortOrder[i] is true, sort DESC *\/$/;"	m	struct:KeyInfo
aSortOrder	sqliteInt.h	/^  u8 *aSortOrder;  \/* Array of size Index.nColumn. True==DESC, False==ASC *\/$/;"	m	struct:Index
aStatic	where.c	/^  WhereTerm aStatic[10];   \/* Initial static space for a[] *\/$/;"	m	struct:WhereClause	file:
aTableLock	sqliteInt.h	/^  TableLock *aTableLock; \/* Required table locks for shared-cache mode *\/$/;"	m	struct:Parse
aTempReg	sqliteInt.h	/^  int aTempReg[8];     \/* Holding area for temporary registers *\/$/;"	m	struct:Parse
aType	vdbeInt.h	/^  u32 *aType;           \/* Type values for all entries in the record *\/$/;"	m	struct:Cursor
aVTrans	sqliteInt.h	/^  sqlite3_vtab **aVTrans;       \/* Virtual tables with open transactions *\/$/;"	m	struct:sqlite3
aVar	vdbeInt.h	/^  Mem *aVar;          \/* Values for the OP_Variable opcode. *\/$/;"	m	struct:Vdbe
aborted	vdbeInt.h	/^  u8 aborted;             \/* True if ROLLBACK in another VM causes an abort *\/$/;"	m	struct:Vdbe
absFunc	func.c	/^static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
accessPayload	btree.c	/^static int accessPayload($/;"	f	file:
activeVdbeCnt	sqliteInt.h	/^  int activeVdbeCnt;            \/* Number of vdbes currently executing *\/$/;"	m	struct:sqlite3
actualWidth	shell.c	/^  int actualWidth[100];  \/* Actual width of each column *\/$/;"	m	struct:callback_data	file:
addAggInfoColumn	expr.c	/^static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addAggInfoFunc	expr.c	/^static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addArgumentToVtab	vtab.c	/^static void addArgumentToVtab(Parse *pParse){$/;"	f	file:
addAsyncWrite	test_async.c	/^static void addAsyncWrite(AsyncWrite *pWrite){$/;"	f	file:
addColOffset	sqliteInt.h	/^  int addColOffset;  \/* Offset in CREATE TABLE statement to add a new column *\/$/;"	m	struct:Table
addModuleArgument	vtab.c	/^static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){$/;"	f	file:
addNewAsyncWrite	test_async.c	/^static int addNewAsyncWrite($/;"	f	file:
addToVTrans	vtab.c	/^static int addToVTrans(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f	file:
addWhereTerm	select.c	/^static void addWhereTerm($/;"	f	file:
add_alignment_test_collations	test1.c	/^static int add_alignment_test_collations($/;"	f	file:
add_column_fullname	parse.y	/^add_column_fullname ::= fullname(X). {$/;"	l
add_history	shell.c	41;"	d	file:
addrOpenEphm	sqliteInt.h	/^  int addrOpenEphm[3];   \/* OP_OpenEphem opcodes related to this select *\/$/;"	m	struct:Select
affinity	sqliteInt.h	/^  char affinity;         \/* MakeRecord with this affinity for SRT_Set *\/$/;"	m	struct:Select
affinity	sqliteInt.h	/^  char affinity;         \/* The affinity of the column or 0 if not a column *\/$/;"	m	struct:Expr
affinity	sqliteInt.h	/^  char affinity;   \/* One of the SQLITE_AFF_... values *\/$/;"	m	struct:Column
affinity	sqliteInt.h	/^  u8 affinity;      \/* Affinity used when eDest==SRT_Set *\/$/;"	m	struct:SelectDest
afpLockingContext	os_unix.c	/^struct afpLockingContext {$/;"	s	file:
afpLockingContext	os_unix.c	/^typedef struct afpLockingContext afpLockingContext;$/;"	t	typeref:struct:afpLockingContext	file:
afpLockingStyle	os_unix.c	/^        afpLockingStyle,             \/* use afp locks *\/$/;"	e	enum:__anon4	file:
afpUnixCheckReservedLock	os_unix.c	/^static int afpUnixCheckReservedLock(sqlite3_file *id){$/;"	f	file:
afpUnixClose	os_unix.c	/^static int afpUnixClose(sqlite3_file *id) {$/;"	f	file:
afpUnixLock	os_unix.c	/^static int afpUnixLock(sqlite3_file *id, int locktype)$/;"	f	file:
afpUnixUnlock	os_unix.c	/^static int afpUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
afpfsByteRangeLock2FSCTL	os_unix.c	1471;"	d	file:
aggregate_context	sqlite3ext.h	/^  void * (*aggregate_context)(sqlite3_context*,int nBytes);$/;"	m	struct:sqlite3_api_routines
aggregate_count	sqlite3ext.h	/^  int  (*aggregate_count)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
aiColumn	sqliteInt.h	/^  int *aiColumn;   \/* Which columns are used by this index.  1st is 0 *\/$/;"	m	struct:Index
aiHash	mem3.c	/^  u32 aiHash[N_HASH];        \/* For sizes MX_SMALL+1 and larger *\/$/;"	m	struct:__anon11	file:
aiRowEst	sqliteInt.h	/^  unsigned *aiRowEst; \/* Result of ANALYZE: Est. rows selected by each column *\/$/;"	m	struct:Index
aiSmall	mem3.c	/^  u32 aiSmall[MX_SMALL-1];   \/* For sizes 2 through MX_SMALL, inclusive *\/$/;"	m	struct:__anon11	file:
alarmArg	mem1.c	/^  void *alarmArg;$/;"	m	struct:__anon1	file:
alarmArg	mem2.c	/^  void *alarmArg;$/;"	m	struct:__anon5	file:
alarmArg	mem4.c	/^  void *alarmArg;$/;"	m	struct:__anon7	file:
alarmBusy	mem1.c	/^  int alarmBusy;$/;"	m	struct:__anon1	file:
alarmBusy	mem2.c	/^  int alarmBusy;$/;"	m	struct:__anon5	file:
alarmBusy	mem3.c	/^  int alarmBusy;$/;"	m	struct:__anon11	file:
alarmBusy	mem4.c	/^  int alarmBusy;$/;"	m	struct:__anon7	file:
alarmCallback	mem1.c	/^  void (*alarmCallback)(void*, sqlite3_int64,int);$/;"	m	struct:__anon1	file:
alarmCallback	mem2.c	/^  void (*alarmCallback)(void*, sqlite3_int64, int);$/;"	m	struct:__anon5	file:
alarmCallback	mem4.c	/^  void (*alarmCallback)(void*, sqlite3_int64,int);$/;"	m	struct:__anon7	file:
alarmThreshold	mem1.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon1	file:
alarmThreshold	mem2.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon5	file:
alarmThreshold	mem4.c	/^  sqlite3_int64 alarmThreshold;$/;"	m	struct:__anon7	file:
alignmentCollFunc	test1.c	/^static int alignmentCollFunc($/;"	f	file:
allSpaces	main.c	/^static int allSpaces(const char *z, int n){$/;"	f	file:
allocateBtreePage	btree.c	/^static int allocateBtreePage($/;"	f	file:
allocateCursor	vdbe.c	/^static Cursor *allocateCursor(Vdbe *p, int iCur, int iDb){$/;"	f	file:
allocateFifoPage	vdbefifo.c	/^static FifoPage *allocateFifoPage(int nEntry){$/;"	f	file:
allocateSpace	btree.c	/^static int allocateSpace(MemPage *pPage, int nByte){$/;"	f	file:
allowAgg	sqliteInt.h	/^  u8 allowAgg;         \/* Aggregate functions allowed here *\/$/;"	m	struct:NameContext
allowedOp	where.c	/^static int allowedOp(int op){$/;"	f	file:
alwaysRollback	pager.c	/^  u8 alwaysRollback;             \/* Disable DontRollback() for this page *\/$/;"	m	struct:PgHdr	file:
alwaysRollback	pager.c	/^  u8 alwaysRollback;          \/* Disable DontRollback() for all pages *\/$/;"	m	struct:Pager	file:
anRef	btreeInt.h	/^  int *anRef;       \/* Number of times each page is referenced *\/$/;"	m	struct:IntegrityCk
analysisInfo	analyze.c	/^struct analysisInfo {$/;"	s	file:
analysisInfo	analyze.c	/^typedef struct analysisInfo analysisInfo;$/;"	t	typeref:struct:analysisInfo	file:
analysisLoader	analyze.c	/^static int analysisLoader(void *pData, int argc, char **argv, char **azNotUsed){$/;"	f	file:
analyzeAggregate	expr.c	/^static int analyzeAggregate(void *pArg, Expr *pExpr){$/;"	f	file:
analyzeDatabase	analyze.c	/^static void analyzeDatabase(Parse *pParse, int iDb){$/;"	f	file:
analyzeOneTable	analyze.c	/^static void analyzeOneTable($/;"	f	file:
analyzeTable	analyze.c	/^static void analyzeTable(Parse *pParse, Table *pTab){$/;"	f	file:
anylist	parse.y	/^anylist ::= .$/;"	l
anylist	parse.y	/^anylist ::= anylist ANY(X).         {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
apArg	vdbeInt.h	/^  Mem **apArg;        \/* Arguments to currently executing user function *\/$/;"	m	struct:Vdbe
apAux	vdbeInt.h	/^  } apAux[1];                   \/* One slot for each function argument *\/$/;"	m	struct:VdbeFunc	typeref:struct:VdbeFunc::AuxData
apCsr	vdbeInt.h	/^  Cursor **apCsr;     \/* One element of this array for each open cursor *\/$/;"	m	struct:Vdbe
apInfo	sqliteInt.h	/^  sqlite3_index_info **apInfo;  \/* Array of pointers to index info structures *\/$/;"	m	struct:WhereInfo
apVarExpr	sqliteInt.h	/^  Expr **apVarExpr;    \/* Pointers to :aaa and $aaaa wildcard expressions *\/$/;"	m	struct:Parse
appendSpace	printf.c	/^static void appendSpace(StrAccum *pAccum, int N){$/;"	f	file:
appendText	shell.c	/^static char *appendText(char *zIn, char const *zAppend, char quote){$/;"	f	file:
appendToEchoModule	test8.c	/^static void appendToEchoModule(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
applyAffinity	vdbe.c	/^static void applyAffinity($/;"	f	file:
applyNumericAffinity	vdbe.c	/^static void applyNumericAffinity(Mem *pRec){$/;"	f	file:
approx	func.c	/^  u8 approx;        \/* True if non-integer value was input to the sum *\/$/;"	m	struct:SumCtx	file:
argc	test4.c	/^  int argc;             \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argc	test7.c	/^  int argc;                \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argv	test4.c	/^  const char *argv[100];    \/* result columns *\/$/;"	m	struct:Thread	file:
argv	test7.c	/^  const char *argv[100];   \/* result columns *\/$/;"	m	struct:Thread	file:
assemblePage	btree.c	/^static void assemblePage($/;"	f	file:
assertCellInfo	btree.c	/^  static void assertCellInfo(BtCursor *pCur){$/;"	f	file:
assertCellInfo	btree.c	2853;"	d	file:
async	test_async.c	/^} async = {$/;"	v	typeref:struct:TestAsyncStaticData	file:
asyncAccess	test_async.c	/^static int asyncAccess(sqlite3_vfs *pAsyncVfs, const char *zName, int flags){$/;"	f	file:
asyncCheckReservedLock	test_async.c	/^static int asyncCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
asyncClose	test_async.c	/^static int asyncClose(sqlite3_file *pFile){$/;"	f	file:
asyncCurrentTime	test_async.c	/^static int asyncCurrentTime(sqlite3_vfs *pAsyncVfs, double *pTimeOut){$/;"	f	file:
asyncDelete	test_async.c	/^static int asyncDelete(sqlite3_vfs *pAsyncVfs, const char *z, int syncDir){$/;"	f	file:
asyncDeviceCharacteristics	test_async.c	/^static int asyncDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
asyncDlClose	test_async.c	/^static void asyncDlClose(sqlite3_vfs *pAsyncVfs, void *pHandle){$/;"	f	file:
asyncDlError	test_async.c	/^static void asyncDlError(sqlite3_vfs *pAsyncVfs, int nByte, char *zErrMsg){$/;"	f	file:
asyncDlOpen	test_async.c	/^static void *asyncDlOpen(sqlite3_vfs *pAsyncVfs, const char *zPath){$/;"	f	file:
asyncDlSym	test_async.c	/^static void *asyncDlSym($/;"	f	file:
asyncEnable	test_async.c	/^static void asyncEnable(int enable){$/;"	f	file:
asyncFileControl	test_async.c	/^static int asyncFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
asyncFileSize	test_async.c	/^int asyncFileSize(sqlite3_file *pFile, i64 *piSize){$/;"	f
asyncFullPathname	test_async.c	/^static int asyncFullPathname($/;"	f	file:
asyncGetTempname	test_async.c	/^static int asyncGetTempname(sqlite3_vfs *pAsyncVfs, int nBufOut, char *zBufOut){$/;"	f	file:
asyncLock	test_async.c	/^static int asyncLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncOpen	test_async.c	/^static int asyncOpen($/;"	f	file:
asyncRandomness	test_async.c	/^static int asyncRandomness(sqlite3_vfs *pAsyncVfs, int nByte, char *zBufOut){$/;"	f	file:
asyncRead	test_async.c	/^static int asyncRead(sqlite3_file *pFile, void *zOut, int iAmt, i64 iOffset){$/;"	f	file:
asyncSectorSize	test_async.c	/^static int asyncSectorSize(sqlite3_file *pFile){$/;"	f	file:
asyncSleep	test_async.c	/^static int asyncSleep(sqlite3_vfs *pAsyncVfs, int nMicro){$/;"	f	file:
asyncSync	test_async.c	/^static int asyncSync(sqlite3_file *pFile, int flags){$/;"	f	file:
asyncTrace	test_async.c	/^static void asyncTrace(const char *zFormat, ...){$/;"	f	file:
asyncTruncate	test_async.c	/^static int asyncTruncate(sqlite3_file *pFile, i64 nByte){$/;"	f	file:
asyncUnlock	test_async.c	/^static int asyncUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncWrite	test_async.c	/^static int asyncWrite(sqlite3_file *pFile, const void *pBuf, int amt, i64 iOff){$/;"	f	file:
asyncWriterThread	test_async.c	/^static void *asyncWriterThread(void *pIsStarted){$/;"	f	file:
async_cond_wait	test_async.c	/^static int async_cond_wait(pthread_cond_t *pCond, pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_lock	test_async.c	/^static int async_mutex_lock(pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_trylock	test_async.c	/^static int async_mutex_trylock(pthread_mutex_t *pMutex){$/;"	f	file:
async_mutex_unlock	test_async.c	/^static int async_mutex_unlock(pthread_mutex_t *pMutex){$/;"	f	file:
async_vfs	test_async.c	/^static sqlite3_vfs async_vfs = {$/;"	v	file:
asyncdebug	test_async.c	/^} asyncdebug = {0, 0, 0};$/;"	v	typeref:struct:TestAsyncDebugData	file:
atFirst	vdbeInt.h	/^  Bool atFirst;         \/* True if pointing to first entry *\/$/;"	m	struct:Cursor
attachFunc	attach.c	/^static void attachFunc($/;"	f	file:
auth_callback	tclsqlite.c	/^static int auth_callback($/;"	f	file:
autoCommit	sqliteInt.h	/^  u8 autoCommit;                \/* The auto-commit flag. *\/$/;"	m	struct:sqlite3
autoExtBrokenObjCmd	test_autoext.c	/^static int autoExtBrokenObjCmd($/;"	f	file:
autoExtCubeObjCmd	test_autoext.c	/^static int autoExtCubeObjCmd($/;"	f	file:
autoExtSqrObjCmd	test_autoext.c	/^static int autoExtSqrObjCmd($/;"	f	file:
autoInc	sqliteInt.h	/^  u8 autoInc;      \/* True if the integer primary key is autoincrement *\/$/;"	m	struct:Table
autoIncBegin	insert.c	/^static int autoIncBegin($/;"	f	file:
autoIncBegin	insert.c	238;"	d	file:
autoIncEnd	insert.c	/^static void autoIncEnd($/;"	f	file:
autoIncEnd	insert.c	240;"	d	file:
autoIncStep	insert.c	/^static void autoIncStep(Parse *pParse, int memId, int regRowid){$/;"	f	file:
autoIncStep	insert.c	239;"	d	file:
autoIndex	sqliteInt.h	/^  u8 autoIndex;    \/* True if is automatically created (ex: by UNIQUE) *\/$/;"	m	struct:Index
autoVacuum	btreeInt.h	/^  u8 autoVacuum;        \/* True if auto-vacuum is enabled *\/$/;"	m	struct:BtShared
autoVacuumCommit	btree.c	/^static int autoVacuumCommit(BtShared *pBt, Pgno *pnTrunc){$/;"	f	file:
autoext	loadext.c	/^} autoext = { 0, 0 };$/;"	v	typeref:struct:__anon13	file:
avgFinalize	func.c	/^static void avgFinalize(sqlite3_context *context){$/;"	f	file:
azColl	sqliteInt.h	/^  char **azColl;   \/* Array of collation sequence names for index *\/$/;"	m	struct:Index
azModuleArg	sqliteInt.h	/^  char **azModuleArg;       \/* Text of all module args. [0] is module name *\/$/;"	m	struct:Table
azOpcodeName	test_async.c	/^static const char *azOpcodeName[] = {$/;"	v	file:
azResColumn	vdbeInt.h	/^  char **azResColumn;     \/* Values for one row of result *\/ $/;"	m	struct:Vdbe
azResult	table.c	/^  char **azResult;$/;"	m	struct:TabResult	file:
azVar	vdbeInt.h	/^  char **azVar;       \/* Name of variables *\/$/;"	m	struct:Vdbe
bExclusive	os_win.c	/^  BOOL bExclusive;    \/* Indicates an exclusive lock has been obtained *\/$/;"	m	struct:winceLock	file:
bPending	os_win.c	/^  BOOL bPending;      \/* Indicates a pending lock has been obtained *\/$/;"	m	struct:winceLock	file:
bReserved	os_win.c	/^  BOOL bReserved;     \/* Indicates a reserved lock has been obtained *\/$/;"	m	struct:winceLock	file:
backtrace	mem2.c	55;"	d	file:
backtrace_symbols_fd	mem2.c	56;"	d	file:
bail_on_error	shell.c	/^static int bail_on_error = 0;$/;"	v	file:
balance	btree.c	/^static int balance(MemPage *pPage, int insert){$/;"	f	file:
balance_deeper	btree.c	/^static int balance_deeper(MemPage *pPage){$/;"	f	file:
balance_nonroot	btree.c	/^static int balance_nonroot(MemPage *pPage){$/;"	f	file:
balance_quick	btree.c	/^static int balance_quick(MemPage *pPage, MemPage *pParent){$/;"	f	file:
balance_shallower	btree.c	/^static int balance_shallower(MemPage *pPage){$/;"	f	file:
base	printf.c	/^  etByte base;             \/* The base for radix conversion *\/$/;"	m	struct:et_info	file:
base	test8.c	/^  sqlite3_vtab base;$/;"	m	struct:echo_vtab	file:
base	test8.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:echo_cursor	file:
base	test_devsym.c	/^  sqlite3_file base;$/;"	m	struct:devsym_file	file:
base	test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:fs_file	file:
base	test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:tmp_file	file:
base	test_onefile.c	/^  sqlite3_vfs base;$/;"	m	struct:fs_vfs_t	file:
base	test_schema.c	/^  sqlite3_vtab base;$/;"	m	struct:schema_vtab	file:
base	test_schema.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:schema_cursor	file:
base	test_tclvar.c	/^  sqlite3_vtab base;$/;"	m	struct:tclvar_vtab	file:
base	test_tclvar.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:tclvar_cursor	file:
base	test_thread.c	/^  Tcl_Event base;          \/* Base class of type Tcl_Event *\/$/;"	m	struct:EvalEvent	file:
beginTimer	shell.c	/^static void beginTimer(void){$/;"	f	file:
benign	fault.c	/^  u8 benign;        \/* Ture if next failure will be benign *\/$/;"	m	struct:FaultInjector	file:
bestIndex	where.c	/^static double bestIndex($/;"	f	file:
bestVirtualIndex	where.c	/^static double bestVirtualIndex($/;"	f	file:
binCollFunc	main.c	/^static int binCollFunc($/;"	f	file:
binCompare	hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binHash	hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binarize	test5.c	/^static int binarize($/;"	f	file:
binaryCompareP5	expr.c	/^static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){$/;"	f	file:
bindText	vdbeapi.c	/^static int bindText($/;"	f	file:
bind_blob	sqlite3ext.h	/^  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_double	sqlite3ext.h	/^  int  (*bind_double)(sqlite3_stmt*,int,double);$/;"	m	struct:sqlite3_api_routines
bind_int	sqlite3ext.h	/^  int  (*bind_int)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bind_int64	sqlite3ext.h	/^  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
bind_null	sqlite3ext.h	/^  int  (*bind_null)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_parameter_count	sqlite3ext.h	/^  int  (*bind_parameter_count)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
bind_parameter_index	sqlite3ext.h	/^  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);$/;"	m	struct:sqlite3_api_routines
bind_parameter_name	sqlite3ext.h	/^  const char * (*bind_parameter_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_text	sqlite3ext.h	/^  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_text16	sqlite3ext.h	/^  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_value	sqlite3ext.h	/^  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
bind_zeroblob	sqlite3ext.h	/^  int (*bind_zeroblob)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bits	test_md5.c	/^  uint32 bits[2];$/;"	m	struct:Context	file:
blobReadWrite	vdbeblob.c	/^static int blobReadWrite($/;"	f	file:
blob_bytes	sqlite3ext.h	/^  int (*blob_bytes)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_close	sqlite3ext.h	/^  int (*blob_close)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_open	sqlite3ext.h	/^  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**);$/;"	m	struct:sqlite3_api_routines
blob_read	sqlite3ext.h	/^  int (*blob_read)(sqlite3_blob*,void*,int,int);$/;"	m	struct:sqlite3_api_routines
blob_write	sqlite3ext.h	/^  int (*blob_write)(sqlite3_blob*,const void*,int,int);$/;"	m	struct:sqlite3_api_routines
bogusIncrKey	vdbeInt.h	/^  u8 bogusIncrKey;      \/* Something for pIncrKey to point to if pKeyInfo==0 *\/$/;"	m	struct:Cursor
booleanValue	shell.c	/^static int booleanValue(char *zArg){$/;"	f	file:
brk	sqliteInt.h	/^  int brk;              \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereLevel
broken_init	test_autoext.c	/^static int broken_init($/;"	f	file:
btreeCopyFile	btree.c	/^static int btreeCopyFile(Btree *pTo, Btree *pFrom){$/;"	f	file:
btreeCreateTable	btree.c	/^static int btreeCreateTable(Btree *p, int *piTable, int flags){$/;"	f	file:
btreeCursor	btree.c	/^static int btreeCursor($/;"	f	file:
btreeDropTable	btree.c	/^static int btreeDropTable(Btree *p, int iTable, int *piMoved){$/;"	f	file:
btreeIntegrity	btreeInt.h	594;"	d
btreeMask	vdbeInt.h	/^  int btreeMask;          \/* Bitmask of db->aDb[] entries referenced *\/$/;"	m	struct:Vdbe
btreeNext	btree.c	/^static int btreeNext(BtCursor *pCur, int *pRes){$/;"	f	file:
btreePageDump	test_btree.c	/^static int btreePageDump($/;"	f	file:
btreePrevious	btree.c	/^static int btreePrevious(BtCursor *pCur, int *pRes){$/;"	f	file:
btree_begin_statement	test3.c	/^static int btree_begin_statement($/;"	f	file:
btree_begin_transaction	test3.c	/^static int btree_begin_transaction($/;"	f	file:
btree_breakpoint	test3.c	/^static int btree_breakpoint($/;"	f	file:
btree_clear_table	test3.c	/^static int btree_clear_table($/;"	f	file:
btree_close	test3.c	/^static int btree_close($/;"	f	file:
btree_close_cursor	test3.c	/^static int btree_close_cursor($/;"	f	file:
btree_commit	test3.c	/^static int btree_commit($/;"	f	file:
btree_commit_statement	test3.c	/^static int btree_commit_statement($/;"	f	file:
btree_create_table	test3.c	/^static int btree_create_table($/;"	f	file:
btree_cursor	test3.c	/^static int btree_cursor($/;"	f	file:
btree_cursor_info	test3.c	/^static int btree_cursor_info($/;"	f	file:
btree_cursor_list	test3.c	/^static int btree_cursor_list($/;"	f	file:
btree_data	test3.c	/^static int btree_data($/;"	f	file:
btree_delete	test3.c	/^static int btree_delete($/;"	f	file:
btree_drop_table	test3.c	/^static int btree_drop_table($/;"	f	file:
btree_eof	test3.c	/^static int btree_eof($/;"	f	file:
btree_fetch_data	test3.c	/^static int btree_fetch_data($/;"	f	file:
btree_fetch_key	test3.c	/^static int btree_fetch_key($/;"	f	file:
btree_first	test3.c	/^static int btree_first($/;"	f	file:
btree_from_db	test3.c	/^static int btree_from_db($/;"	f	file:
btree_get_meta	test3.c	/^static int btree_get_meta($/;"	f	file:
btree_insert	test3.c	/^static int btree_insert($/;"	f	file:
btree_integrity_check	test3.c	/^static int btree_integrity_check($/;"	f	file:
btree_key	test3.c	/^static int btree_key($/;"	f	file:
btree_keysize	test3.c	/^static int btree_keysize($/;"	f	file:
btree_last	test3.c	/^static int btree_last($/;"	f	file:
btree_move_to	test3.c	/^static int btree_move_to($/;"	f	file:
btree_next	test3.c	/^static int btree_next($/;"	f	file:
btree_open	test3.c	/^static int btree_open($/;"	f	file:
btree_ovfl_info	test3.c	/^static int btree_ovfl_info($/;"	f	file:
btree_page_dump	test3.c	/^static int btree_page_dump($/;"	f	file:
btree_pager_ref_dump	test3.c	/^static int btree_pager_ref_dump($/;"	f	file:
btree_pager_stats	test3.c	/^static int btree_pager_stats($/;"	f	file:
btree_payload_size	test3.c	/^static int btree_payload_size($/;"	f	file:
btree_prev	test3.c	/^static int btree_prev($/;"	f	file:
btree_rollback	test3.c	/^static int btree_rollback($/;"	f	file:
btree_rollback_statement	test3.c	/^static int btree_rollback_statement($/;"	f	file:
btree_set_cache_size	test3.c	/^static int btree_set_cache_size($/;"	f	file:
btree_tree_dump	test3.c	/^static int btree_tree_dump($/;"	f	file:
btree_update_meta	test3.c	/^static int btree_update_meta($/;"	f	file:
btree_varint_test	test3.c	/^static int btree_varint_test($/;"	f	file:
buf	test_md5.c	/^  uint32 buf[4];$/;"	m	struct:Context	file:
buildIndexProbe	where.c	/^static void buildIndexProbe($/;"	f	file:
busy	sqliteInt.h	/^    u8 busy;                    \/* TRUE if currently initializing *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
busy	test4.c	/^  int busy;              \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busy	test7.c	/^  volatile int busy;       \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busyHandler	sqliteInt.h	/^  BusyHandler busyHandler;      \/* Busy callback *\/$/;"	m	struct:sqlite3
busyHdr	btreeInt.h	/^  BusyHandler busyHdr;  \/* The busy handler for this btree *\/$/;"	m	struct:BtShared
busyTimeout	sqliteInt.h	/^  int busyTimeout;              \/* Busy handler timeout, in msec *\/$/;"	m	struct:sqlite3
busy_handler	sqlite3ext.h	/^  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);$/;"	m	struct:sqlite3_api_routines
busy_timeout	sqlite3ext.h	/^  int  (*busy_timeout)(sqlite3*,int ms);$/;"	m	struct:sqlite3_api_routines
byteReverse	test_md5.c	/^static void byteReverse (unsigned char *buf, unsigned longs){$/;"	f	file:
c_collation_test	test9.c	/^static int c_collation_test($/;"	f	file:
c_misuse_test	test9.c	/^static int c_misuse_test($/;"	f	file:
c_realloc_test	test9.c	/^static int c_realloc_test($/;"	f	file:
cacheCtr	vdbeInt.h	/^  int cacheCtr;           \/* Cursor row cache generation counter *\/$/;"	m	struct:Vdbe
cacheStatus	vdbeInt.h	/^  int cacheStatus;      \/* Cache is valid if this matches Vdbe.cacheCtr *\/$/;"	m	struct:Cursor
cache_size	sqliteInt.h	/^  int cache_size;      \/* Number of pages to use in the cache *\/$/;"	m	struct:Schema
callCollNeeded	callback.c	/^static void callCollNeeded(sqlite3 *db, const char *zName, int nName){$/;"	f	file:
callFinaliser	vtab.c	/^static void callFinaliser(sqlite3 *db, int offset){$/;"	f	file:
callback	shell.c	/^static int callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
callback_data	shell.c	/^struct callback_data {$/;"	s	file:
carg	parse.y	/^carg ::= CONSTRAINT nm ccons.$/;"	l
carg	parse.y	/^carg ::= ccons.$/;"	l
carglist	parse.y	/^carglist ::= .$/;"	l
carglist	parse.y	/^carglist ::= carglist carg.$/;"	l
ccons	parse.y	/^ccons ::= CHECK LP expr(X) RP.       {sqlite3AddCheckConstraint(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= COLLATE ids(C).  {sqlite3AddCollateType(pParse, &C);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT LP expr(X) RP.      {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT MINUS term(X).      {$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT PLUS term(X).       {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT id(X).              {$/;"	l
ccons	parse.y	/^ccons ::= DEFAULT term(X).            {sqlite3AddDefaultValue(pParse,X);}$/;"	l
ccons	parse.y	/^ccons ::= NOT NULL onconf(R).               {sqlite3AddNotNull(pParse, R);}$/;"	l
ccons	parse.y	/^ccons ::= NULL onconf.$/;"	l
ccons	parse.y	/^ccons ::= PRIMARY KEY sortorder(Z) onconf(R) autoinc(I).$/;"	l
ccons	parse.y	/^ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).$/;"	l
ccons	parse.y	/^ccons ::= UNIQUE onconf(R).    {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0,0,0);}$/;"	l
ccons	parse.y	/^ccons ::= defer_subclause(D).   {sqlite3DeferForeignKey(pParse,D);}$/;"	l
cdateFunc	date.c	/^static void cdateFunc($/;"	f	file:
cellOffset	btreeInt.h	/^  u16 cellOffset;      \/* Index in aData of first cell pointer *\/$/;"	m	struct:MemPage
cellSize	btree.c	/^static int cellSize(MemPage *pPage, int iCell){$/;"	f	file:
cellSizePtr	btree.c	/^static int cellSizePtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
cfAccess	test6.c	/^static int cfAccess(sqlite3_vfs *pCfVfs, const char *zPath, int flags){$/;"	f	file:
cfCheckReservedLock	test6.c	/^static int cfCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
cfClose	test6.c	/^static int cfClose(sqlite3_file *pFile){$/;"	f	file:
cfCurrentTime	test6.c	/^static int cfCurrentTime(sqlite3_vfs *pCfVfs, double *pTimeOut){$/;"	f	file:
cfDelete	test6.c	/^static int cfDelete(sqlite3_vfs *pCfVfs, const char *zPath, int dirSync){$/;"	f	file:
cfDeviceCharacteristics	test6.c	/^static int cfDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
cfDlClose	test6.c	/^static void cfDlClose(sqlite3_vfs *pCfVfs, void *pHandle){$/;"	f	file:
cfDlError	test6.c	/^static void cfDlError(sqlite3_vfs *pCfVfs, int nByte, char *zErrMsg){$/;"	f	file:
cfDlOpen	test6.c	/^static void *cfDlOpen(sqlite3_vfs *pCfVfs, const char *zPath){$/;"	f	file:
cfDlSym	test6.c	/^static void *cfDlSym(sqlite3_vfs *pCfVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
cfFileControl	test6.c	/^static int cfFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
cfFileSize	test6.c	/^static int cfFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
cfFullPathname	test6.c	/^static int cfFullPathname($/;"	f	file:
cfGetTempname	test6.c	/^static int cfGetTempname(sqlite3_vfs *pCfVfs, int nBufOut, char *zBufOut){$/;"	f	file:
cfLock	test6.c	/^static int cfLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfOpen	test6.c	/^static int cfOpen($/;"	f	file:
cfRandomness	test6.c	/^static int cfRandomness(sqlite3_vfs *pCfVfs, int nByte, char *zBufOut){$/;"	f	file:
cfRead	test6.c	/^static int cfRead($/;"	f	file:
cfSectorSize	test6.c	/^static int cfSectorSize(sqlite3_file *pFile){$/;"	f	file:
cfSleep	test6.c	/^static int cfSleep(sqlite3_vfs *pCfVfs, int nMicro){$/;"	f	file:
cfSync	test6.c	/^static int cfSync(sqlite3_file *pFile, int flags){$/;"	f	file:
cfTruncate	test6.c	/^static int cfTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
cfUnlock	test6.c	/^static int cfUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfWrite	test6.c	/^static int cfWrite($/;"	f	file:
chain	hash.h	/^    HashElem *chain;         \/* Pointer to first entry with this hash *\/$/;"	m	struct:Hash::_ht
changeCntOn	vdbeInt.h	/^  u8 changeCntOn;         \/* True to update the change-counter *\/$/;"	m	struct:Vdbe
changeCountDone	pager.c	/^  u8 changeCountDone;         \/* Set after incrementing the change-counter *\/$/;"	m	struct:Pager	file:
changeTempStorage	pragma.c	/^static int changeTempStorage(Parse *pParse, const char *zStorageType){$/;"	f	file:
changes	func.c	/^static void changes($/;"	f	file:
changes	sqlite3ext.h	/^  int  (*changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
channel	tclsqlite.c	/^  Tcl_Channel channel;      \/* Channel identifier *\/$/;"	m	struct:IncrblobChannel	file:
charMap	tokenize.c	32;"	d	file:
charMap	tokenize.c	35;"	d	file:
charset	printf.c	/^  etByte charset;          \/* Offset into aDigits[] of the digits string *\/$/;"	m	struct:et_info	file:
checkActiveVdbeCnt	vdbeaux.c	/^static void checkActiveVdbeCnt(sqlite3 *db){$/;"	f	file:
checkActiveVdbeCnt	vdbeaux.c	1363;"	d	file:
checkAppendMsg	btree.c	/^static void checkAppendMsg($/;"	f	file:
checkColumnOverLap	trigger.c	/^static int checkColumnOverLap(IdList *pIdList, ExprList *pEList){$/;"	f	file:
checkForMultiColumnSelectError	select.c	/^static int checkForMultiColumnSelectError($/;"	f	file:
checkList	btree.c	/^static void checkList($/;"	f	file:
checkPage	pager.c	/^static void checkPage(PgHdr *pPg){$/;"	f	file:
checkPtrmap	btree.c	/^static void checkPtrmap($/;"	f	file:
checkReadLocks	btree.c	/^static int checkReadLocks(Btree *pBtree, Pgno pgnoRoot, BtCursor *pExclude){$/;"	f	file:
checkRef	btree.c	/^static int checkRef(IntegrityCk *pCheck, int iPage, char *zContext){$/;"	f	file:
checkSchema	sqliteInt.h	/^  u8 checkSchema;      \/* Causes schema cookie check after an error *\/$/;"	m	struct:Parse
checkTreePage	btree.c	/^static int checkTreePage($/;"	f	file:
childPtrSize	btreeInt.h	/^  u8 childPtrSize;     \/* 0 if leaf==1.  4 if leaf==0 *\/$/;"	m	struct:MemPage
ckBase	sqliteInt.h	/^  int ckBase;          \/* Base register of data during check constraints *\/$/;"	m	struct:Parse
cksumInit	pager.c	/^  u32 cksumInit;              \/* Quasi-random value added to every checksum *\/$/;"	m	struct:Pager	file:
clearCell	btree.c	/^static int clearCell(MemPage *pPage, unsigned char *pCell){$/;"	f	file:
clearCursorPosition	btree.c	/^static void clearCursorPosition(BtCursor *pCur){$/;"	f	file:
clearDatabasePage	btree.c	/^static int clearDatabasePage($/;"	f	file:
clearHistory	pager.c	/^static void clearHistory(PgHistory *pHist){$/;"	f	file:
clearHistory	pager.c	2481;"	d	file:
clearSelect	select.c	/^static void clearSelect(Select *p){$/;"	f	file:
clearYMD_HMS_TZ	date.c	/^static void clearYMD_HMS_TZ(DateTime *p){$/;"	f	file:
clear_bindings	sqlite3ext.h	/^  int (*clear_bindings)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
clientMutex	test_server.c	/^  pthread_mutex_t clientMutex; \/* Hold this mutex to access the message *\/$/;"	m	struct:SqlMessage	file:
clientWakeup	test_server.c	/^  pthread_cond_t clientWakeup; \/* Signal to wake up the client *\/$/;"	m	struct:SqlMessage	file:
client_main	test7.c	/^static void *client_main(void *pArg){$/;"	f	file:
client_wait	test7.c	/^static void client_wait(Thread *p){$/;"	f	file:
close	sqlite3ext.h	/^  int  (*close)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
close	test_async.c	/^  AsyncWrite close;$/;"	m	struct:AsyncFileData	file:
closeAllCursorsExceptActiveVtabs	vdbeaux.c	/^static void closeAllCursorsExceptActiveVtabs(Vdbe *p){$/;"	f	file:
closeIncrblobChannels	tclsqlite.c	/^static void closeIncrblobChannels(SqliteDb *pDb){$/;"	f	file:
closeIncrblobChannels	tclsqlite.c	347;"	d	file:
cmd	parse.y	/^cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(Y). {$/;"	l
cmd	parse.y	/^cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {$/;"	l
cmd	parse.y	/^cmd ::= ANALYZE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}$/;"	l
cmd	parse.y	/^cmd ::= ANALYZE.                {sqlite3Analyze(pParse, 0, 0);}$/;"	l
cmd	parse.y	/^cmd ::= ATTACH database_kw_opt expr(F) AS expr(D) key_opt(K). {$/;"	l
cmd	parse.y	/^cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}$/;"	l
cmd	parse.y	/^cmd ::= COMMIT trans_opt.      {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= CREATE trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {$/;"	l
cmd	parse.y	/^cmd ::= CREATE(S) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)$/;"	l
cmd	parse.y	/^cmd ::= CREATE(X) temp(T) VIEW ifnotexists(E) nm(Y) dbnm(Z) AS select(S). {$/;"	l
cmd	parse.y	/^cmd ::= DELETE FROM fullname(X) where_opt(Y). {sqlite3DeleteFrom(pParse,X,Y);}$/;"	l
cmd	parse.y	/^cmd ::= DETACH database_kw_opt expr(D). {$/;"	l
cmd	parse.y	/^cmd ::= DROP INDEX ifexists(E) fullname(X).   {sqlite3DropIndex(pParse, X, E);}$/;"	l
cmd	parse.y	/^cmd ::= DROP TABLE ifexists(E) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP TRIGGER ifexists(NOERR) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP VIEW ifexists(E) fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= END trans_opt.         {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ ON(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). {$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ nmnum(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP nmnum(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z).             {sqlite3Pragma(pParse,&X,&Z,0,0);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}$/;"	l
cmd	parse.y	/^cmd ::= ROLLBACK trans_opt.    {sqlite3RollbackTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= UPDATE orconf(R) fullname(X) SET setlist(Y) where_opt(Z).  {$/;"	l
cmd	parse.y	/^cmd ::= VACUUM nm.             {sqlite3Vacuum(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= VACUUM.                {sqlite3Vacuum(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= create_table create_table_args.$/;"	l
cmd	parse.y	/^cmd ::= create_vtab LP vtabarglist RP(X).  {sqlite3VtabFinishParse(pParse,&X);}$/;"	l
cmd	parse.y	/^cmd ::= create_vtab.                       {sqlite3VtabFinishParse(pParse,0);}$/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) $/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) DEFAULT VALUES.$/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) select(S).$/;"	l
cmd	parse.y	/^cmd ::= select(X).  {$/;"	l
cmdlist	parse.y	/^cmdlist ::= cmdlist ecmd.$/;"	l
cmdlist	parse.y	/^cmdlist ::= ecmd.$/;"	l
cmdx	parse.y	/^cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }$/;"	l
cnt	func.c	/^  i64 cnt;          \/* Number of elements summed *\/$/;"	m	struct:SumCtx	file:
cnt	mutex.c	/^  int cnt;    \/* Number of entries without a matching leave *\/$/;"	m	struct:sqlite3_mutex	file:
cnt	os_unix.c	/^  int cnt;             \/* Number of SHARED locks held *\/$/;"	m	struct:lockInfo	file:
cnt	shell.c	/^  int cnt;               \/* Number of records displayed so far *\/$/;"	m	struct:callback_data	file:
cnt	vdbe.h	/^  int cnt;            \/* Number of times this instruction was executed *\/$/;"	m	struct:VdbeOp
codeAllEqualityTerms	where.c	/^static int codeAllEqualityTerms($/;"	f	file:
codeAttach	attach.c	/^static void codeAttach($/;"	f	file:
codeCompare	expr.c	/^static int codeCompare($/;"	f	file:
codeDistinct	select.c	/^static void codeDistinct($/;"	f	file:
codeEqualityTerm	where.c	/^static void codeEqualityTerm($/;"	f	file:
codeInteger	expr.c	/^static void codeInteger(Vdbe *v, const char *z, int n, int negFlag, int iMem){$/;"	f	file:
codeOffset	select.c	/^static void codeOffset($/;"	f	file:
codeReal	expr.c	/^static void codeReal(Vdbe *v, const char *z, int n, int negateFlag, int iMem){$/;"	f	file:
codeTableLocks	build.c	/^static void codeTableLocks(Parse *pParse){$/;"	f	file:
codeTableLocks	build.c	121;"	d	file:
codeTriggerProgram	trigger.c	/^static int codeTriggerProgram($/;"	f	file:
colNamesSet	sqliteInt.h	/^  u8 colNamesSet;      \/* TRUE after OP_ColumnName has been issued to pVdbe *\/$/;"	m	struct:Parse
colUsed	sqliteInt.h	/^    Bitmask colUsed;  \/* Bit N (1<<N) set if column N or pTab is used *\/$/;"	m	struct:SrcList::SrcList_item
colWidth	shell.c	/^  int colWidth[100];     \/* Requested width of each column when in column mode*\/$/;"	m	struct:callback_data	file:
colWidth	shell.c	/^  int colWidth[100];$/;"	m	struct:previous_mode_data	file:
collationMatch	build.c	/^static int collationMatch(const char *zColl, Index *pIndex){$/;"	f	file:
collation_needed	sqlite3ext.h	/^  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const char*));$/;"	m	struct:sqlite3_api_routines
collation_needed16	sqlite3ext.h	/^  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const void*));$/;"	m	struct:sqlite3_api_routines
columnIndex	select.c	/^static int columnIndex(Table *pTab, const char *zCol){$/;"	f	file:
columnMallocFailure	vdbeapi.c	/^static void columnMallocFailure(sqlite3_stmt *pStmt)$/;"	f	file:
columnMem	vdbeapi.c	/^static Mem *columnMem(sqlite3_stmt *pStmt, int i){$/;"	f	file:
columnName	vdbeapi.c	/^static const void *columnName($/;"	f	file:
columnType	select.c	/^static const char *columnType($/;"	f	file:
column_blob	sqlite3ext.h	/^  const void * (*column_blob)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes	sqlite3ext.h	/^  int  (*column_bytes)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes16	sqlite3ext.h	/^  int  (*column_bytes16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_count	sqlite3ext.h	/^  int  (*column_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
column_database_name	sqlite3ext.h	/^  const char * (*column_database_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_database_name16	sqlite3ext.h	/^  const void * (*column_database_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_decltype	sqlite3ext.h	/^  const char * (*column_decltype)(sqlite3_stmt*,int i);$/;"	m	struct:sqlite3_api_routines
column_decltype16	sqlite3ext.h	/^  const void * (*column_decltype16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_double	sqlite3ext.h	/^  double  (*column_double)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int	sqlite3ext.h	/^  int  (*column_int)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int64	sqlite3ext.h	/^  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_name	sqlite3ext.h	/^  const char * (*column_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_name16	sqlite3ext.h	/^  const void * (*column_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name	sqlite3ext.h	/^  const char * (*column_origin_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name16	sqlite3ext.h	/^  const void * (*column_origin_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name	sqlite3ext.h	/^  const char * (*column_table_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name16	sqlite3ext.h	/^  const void * (*column_table_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_text	sqlite3ext.h	/^  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_text16	sqlite3ext.h	/^  const void * (*column_text16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_type	sqlite3ext.h	/^  int  (*column_type)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_value	sqlite3ext.h	/^  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
columnlist	parse.y	/^columnlist ::= column.$/;"	l
columnlist	parse.y	/^columnlist ::= columnlist COMMA column.$/;"	l
colv	test4.c	/^  const char *colv[100];    \/* result column names *\/$/;"	m	struct:Thread	file:
colv	test7.c	/^  const char *colv[100];   \/* result column names *\/$/;"	m	struct:Thread	file:
commit_hook	sqlite3ext.h	/^  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
compare2pow63	util.c	/^static int compare2pow63(const char *zNum){$/;"	f	file:
compareFunction	hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareInfo	func.c	/^struct compareInfo {$/;"	s	file:
comparisonAffinity	expr.c	/^static char comparisonAffinity(Expr *pExpr){$/;"	f	file:
complete	sqlite3ext.h	/^  int  (*complete)(const char*sql);$/;"	m	struct:sqlite3_api_routines
complete16	sqlite3ext.h	/^  int  (*complete16)(const void*sql);$/;"	m	struct:sqlite3_api_routines
completed	test4.c	/^  int completed;        \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
completed	test7.c	/^  volatile int completed;  \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
computeColumnNames	tclsqlite.c	/^computeColumnNames($/;"	f	file:
computeHMS	date.c	/^static void computeHMS(DateTime *p){$/;"	f	file:
computeJD	date.c	/^static void computeJD(DateTime *p){$/;"	f	file:
computeLimitRegisters	select.c	/^static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){$/;"	f	file:
computeYMD	date.c	/^static void computeYMD(DateTime *p){$/;"	f	file:
computeYMD_HMS	date.c	/^static void computeYMD_HMS(DateTime *p){$/;"	f	file:
conslist	parse.y	/^conslist ::= conslist COMMA tcons.$/;"	l
conslist	parse.y	/^conslist ::= conslist tcons.$/;"	l
conslist	parse.y	/^conslist ::= tcons.$/;"	l
cont	sqliteInt.h	/^  int cont;             \/* Jump here to continue with the next loop cycle *\/$/;"	m	struct:WhereLevel
contextMalloc	func.c	/^static void *contextMalloc(sqlite3_context *context, int nByte){$/;"	f	file:
contextStack	vdbeInt.h	/^  Context *contextStack;  \/* Stack used by opcodes ContextPush & ContextPop*\/$/;"	m	struct:Vdbe
contextStackDepth	vdbeInt.h	/^  int contextStackDepth;  \/* The size of the "context" stack *\/$/;"	m	struct:Vdbe
contextStackTop	vdbeInt.h	/^  int contextStackTop;    \/* Index of top element in the context stack *\/$/;"	m	struct:Vdbe
continuePrompt	shell.c	/^static char continuePrompt[20]; \/* Continuation prompt. default: "   ...> " *\/$/;"	v	file:
convertUtf8Filename	os_win.c	/^static void *convertUtf8Filename(const char *zFilename){$/;"	f	file:
cookieGoto	sqliteInt.h	/^  int cookieGoto;      \/* Address of OP_Goto to cookie verifier subroutine *\/$/;"	m	struct:Parse
cookieMask	sqliteInt.h	/^  u32 cookieMask;      \/* Bitmask of schema verified databases *\/$/;"	m	struct:Parse
cookieValue	sqliteInt.h	/^  int cookieValue[SQLITE_MAX_ATTACHED+2];  \/* Values of cookies to verify *\/$/;"	m	struct:Parse
copyKey	hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:Hash
copyPayload	btree.c	/^static int copyPayload($/;"	f	file:
corruptSchema	prepare.c	/^static void corruptSchema(InitData *pData, const char *zExtra){$/;"	f	file:
count	hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:Hash::_ht
count	hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:Hash
countFinalize	func.c	/^static void countFinalize(sqlite3_context *context){$/;"	f	file:
countStep	func.c	/^static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
countWriteCursors	btree.c	/^static int countWriteCursors(BtShared *pBt){$/;"	f	file:
crashAppData	test6.c	/^struct crashAppData {$/;"	s	file:
crashEnableCmd	test6.c	/^static int crashEnableCmd($/;"	f	file:
crashParamsObjCmd	test6.c	/^static int crashParamsObjCmd($/;"	f	file:
crash_free	test6.c	/^static void crash_free(void *p){$/;"	f	file:
crash_malloc	test6.c	/^static void *crash_malloc(int nByte){$/;"	f	file:
crash_realloc	test6.c	/^static void *crash_realloc(void *p, int n){$/;"	f	file:
createCollation	main.c	/^static int createCollation($/;"	f	file:
createFile	journal.c	/^static int createFile(JournalFile *p){$/;"	f	file:
createIncrblobChannel	tclsqlite.c	/^static int createIncrblobChannel($/;"	f	file:
createMask	where.c	/^static void createMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
createModule	vtab.c	/^static int createModule($/;"	f	file:
createSortingIndex	select.c	/^static void createSortingIndex(Parse *pParse, Select *p, ExprList *pOrderBy){$/;"	f	file:
createTableStmt	build.c	/^static char *createTableStmt(sqlite3 *db, Table *p, int isTemp){$/;"	f	file:
createVarMap	vdbeapi.c	/^static void createVarMap(Vdbe *p){$/;"	f	file:
create_collation	sqlite3ext.h	/^  int  (*create_collation)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));$/;"	m	struct:sqlite3_api_routines
create_collation16	sqlite3ext.h	/^  int  (*create_collation16)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));$/;"	m	struct:sqlite3_api_routines
create_collation_v2	sqlite3ext.h	/^  int (*create_collation_v2)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*),void(*)(void*));$/;"	m	struct:sqlite3_api_routines
create_function	sqlite3ext.h	/^  int  (*create_function)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));$/;"	m	struct:sqlite3_api_routines
create_function16	sqlite3ext.h	/^  int  (*create_function16)(sqlite3*,const void*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));$/;"	m	struct:sqlite3_api_routines
create_module	sqlite3ext.h	/^  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);$/;"	m	struct:sqlite3_api_routines
create_module_v2	sqlite3ext.h	/^  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy)(void *));$/;"	m	struct:sqlite3_api_routines
create_table	parse.y	/^create_table ::= CREATE temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= AS select(S). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= LP columnlist conslist_opt(X) RP(Y). {$/;"	l
create_vtab	parse.y	/^create_vtab ::= CREATE VIRTUAL TABLE nm(X) dbnm(Y) USING nm(Z). {$/;"	l
ctimeFunc	date.c	/^static void ctimeFunc($/;"	f	file:
ctimestampFunc	date.c	/^static void ctimestampFunc($/;"	f	file:
cubeFunc	test_autoext.c	/^static void cubeFunc($/;"	f	file:
cube_init	test_autoext.c	/^static int cube_init($/;"	f	file:
currentTimeFunc	date.c	/^static void currentTimeFunc($/;"	f	file:
cursorHoldsMutex	btree.c	/^static int cursorHoldsMutex(BtCursor *p){$/;"	f	file:
cycles	vdbe.h	/^  long long cycles;   \/* Total time spend executing this instruction *\/$/;"	m	struct:VdbeOp
data	hash.h	/^  void *data;              \/* Data associated with this element *\/$/;"	m	struct:HashElem
data_count	sqlite3ext.h	/^  int  (*data_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
database_kw_opt	parse.y	/^database_kw_opt ::= .$/;"	l
database_kw_opt	parse.y	/^database_kw_opt ::= DATABASE.$/;"	l
dateFunc	date.c	/^static void dateFunc($/;"	f	file:
datetimeFunc	date.c	/^static void datetimeFunc($/;"	f	file:
db	analyze.c	/^  sqlite3 *db;$/;"	m	struct:analysisInfo	file:
db	btreeInt.h	/^  sqlite3 *db;          \/* Database connection currently using this Btree *\/$/;"	m	struct:BtShared
db	btreeInt.h	/^  sqlite3 *db;       \/* The database connection holding this btree *\/$/;"	m	struct:Btree
db	shell.c	/^  sqlite3 *db;            \/* The database *\/$/;"	m	struct:callback_data	file:
db	shell.c	/^static sqlite3 *db = 0;$/;"	v	file:
db	sqliteInt.h	/^  sqlite3 *db;         \/* "Owner" connection. See comment above *\/$/;"	m	struct:Schema
db	sqliteInt.h	/^  sqlite3 *db;         \/* The main database structure *\/$/;"	m	struct:Parse
db	sqliteInt.h	/^  sqlite3 *db;        \/* The database being initialized *\/$/;"	m	struct:__anon3
db	sqliteInt.h	/^  sqlite3 *db;        \/* The database connection *\/$/;"	m	struct:KeyInfo
db	tclsqlite.c	/^  sqlite3 *db;               \/* The "real" database structure. MUST BE FIRST *\/$/;"	m	struct:SqliteDb	file:
db	test1.c	/^  sqlite3 *db;$/;"	m	struct:SqliteDb	file:
db	test4.c	/^  sqlite3 *db;           \/* Open database *\/$/;"	m	struct:Thread	file:
db	test7.c	/^  sqlite3 *db;             \/* Open database *\/$/;"	m	struct:Thread	file:
db	test8.c	/^  sqlite3 *db;            \/* Database connection *\/$/;"	m	struct:echo_vtab	file:
db	test_schema.c	/^  sqlite3 *db;$/;"	m	struct:schema_vtab	file:
db	vdbeInt.h	/^  sqlite3 *db;        \/* The associated database connection *\/$/;"	m	struct:Mem
db	vdbeInt.h	/^  sqlite3 *db;        \/* The whole database *\/$/;"	m	struct:Vdbe
db	vdbeblob.c	/^  sqlite3 *db;            \/* The associated database *\/$/;"	m	struct:Incrblob	file:
dbFileVers	pager.c	/^  char dbFileVers[16];        \/* Changes whenever database file changes *\/$/;"	m	struct:Pager	file:
dbSize	pager.c	/^  int dbSize;                 \/* Number of pages in the file *\/$/;"	m	struct:Pager	file:
dbTextToObj	tclsqlite.c	/^static Tcl_Obj *dbTextToObj(char const *zText){$/;"	f	file:
db_enter	test1.c	/^static int db_enter($/;"	f	file:
db_handle	sqlite3ext.h	/^  sqlite3 * (*db_handle)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
db_leave	test1.c	/^static int db_leave($/;"	f	file:
declareVtab	sqliteInt.h	/^  u8 declareVtab;            \/* True if inside sqlite3_declare_vtab() *\/$/;"	m	struct:Parse
declare_vtab	sqlite3ext.h	/^  int (*declare_vtab)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
declare_vtab	test8.c	/^static int declare_vtab($/;"	f	file:
decodeFlags	btree.c	/^static void decodeFlags(MemPage *pPage, int flagByte){$/;"	f	file:
deferredMoveto	vdbeInt.h	/^  Bool deferredMoveto;  \/* A call to sqlite3BtreeMoveto() is needed *\/$/;"	m	struct:Cursor
defragmentPage	btree.c	/^static int defragmentPage(MemPage *pPage){$/;"	f	file:
delOnClose	os_os2.c	/^  int delOnClose;           \/* True if file is to be deleted on close *\/$/;"	m	struct:os2File	file:
deleteConf	sqliteInt.h	/^  u8 deleteConf;    \/* How to resolve conflicts that occur on DELETE *\/$/;"	m	struct:FKey
delete_collation	test1.c	/^static int delete_collation($/;"	f	file:
delete_function	test1.c	/^static int delete_function($/;"	f	file:
dequoteString	test8.c	/^static void dequoteString(char *z){$/;"	f	file:
destroyRootPage	build.c	/^static void destroyRootPage(Parse *pParse, int iTable, int iDb){$/;"	f	file:
destroyTable	build.c	/^static void destroyTable(Parse *pParse, Table *pTab){$/;"	f	file:
destructor	func.c	/^static void destructor(void *p){$/;"	f	file:
detachFunc	attach.c	/^static void detachFunc($/;"	f	file:
dev	os_unix.c	/^  dev_t dev;       \/* Device number *\/$/;"	m	struct:lockKey	file:
dev	os_unix.c	/^  dev_t dev;   \/* Device number *\/$/;"	m	struct:openKey	file:
devSymObjCmd	test6.c	/^static int devSymObjCmd($/;"	f	file:
devsymAccess	test_devsym.c	/^static int devsymAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
devsymCheckReservedLock	test_devsym.c	/^static int devsymCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
devsymClose	test_devsym.c	/^static int devsymClose(sqlite3_file *pFile){$/;"	f	file:
devsymCurrentTime	test_devsym.c	/^static int devsymCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
devsymDelete	test_devsym.c	/^static int devsymDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
devsymDeviceCharacteristics	test_devsym.c	/^static int devsymDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
devsymDlClose	test_devsym.c	/^static void devsymDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
devsymDlError	test_devsym.c	/^static void devsymDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
devsymDlOpen	test_devsym.c	/^static void *devsymDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
devsymDlSym	test_devsym.c	/^static void *devsymDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
devsymFileControl	test_devsym.c	/^static int devsymFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
devsymFileSize	test_devsym.c	/^static int devsymFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
devsymFullPathname	test_devsym.c	/^static int devsymFullPathname($/;"	f	file:
devsymGetTempName	test_devsym.c	/^static int devsymGetTempName(sqlite3_vfs *pVfs, int nOut, char *zBufOut){$/;"	f	file:
devsymLock	test_devsym.c	/^static int devsymLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymOpen	test_devsym.c	/^static int devsymOpen($/;"	f	file:
devsymRandomness	test_devsym.c	/^static int devsymRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
devsymRead	test_devsym.c	/^static int devsymRead($/;"	f	file:
devsymSectorSize	test_devsym.c	/^static int devsymSectorSize(sqlite3_file *pFile){$/;"	f	file:
devsymSleep	test_devsym.c	/^static int devsymSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
devsymSync	test_devsym.c	/^static int devsymSync(sqlite3_file *pFile, int flags){$/;"	f	file:
devsymTruncate	test_devsym.c	/^static int devsymTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
devsymUnlock	test_devsym.c	/^static int devsymUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymWrite	test_devsym.c	/^static int devsymWrite($/;"	f	file:
devsym_file	test_devsym.c	/^struct devsym_file {$/;"	s	file:
devsym_file	test_devsym.c	/^typedef struct devsym_file devsym_file;$/;"	t	typeref:struct:devsym_file	file:
devsym_io_methods	test_devsym.c	/^static sqlite3_io_methods devsym_io_methods = {$/;"	v	file:
devsym_register	test_devsym.c	/^void devsym_register(int iDeviceChar, int iSectorSize){$/;"	f
devsym_vfs	test_devsym.c	/^static sqlite3_vfs devsym_vfs = {$/;"	v	file:
dfltCompare	btree.c	/^static int dfltCompare($/;"	f	file:
dfltLockMode	sqliteInt.h	/^  u8 dfltLockMode;              \/* Default locking-mode for attached dbs *\/$/;"	m	struct:sqlite3
directMode	sqliteInt.h	/^  u8 directMode;          \/* Direct rendering mode means take data directly$/;"	m	struct:AggInfo
dirfd	os_unix.c	/^  int dirfd;                \/* File descriptor for the directory *\/$/;"	m	struct:unixFile	file:
dirty	pager.c	/^  u8 dirty;                      \/* TRUE if we need to write back changes *\/$/;"	m	struct:PgHdr	file:
dirtyCache	pager.c	/^  u8 dirtyCache;              \/* True if cached pages have changed *\/$/;"	m	struct:Pager	file:
disableTerm	where.c	/^static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){$/;"	f	file:
disable_simulated_io_errors	pager.c	/^void disable_simulated_io_errors(void){$/;"	f
disable_simulated_io_errors	pager.c	2396;"	d	file:
disable_simulated_io_errors	pager.h	122;"	d
disallow	mem2.c	/^  int disallow; \/* Do not allow memory allocation *\/$/;"	m	struct:__anon5	file:
disallowOrderBy	sqliteInt.h	/^  u8 disallowOrderBy;    \/* Do not allow an ORDER BY to be attached if TRUE *\/$/;"	m	struct:Select
displayP4	vdbeaux.c	/^static char *displayP4(Op *pOp, char *zTemp, int nTemp){$/;"	f	file:
doNotSync	pager.c	/^  u8 doNotSync;               \/* Boolean. While true, do not spill the cache *\/$/;"	m	struct:Pager	file:
do_compile	test4.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_compile	test7.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_finalize	test4.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_finalize	test7.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_meta_command	shell.c	/^static int do_meta_command(char *zLine, struct callback_data *p){$/;"	f	file:
do_reset	test7.c	/^static void do_reset(Thread *p){$/;"	f	file:
do_step	test4.c	/^static void do_step(Thread *p){$/;"	f	file:
do_step	test7.c	/^static void do_step(Thread *p){$/;"	f	file:
done	sqliteInt.h	/^    u8 done;               \/* A flag to indicate when processing is finished *\/$/;"	m	struct:ExprList::ExprList_item
dotlockLockingContext	os_unix.c	/^struct dotlockLockingContext {$/;"	s	file:
dotlockLockingContext	os_unix.c	/^typedef struct dotlockLockingContext dotlockLockingContext;$/;"	t	typeref:struct:dotlockLockingContext	file:
dotlockLockingStyle	os_unix.c	/^        dotlockLockingStyle,         \/* use <file>.lock files *\/$/;"	e	enum:__anon4	file:
dotlockUnixCheckReservedLock	os_unix.c	/^static int dotlockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
dotlockUnixClose	os_unix.c	/^static int dotlockUnixClose(sqlite3_file *id) {$/;"	f	file:
dotlockUnixLock	os_unix.c	/^static int dotlockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
dotlockUnixUnlock	os_unix.c	/^static int dotlockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
double	sqliteInt.h	168;"	d
doubleToInt64	vdbemem.c	/^static i64 doubleToInt64(double r){$/;"	f	file:
dropCell	btree.c	/^static void dropCell(MemPage *pPage, int idx, int sz){$/;"	f	file:
dstr	test1.c	/^struct dstr {$/;"	s	file:
dstrAppend	test1.c	/^static void dstrAppend(struct dstr *p, const char *z, int divider){$/;"	f	file:
dump_callback	shell.c	/^static int dump_callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
dup8bytes	expr.c	/^static char *dup8bytes(Vdbe *v, const char *in){$/;"	f	file:
dyn	sqliteInt.h	/^  unsigned dyn  : 1;      \/* True for malloced memory, false for static *\/$/;"	m	struct:Token
eAsyncLock	test_async.c	/^  int eAsyncLock;           \/* Lock-state with write-queue unlock *\/$/;"	m	struct:AsyncFileLock	file:
eDest	sqliteInt.h	/^  u8 eDest;         \/* How to dispose of the results *\/$/;"	m	struct:SelectDest
eLock	btreeInt.h	/^  u8 eLock;             \/* READ_LOCK or WRITE_LOCK *\/$/;"	m	struct:BtLock
eLock	test_async.c	/^  int eLock;                \/* Internally visible lock state (sqlite pov) *\/$/;"	m	struct:AsyncFileLock	file:
eLock	test_async.c	/^  int eLock;$/;"	m	struct:AsyncLock	file:
eOperator	where.c	/^  u16 eOperator;          \/* A WO_xx value describing <op> *\/$/;"	m	struct:WhereTerm	file:
eState	btreeInt.h	/^  u8 eState;                \/* One of the CURSOR_XXX constants (see below) *\/$/;"	m	struct:BtCursor
eType	test_onefile.c	/^  int eType;$/;"	m	struct:fs_file	file:
ebcdicToAscii	tokenize.c	/^const unsigned char ebcdicToAscii[] = {$/;"	v
echoBegin	test8.c	/^static int echoBegin(sqlite3_vtab *tab){$/;"	f	file:
echoBestIndex	test8.c	/^static int echoBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
echoClose	test8.c	/^static int echoClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoColumn	test8.c	/^static int echoColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
echoCommit	test8.c	/^static int echoCommit(sqlite3_vtab *tab){$/;"	f	file:
echoConnect	test8.c	/^static int echoConnect($/;"	f	file:
echoConstructor	test8.c	/^static int echoConstructor($/;"	f	file:
echoCreate	test8.c	/^static int echoCreate($/;"	f	file:
echoDeclareVtab	test8.c	/^static int echoDeclareVtab($/;"	f	file:
echoDestroy	test8.c	/^static int echoDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
echoDestructor	test8.c	/^static int echoDestructor(sqlite3_vtab *pVtab){$/;"	f	file:
echoDisconnect	test8.c	/^static int echoDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
echoEof	test8.c	/^static int echoEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoFilter	test8.c	/^static int echoFilter($/;"	f	file:
echoFindFunction	test8.c	/^static int echoFindFunction($/;"	f	file:
echoModule	test8.c	/^static sqlite3_module echoModule = {$/;"	v	file:
echoNext	test8.c	/^static int echoNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoOn	shell.c	/^  int echoOn;            \/* True to echo input commands *\/$/;"	m	struct:callback_data	file:
echoOpen	test8.c	/^static int echoOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
echoRename	test8.c	/^static int echoRename(sqlite3_vtab *vtab, const char *zNewName){$/;"	f	file:
echoRollback	test8.c	/^static int echoRollback(sqlite3_vtab *tab){$/;"	f	file:
echoRowid	test8.c	/^static int echoRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
echoSync	test8.c	/^static int echoSync(sqlite3_vtab *tab){$/;"	f	file:
echoTransactionCall	test8.c	/^static int echoTransactionCall(sqlite3_vtab *tab, const char *zCall){$/;"	f	file:
echoUpdate	test8.c	/^int echoUpdate($/;"	f
echo_cursor	test8.c	/^struct echo_cursor {$/;"	s	file:
echo_cursor	test8.c	/^typedef struct echo_cursor echo_cursor;$/;"	t	typeref:struct:echo_cursor	file:
echo_vtab	test8.c	/^struct echo_vtab {$/;"	s	file:
echo_vtab	test8.c	/^typedef struct echo_vtab echo_vtab;$/;"	t	typeref:struct:echo_vtab	file:
ecmd	parse.y	/^ecmd ::= SEMI.$/;"	l
ecmd	parse.y	/^ecmd ::= explain cmdx SEMI.$/;"	l
elapse	os_common.h	/^static unsigned int elapse;$/;"	v
emptySignal	test_async.c	/^  pthread_cond_t emptySignal;  \/* Notify when the write queue is empty *\/$/;"	m	struct:TestAsyncStaticData	file:
enable	fault.c	/^  u8 enable;        \/* True if enabled *\/$/;"	m	struct:FaultInjector	file:
enableTimer	shell.c	/^static int enableTimer = 0;$/;"	v	file:
enable_shared_cache	sqlite3ext.h	/^  int  (*enable_shared_cache)(int);$/;"	m	struct:sqlite3_api_routines
enable_simulated_io_errors	pager.c	/^void enable_simulated_io_errors(void){$/;"	f
enable_simulated_io_errors	pager.c	2397;"	d	file:
enable_simulated_io_errors	pager.h	123;"	d
enc	sqliteInt.h	/^  u8 enc;               \/* Text encoding handled by xCmp() *\/$/;"	m	struct:CollSeq
enc	sqliteInt.h	/^  u8 enc;              \/* Text encoding used by this database *\/$/;"	m	struct:Schema
enc	sqliteInt.h	/^  u8 enc;             \/* Text encoding - one of the TEXT_Utf* values *\/$/;"	m	struct:KeyInfo
enc	vdbeInt.h	/^  u8  enc;            \/* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE *\/$/;"	m	struct:Mem
endTimer	shell.c	/^static void endTimer(void){$/;"	f	file:
enterMem	mem1.c	/^static void enterMem(void){$/;"	f	file:
enterMem	mem2.c	/^static void enterMem(void){$/;"	f	file:
enterMutex	os_unix.c	/^static void enterMutex(){$/;"	f	file:
errCode	pager.c	/^  int errCode;                \/* One of several kinds of errors *\/$/;"	m	struct:Pager	file:
errCode	sqliteInt.h	/^  int errCode;                  \/* Most recent error code (SQLITE_*) *\/$/;"	m	struct:sqlite3
errCode	test_server.c	/^  int errCode;                 \/* Error code returned *\/$/;"	m	struct:SqlMessage	file:
errMask	sqliteInt.h	/^  int errMask;                  \/* & result codes with this before returning *\/$/;"	m	struct:sqlite3
errcode	sqlite3ext.h	/^  int  (*errcode)(sqlite3*db);$/;"	m	struct:sqlite3_api_routines
errmsg	sqlite3ext.h	/^  const char * (*errmsg)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
errmsg16	sqlite3ext.h	/^  const void * (*errmsg16)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
errorAction	vdbeInt.h	/^  int errorAction;        \/* Recovery action to do in case of an error *\/$/;"	m	struct:Vdbe
errorName	test2.c	/^static char *errorName(int rc){$/;"	f	file:
errorName	test3.c	/^static char *errorName(int rc){$/;"	f	file:
estLog	where.c	/^static double estLog(double N){$/;"	f	file:
etBUFSIZE	printf.c	193;"	d	file:
etByte	printf.c	/^typedef unsigned char etByte;$/;"	t	file:
etCHARLIT	printf.c	69;"	d	file:
etCHARX	printf.c	67;"	d	file:
etDYNSTRING	printf.c	65;"	d	file:
etEXP	printf.c	61;"	d	file:
etFLOAT	printf.c	60;"	d	file:
etGENERIC	printf.c	62;"	d	file:
etNINFO	printf.c	139;"	d	file:
etORDINAL	printf.c	77;"	d	file:
etPERCENT	printf.c	66;"	d	file:
etPOINTER	printf.c	75;"	d	file:
etRADIX	printf.c	59;"	d	file:
etSIZE	printf.c	63;"	d	file:
etSQLESCAPE	printf.c	70;"	d	file:
etSQLESCAPE2	printf.c	71;"	d	file:
etSQLESCAPE3	printf.c	76;"	d	file:
etSRCLIST	printf.c	74;"	d	file:
etSTRING	printf.c	64;"	d	file:
etTOKEN	printf.c	73;"	d	file:
et_getdigit	printf.c	/^static int et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){$/;"	f	file:
et_info	printf.c	/^typedef struct et_info {   \/* Information about each format field *\/$/;"	s	file:
et_info	printf.c	/^} et_info;$/;"	t	typeref:struct:et_info	file:
exclusiveMode	pager.c	/^  u8 exclusiveMode;           \/* Boolean. True if locking_mode==EXCLUSIVE *\/$/;"	m	struct:Pager	file:
exec	sqlite3ext.h	/^  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);$/;"	m	struct:sqlite3_api_routines
execExecSql	vacuum.c	/^static int execExecSql(sqlite3 *db, const char *zSql){$/;"	f	file:
execFuncCallback	test1.c	/^static int execFuncCallback(void *pData, int argc, char **argv, char **NotUsed){$/;"	f	file:
execSql	vacuum.c	/^static int execSql(sqlite3 *db, const char *zSql){$/;"	f	file:
exec_printf_cb	test1.c	/^static int exec_printf_cb(void *pArg, int argc, char **argv, char **name){$/;"	f	file:
expandBlob	vdbemem.c	26;"	d	file:
expired	sqlite3ext.h	/^  int  (*expired)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
expired	vdbeInt.h	/^  u8 expired;             \/* True if the VM needs to be recompiled *\/$/;"	m	struct:Vdbe
explain	parse.y	/^explain ::= .           { sqlite3BeginParse(pParse, 0); }$/;"	l
explain	parse.y	/^explain ::= EXPLAIN QUERY PLAN.   { sqlite3BeginParse(pParse, 2); }$/;"	l
explain	parse.y	/^explain ::= EXPLAIN.              { sqlite3BeginParse(pParse, 1); }$/;"	l
explain	sqliteInt.h	/^  u8 explain;          \/* True if the EXPLAIN flag is found on the query *\/$/;"	m	struct:Parse
explain	vdbeInt.h	/^  u8 explain;             \/* True if EXPLAIN present on SQL command *\/$/;"	m	struct:Vdbe
explainPrev	shell.c	/^  struct previous_mode_data explainPrev;$/;"	m	struct:callback_data	typeref:struct:callback_data::previous_mode_data	file:
exprAnalyze	where.c	/^static void exprAnalyze($/;"	f	file:
exprAnalyzeAll	where.c	/^static void exprAnalyzeAll($/;"	f	file:
exprCommute	where.c	/^static void exprCommute(Expr *pExpr){$/;"	f	file:
exprListTableUsage	where.c	/^static Bitmask exprListTableUsage(ExprMaskSet *pMaskSet, ExprList *pList){$/;"	f	file:
exprNodeIsConstant	expr.c	/^static int exprNodeIsConstant(void *pArg, Expr *pExpr){$/;"	f	file:
exprSelectTableUsage	where.c	/^static Bitmask exprSelectTableUsage(ExprMaskSet *pMaskSet, Select *pS){$/;"	f	file:
exprTableUsage	where.c	/^static Bitmask exprTableUsage(ExprMaskSet *pMaskSet, Expr *p){$/;"	f	file:
fake_big_file	test2.c	/^static int fake_big_file($/;"	f	file:
fcntl	os_unix.c	134;"	d	file:
fcntl	os_unix.c	468;"	d	file:
fd	os_unix.c	/^  int fd;                           \/* file desc to assoc this lock with *\/$/;"	m	struct:ByteRangeLockPB2	file:
fd	os_unix.c	/^  int fd;                \/* File to be locked *\/$/;"	m	struct:threadTestData	file:
fd	pager.c	/^  sqlite3_file *fd, *jfd;     \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
fdatasync	os_unix.c	898;"	d	file:
fetchId	vdbeInt.h	/^  int fetchId;          \/* Statement number used by sqlite3_fetch_statement *\/$/;"	m	struct:Vdbe
fetchPayload	btree.c	/^static const unsigned char *fetchPayload($/;"	f	file:
filePath	os_unix.c	/^  char *filePath;$/;"	m	struct:afpLockingContext	file:
file_control	sqlite3ext.h	/^  int (*file_control)(sqlite3*,const char*,int,void*);$/;"	m	struct:sqlite3_api_routines
file_control_test	test1.c	/^static int file_control_test($/;"	f	file:
file_format	sqliteInt.h	/^  u8 file_format;      \/* Schema format version for this file *\/$/;"	m	struct:Schema
fillInCell	btree.c	/^static int fillInCell($/;"	f	file:
fillInUnixFile	os_unix.c	/^static int fillInUnixFile($/;"	f	file:
finalize	sqlite3ext.h	/^  int  (*finalize)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
finalize	test_schema.c	/^static int finalize(sqlite3_stmt **ppStmt){$/;"	f	file:
finalizeAggFunctions	select.c	/^static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
findCell	btree.c	499;"	d	file:
findCollSeqEntry	callback.c	/^static CollSeq *findCollSeqEntry($/;"	f	file:
findElementGivenHash	hash.c	/^static HashElem *findElementGivenHash($/;"	f	file:
findLockInfo	os_unix.c	/^static int findLockInfo($/;"	f	file:
findOverflowCell	btree.c	/^static u8 *findOverflowCell(MemPage *pPage, int iCell){$/;"	f	file:
findSqlFunc	tclsqlite.c	/^static SqlFunc *findSqlFunc(SqliteDb *pDb, const char *zName){$/;"	f	file:
findTerm	where.c	/^static WhereTerm *findTerm($/;"	f	file:
find_home_dir	shell.c	/^static char *find_home_dir(void){$/;"	f	file:
first	hash.h	/^  HashElem *first;        \/* The first element of the array *\/$/;"	m	struct:Hash
firstFree	mem4.c	/^  int firstFree;$/;"	m	struct:__anon7	file:
firstUnused	mem4.c	/^  int firstUnused;$/;"	m	struct:__anon7	file:
flagPragma	pragma.c	/^static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){$/;"	f	file:
flags	journal.c	/^  int flags;                      \/* xOpen flags *\/$/;"	m	struct:JournalFile	file:
flags	printf.c	/^  etByte flags;            \/* One or more of FLAG_ constants below *\/$/;"	m	struct:et_info	file:
flags	sqliteInt.h	/^  int flags;                    \/* Miscellanous flags. See below *\/$/;"	m	struct:sqlite3
flags	sqliteInt.h	/^  int flags;            \/* Flags associated with this level *\/$/;"	m	struct:WhereLevel
flags	sqliteInt.h	/^  u16 flags;             \/* Various flags.  See below *\/$/;"	m	struct:Expr
flags	sqliteInt.h	/^  u16 flags;           \/* Flags associated with this schema *\/$/;"	m	struct:Schema
flags	sqliteInt.h	/^  u8 flags;            \/* Some combination of SQLITE_FUNC_* *\/$/;"	m	struct:FuncDef
flags	vdbe.h	/^  u8 flags;           \/* Flags for internal use *\/$/;"	m	struct:VdbeOp
flags	vdbeInt.h	/^  u16 flags;          \/* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. *\/$/;"	m	struct:Mem
flags	vdbeblob.c	/^  int flags;              \/* Copy of "flags" passed to sqlite3_blob_open() *\/$/;"	m	struct:Incrblob	file:
flags	where.c	/^  u8 flags;               \/* Bit flags.  See below *\/$/;"	m	struct:WhereTerm	file:
flattenSubquery	select.c	/^static int flattenSubquery($/;"	f	file:
floatSwap	vdbeaux.c	/^static u64 floatSwap(u64 in){$/;"	f	file:
flockLockingContext	os_unix.c	/^typedef void flockLockingContext;$/;"	t	file:
flockLockingStyle	os_unix.c	/^        flockLockingStyle,           \/* use flock() *\/$/;"	e	enum:__anon4	file:
flockUnixCheckReservedLock	os_unix.c	/^static int flockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
flockUnixClose	os_unix.c	/^static int flockUnixClose(sqlite3_file *pId) {$/;"	f	file:
flockUnixLock	os_unix.c	/^static int flockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
flockUnixUnlock	os_unix.c	/^static int flockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
flushStmtCache	tclsqlite.c	/^static void flushStmtCache( SqliteDb *pDb ){$/;"	f	file:
fmtinfo	printf.c	/^static const et_info fmtinfo[] = {$/;"	v	file:
fmttype	printf.c	/^  char fmttype;            \/* The format field code letter *\/$/;"	m	struct:et_info	file:
foreach_clause	parse.y	/^foreach_clause ::= .$/;"	l
foreach_clause	parse.y	/^foreach_clause ::= FOR EACH ROW.$/;"	l
free	pager.c	/^  PagerLruLink free;             \/* Next and previous free pages *\/$/;"	m	struct:PgHdr	file:
free	sqlite3ext.h	/^  void  (*free)(void*);$/;"	m	struct:sqlite3_api_routines
freeEphemeralFunction	vdbeaux.c	/^static void freeEphemeralFunction(FuncDef *pDef){$/;"	f	file:
freeIndex	build.c	/^static void freeIndex(Index *p){$/;"	f	file:
freeP4	vdbeaux.c	/^static void freeP4(int p4type, void *p3){$/;"	f	file:
freePage	btree.c	/^static int freePage(MemPage *pPage){$/;"	f	file:
freeSpace	btree.c	/^static void freeSpace(MemPage *pPage, int start, int size){$/;"	f	file:
free_table	sqlite3ext.h	/^  void  (*free_table)(char**result);$/;"	m	struct:sqlite3_api_routines
free_test_auxdata	func.c	/^static void free_test_auxdata(void *p) {sqlite3_free(p);}$/;"	f	file:
fsAccess	test_onefile.c	/^static int fsAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
fsCheckReservedLock	test_onefile.c	/^static int fsCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
fsClose	test_onefile.c	/^static int fsClose(sqlite3_file *pFile){$/;"	f	file:
fsCurrentTime	test_onefile.c	/^static int fsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
fsDelete	test_onefile.c	/^static int fsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
fsDeviceCharacteristics	test_onefile.c	/^static int fsDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
fsDlClose	test_onefile.c	/^static void fsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
fsDlError	test_onefile.c	/^static void fsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
fsDlOpen	test_onefile.c	/^static void *fsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
fsDlSym	test_onefile.c	/^static void *fsDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
fsFileControl	test_onefile.c	/^static int fsFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
fsFileSize	test_onefile.c	/^static int fsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
fsFullPathname	test_onefile.c	/^static int fsFullPathname($/;"	f	file:
fsGetTempname	test_onefile.c	/^static int fsGetTempname(sqlite3_vfs *pVfs, int nBufOut, char *zBufOut){$/;"	f	file:
fsLock	test_onefile.c	/^static int fsLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsOpen	test_onefile.c	/^static int fsOpen($/;"	f	file:
fsRandomness	test_onefile.c	/^static int fsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
fsRead	test_onefile.c	/^static int fsRead($/;"	f	file:
fsSectorSize	test_onefile.c	/^static int fsSectorSize(sqlite3_file *pFile){$/;"	f	file:
fsSleep	test_onefile.c	/^static int fsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
fsSync	test_onefile.c	/^static int fsSync(sqlite3_file *pFile, int flags){$/;"	f	file:
fsTruncate	test_onefile.c	/^static int fsTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
fsUnlock	test_onefile.c	/^static int fsUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsWrite	test_onefile.c	/^static int fsWrite($/;"	f	file:
fs_file	test_onefile.c	/^struct fs_file {$/;"	s	file:
fs_file	test_onefile.c	/^typedef struct fs_file fs_file;$/;"	t	typeref:struct:fs_file	file:
fs_io_methods	test_onefile.c	/^static sqlite3_io_methods fs_io_methods = {$/;"	v	file:
fs_real_file	test_onefile.c	/^struct fs_real_file {$/;"	s	file:
fs_real_file	test_onefile.c	/^typedef struct fs_real_file fs_real_file;$/;"	t	typeref:struct:fs_real_file	file:
fs_register	test_onefile.c	/^int fs_register(){$/;"	f
fs_vfs	test_onefile.c	/^static fs_vfs_t fs_vfs = {$/;"	v	file:
fs_vfs_t	test_onefile.c	/^struct fs_vfs_t {$/;"	s	file:
fs_vfs_t	test_onefile.c	/^typedef struct fs_vfs_t fs_vfs_t;$/;"	t	typeref:struct:fs_vfs_t	file:
fullSync	pager.c	/^  u8 fullSync;                \/* Do extra syncs of the journal for robustness *\/$/;"	m	struct:Pager	file:
full_fsync	os_unix.c	/^static int full_fsync(int fd, int fullSync, int dataOnly){$/;"	f	file:
g	test6.c	/^static CrashGlobal g = {0, 0, SQLITE_DEFAULT_SECTOR_SIZE, 0, 0};$/;"	v	file:
g	test_devsym.c	/^struct DevsymGlobal g = {0, 0, 512};$/;"	v	typeref:struct:DevsymGlobal
g	test_server.c	/^} g = {$/;"	v	typeref:struct:ServerState	file:
g_start	os_common.h	/^static unsigned long long int g_start;$/;"	v
generateColumnNames	select.c	/^static void generateColumnNames($/;"	f	file:
generateColumnTypes	select.c	/^static void generateColumnTypes($/;"	f	file:
generateSortTail	select.c	/^static void generateSortTail($/;"	f	file:
get2byte	btreeInt.h	631;"	d
get4byte	btreeInt.h	633;"	d
getAndInitPage	btree.c	/^static int getAndInitPage($/;"	f	file:
getAutoVacuum	pragma.c	/^static int getAutoVacuum(const char *z){$/;"	f	file:
getBoolean	pragma.c	/^static int getBoolean(const char *z){$/;"	f	file:
getCellInfo	btree.c	/^  static void getCellInfo(BtCursor *pCur){$/;"	f	file:
getCellInfo	btree.c	2866;"	d	file:
getColumnNames	test8.c	/^static int getColumnNames($/;"	f	file:
getDbPointer	test1.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	test8.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	test_schema.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDbPointer	test_tclvar.c	/^static int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f	file:
getDigits	date.c	/^static int getDigits(const char *zDate, ...){$/;"	f	file:
getFileLock	test_async.c	/^static int getFileLock(AsyncLock *pLock){$/;"	f	file:
getIndexArray	test8.c	/^static int getIndexArray($/;"	f	file:
getLockingMode	pragma.c	/^static int getLockingMode(const char *z){$/;"	f	file:
getMask	where.c	/^static Bitmask getMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
getOverflowPage	btree.c	/^static int getOverflowPage($/;"	f	file:
getReadLock	os_os2.c	/^static int getReadLock( os2File *pFile ){$/;"	f	file:
getReadLock	os_win.c	/^static int getReadLock(winFile *pFile){$/;"	f	file:
getSafetyLevel	pragma.c	/^static int getSafetyLevel(const char *z){$/;"	f	file:
getStmtPointer	test1.c	/^static int getStmtPointer($/;"	f	file:
getTempStore	pragma.c	/^static int getTempStore(const char *z){$/;"	f	file:
getToken	tokenize.c	/^static int getToken(const unsigned char *z, int *tokenType){$/;"	f	file:
getValue	date.c	126;"	d	file:
getVarint	btreeInt.h	500;"	d
getVarint32	btreeInt.h	501;"	d
get_autocommit	sqlite3ext.h	/^  int  (*get_autocommit)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
get_autocommit	test1.c	/^static int get_autocommit($/;"	f	file:
get_auxdata	sqlite3ext.h	/^  void * (*get_auxdata)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
get_sqlite_pointer	test1.c	/^static int get_sqlite_pointer($/;"	f	file:
get_table	sqlite3ext.h	/^  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);$/;"	m	struct:sqlite3_api_routines
gfree	pager.c	/^  PagerLruLink gfree;            \/* Global list of nRef==0 pages *\/$/;"	m	struct:PgHdr	file:
globInfo	func.c	/^static const struct compareInfo globInfo = { '*', '?', '[', 0 };$/;"	v	typeref:struct:compareInfo	file:
global_recover	sqlite3ext.h	/^  int  (*global_recover)(void);$/;"	m	struct:sqlite3_api_routines
groupConcatFinalize	func.c	/^static void groupConcatFinalize(sqlite3_context *context){$/;"	f	file:
groupConcatStep	func.c	/^static void groupConcatStep($/;"	f	file:
h	date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
h	os_os2.c	/^  HFILE h;                  \/* Handle for accessing the file *\/$/;"	m	struct:os2File	file:
h	os_unix.c	/^  int h;                    \/* The file descriptor *\/$/;"	m	struct:unixFile	file:
h	os_win.c	/^  HANDLE h;               \/* Handle for accessing the file *\/$/;"	m	struct:winFile	file:
hMutex	os_win.c	/^  HANDLE hMutex;          \/* Mutex used to control access to shared lock *\/  $/;"	m	struct:winFile	file:
hShared	os_win.c	/^  HANDLE hShared;         \/* Shared memory segment used for locking *\/$/;"	m	struct:winFile	file:
halfFunc	test_loadext.c	/^static void halfFunc($/;"	f	file:
hasAgg	sqliteInt.h	/^  u8 hasAgg;           \/* True if aggregates are seen *\/$/;"	m	struct:NameContext
hasData	btreeInt.h	/^  u8 hasData;          \/* True if this page stores data *\/$/;"	m	struct:MemPage
hasHotJournal	pager.c	/^static int hasHotJournal(Pager *pPager){$/;"	f	file:
hasPrimKey	sqliteInt.h	/^  u8 hasPrimKey;   \/* True if there exists a primary key *\/$/;"	m	struct:Table
hash	vdbeInt.h	/^  Hash hash;             \/* A set is just a hash table *\/$/;"	m	struct:Set
hashFunction	hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashString	test8.c	/^static int hashString(const char *zString){$/;"	f	file:
hdr	mem3.c	/^    } hdr;$/;"	m	union:Mem3Block::__anon8	typeref:struct:Mem3Block::__anon8::__anon9	file:
hdrOffset	btreeInt.h	/^  u8 hdrOffset;        \/* 100 for page 1.  0 otherwise *\/$/;"	m	struct:MemPage
heightOfExpr	expr.c	/^static void heightOfExpr(Expr *p, int *pnHeight){$/;"	f	file:
heightOfExprList	expr.c	/^static void heightOfExprList(ExprList *p, int *pnHeight){$/;"	f	file:
heightOfSelect	expr.c	/^static void heightOfSelect(Select *p, int *pnHeight){$/;"	f	file:
hex16Func	test1.c	/^static void hex16Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hex8Func	test1.c	/^static void hex8Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hexFunc	func.c	/^static void hexFunc($/;"	f	file:
hexToInt	test_malloc.c	/^static int hexToInt(int h){$/;"	f	file:
hexToInt	util.c	/^static int hexToInt(int h){$/;"	f	file:
hexdigits	func.c	/^static const char hexdigits[] = {$/;"	v	file:
hexio_get_int	test_hexio.c	/^static int hexio_get_int($/;"	f	file:
hexio_read	test_hexio.c	/^static int hexio_read($/;"	f	file:
hexio_render_int16	test_hexio.c	/^static int hexio_render_int16($/;"	f	file:
hexio_render_int32	test_hexio.c	/^static int hexio_render_int32($/;"	f	file:
hexio_write	test_hexio.c	/^static int hexio_write($/;"	f	file:
ht	hash.h	/^  } *ht;$/;"	m	struct:Hash	typeref:struct:Hash::_ht
htsize	hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:Hash
hwtime	os_common.h	/^__inline__ unsigned long long int hwtime(void){$/;"	f
hwtime	vdbe.c	/^__inline__ unsigned long long int hwtime(void){$/;"	f
i	random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
i	vdbe.h	/^    int i;                 \/* Integer value if p4type==P4_INT32 *\/$/;"	m	union:VdbeOp::__anon12
i	vdbeInt.h	/^    i64 i;              \/* Integer value. Or FuncDef* when flags==MEM_Agg *\/$/;"	m	union:Mem::__anon6
i1	test_tclvar.c	/^  int i1;              \/* Current item in pList1 *\/$/;"	m	struct:tclvar_cursor	file:
i16	sqliteInt.h	/^typedef INT16_TYPE i16;            \/* 2-byte signed integer *\/$/;"	t
i2	test_tclvar.c	/^  int i2;              \/* Current item (if any) in pList2 *\/$/;"	m	struct:tclvar_cursor	file:
i64	sqliteInt.h	/^typedef sqlite_int64 i64;          \/* 8-byte signed integer *\/$/;"	t
i8	sqliteInt.h	/^typedef UINT8_TYPE i8;             \/* 1-byte signed integer *\/$/;"	t
iAgg	sqliteInt.h	/^  int iAgg;              \/* Which entry in pAggInfo->aCol[] or ->aFunc[] *\/$/;"	m	struct:Expr
iBreak	sqliteInt.h	/^  int iBreak;          \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereInfo
iColumn	sqliteInt.h	/^    int iColumn;             \/* Column number within the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iColumn	sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iContinue	sqliteInt.h	/^  int iContinue;       \/* Jump here to continue with next record *\/$/;"	m	struct:WhereInfo
iCountdown	fault.c	/^  int iCountdown;   \/* Number of pending successes before we hit a failure *\/$/;"	m	struct:FaultInjector	file:
iCrash	test6.c	/^  int iCrash;                  \/* Crash on the iCrash'th call to xSync() *\/$/;"	m	struct:CrashGlobal	file:
iCur	sqliteInt.h	/^    int iCur;              \/* The VDBE cursor used by this IN operator *\/$/;"	m	struct:WhereLevel::InLoop
iCursor	sqliteInt.h	/^    int iCursor;      \/* The VDBE cursor number used to access this table *\/$/;"	m	struct:SrcList::SrcList_item
iDb	build.c	/^  int iDb;             \/* The database containing the table to be locked *\/$/;"	m	struct:TableLock	file:
iDb	sqliteInt.h	/^    int iDb;                    \/* When back is being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
iDb	sqliteInt.h	/^  int iDb;            \/* 0 for main database.  1 for TEMP, 2.. for ATTACHed *\/$/;"	m	struct:__anon3
iDb	vdbeInt.h	/^  int iDb;              \/* Index of cursor database in db->aDb[] (or -1) *\/$/;"	m	struct:Cursor
iDeviceChar	test_devsym.c	/^  int iDeviceChar;$/;"	m	struct:DevsymGlobal	file:
iDeviceCharacteristics	test6.c	/^  int iDeviceCharacteristics;  \/* Value of simulated device characteristics *\/$/;"	m	struct:CrashGlobal	file:
iDistinct	sqliteInt.h	/^    int iDistinct;           \/* Ephermeral table used to enforce DISTINCT *\/$/;"	m	struct:AggInfo::AggInfo_func
iECursor	sqliteInt.h	/^  int iECursor;          \/* VDBE Cursor associated with this ExprList *\/$/;"	m	struct:ExprList
iForeGuard	mem2.c	/^  int iForeGuard;                     \/* Guard word for sanity *\/$/;"	m	struct:MemBlockHdr	file:
iFrom	sqliteInt.h	/^    int iFrom;         \/* Index of column in pFrom *\/$/;"	m	struct:FKey::sColMap
iFrom	sqliteInt.h	/^  int iFrom;            \/* Which entry in the FROM clause *\/$/;"	m	struct:WhereLevel
iIdxCur	sqliteInt.h	/^  int iIdxCur;          \/* The VDBE cursor used to acesss pIdx *\/$/;"	m	struct:WhereLevel
iInUseDB	pager.c	/^  int iInUseDB;               \/* Non-zero if in sqlite3_release_memory() *\/$/;"	m	struct:Pager	file:
iInUseMM	pager.c	/^  int iInUseMM;               \/* Non-zero if unavailable to MM *\/$/;"	m	struct:Pager	file:
iKey	vdbeInt.h	/^  i64 iKey;             \/* Key for the NEW or OLD pseudo-table row *\/$/;"	m	struct:Cursor
iLeftJoin	sqliteInt.h	/^  int iLeftJoin;        \/* Memory cell used to implement LEFT OUTER JOIN *\/$/;"	m	struct:WhereLevel
iLimit	sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iMaster	mem3.c	/^  u32 iMaster;$/;"	m	struct:__anon11	file:
iMem	sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_col
iMem	sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_func
iMem	sqliteInt.h	/^  int iMem;             \/* First memory cell used by this level *\/$/;"	m	struct:WhereLevel
iMem	sqliteInt.h	/^  int iMem;         \/* Base register where results are written *\/$/;"	m	struct:SelectDest
iOffset	sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iOffset	test6.c	/^  i64 iOffset;                 \/* Byte offset of the start of this write() *\/$/;"	m	struct:WriteBuffer	file:
iOffset	test_async.c	/^  i64 iOffset;        \/* See above *\/$/;"	m	struct:AsyncWrite	file:
iOffset	vdbeblob.c	/^  int iOffset;            \/* Byte offset of blob in cursor data *\/$/;"	m	struct:Incrblob	file:
iOverflow	btreeInt.h	/^  u16 iOverflow; \/* Offset to overflow page number.  Zero if no overflow *\/$/;"	m	struct:CellInfo
iPKey	sqliteInt.h	/^  int iPKey;       \/* If not less then 0, use aCol[iPKey] as the primary key *\/$/;"	m	struct:Table
iParent	where.c	/^  i16 iParent;            \/* Disable pWC->a[iParent] when this term disabled *\/$/;"	m	struct:WhereTerm	file:
iParm	sqliteInt.h	/^  int iParm;        \/* A parameter used by the eDest disposal method *\/$/;"	m	struct:SelectDest
iPrefEnc	sqliteInt.h	/^  u8 iPrefEnc;         \/* Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) *\/$/;"	m	struct:FuncDef
iRangeReg	sqliteInt.h	/^  int iRangeReg;       \/* First register in temporary register block *\/$/;"	m	struct:Parse
iRead	vdbeInt.h	/^  int iRead;         \/* Read the next value from this entry in aSlot[] *\/$/;"	m	struct:FifoPage
iRightJoinTable	sqliteInt.h	/^  int iRightJoinTable;   \/* If EP_FromJoin, the right table of the join *\/$/;"	m	struct:Expr
iSectorSize	test6.c	/^  int iSectorSize;             \/* Value of simulated sector size *\/$/;"	m	struct:CrashGlobal	file:
iSectorSize	test_devsym.c	/^  int iSectorSize;$/;"	m	struct:DevsymGlobal	file:
iSeek	tclsqlite.c	/^  int iSeek;                \/* Current seek offset *\/$/;"	m	struct:IncrblobChannel	file:
iSize	journal.c	/^  int iSize;                      \/* Amount of zBuf[] currently used *\/$/;"	m	struct:JournalFile	file:
iSize	mem2.c	/^  int iSize;                          \/* Size of this allocation *\/$/;"	m	struct:MemBlockHdr	file:
iSize	test6.c	/^  int iSize;                           \/* Size of file in bytes *\/$/;"	m	struct:CrashFile	file:
iSorterColumn	sqliteInt.h	/^    int iSorterColumn;       \/* Column number in the sorting index *\/$/;"	m	struct:AggInfo::AggInfo_col
iSum	func.c	/^  i64 iSum;         \/* Integer sum *\/   $/;"	m	struct:SumCtx	file:
iTab	build.c	/^  int iTab;            \/* The root page of the table to be locked *\/$/;"	m	struct:TableLock	file:
iTabCur	sqliteInt.h	/^  int iTabCur;          \/* The VDBE cursor used to access the table *\/$/;"	m	struct:WhereLevel
iTable	btreeInt.h	/^  Pgno iTable;          \/* Root page of table *\/$/;"	m	struct:BtLock
iTable	sqliteInt.h	/^    int iTable;              \/* Cursor number of the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iTable	sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iTop	sqliteInt.h	/^  int iTop;            \/* The very beginning of the WHERE loop *\/$/;"	m	struct:WhereInfo
iWrite	vdbeInt.h	/^  int iWrite;        \/* Push the next value into this entry in aSlot[] *\/$/;"	m	struct:FifoPage
id	mutex.c	/^  int id;     \/* The mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	mutex_os2.c	/^  int  id;          \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	mutex_unix.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	mutex_w32.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
identLength	build.c	/^static int identLength(const char *z){$/;"	f	file:
identPut	build.c	/^static void identPut(char *z, int *pIdx, char *zSignedIdent){$/;"	f	file:
idx	btreeInt.h	/^    u16 idx;            \/* Insert this cell before idx-th non-overflow cell *\/$/;"	m	struct:MemPage::_OvflCell
idx	btreeInt.h	/^  int idx;                  \/* Index of the entry in pPage->aCell[] *\/$/;"	m	struct:BtCursor
idx	sqliteInt.h	/^    int idx;          \/* Index in some Table.aCol[] of a column named zName *\/$/;"	m	struct:IdList::IdList_item
idxHash	sqliteInt.h	/^  Hash idxHash;        \/* All (named) indices indexed by name *\/$/;"	m	struct:Schema
idxParent	btreeInt.h	/^  u16 idxParent;       \/* Index in parent of this node *\/$/;"	m	struct:MemPage
idxShift	btreeInt.h	/^  u8 idxShift;         \/* True if Cell indices have changed *\/$/;"	m	struct:MemPage
ifnullFunc	func.c	/^static void ifnullFunc($/;"	f	file:
ignoreJump	sqliteInt.h	/^  int ignoreJump;      \/* where to jump to for a RAISE(IGNORE) *\/$/;"	m	struct:TriggerStack
in	test_md5.c	/^  unsigned char in[64];$/;"	m	struct:Context	file:
inJournal	pager.c	/^  u8 inJournal;                  \/* TRUE if has been written to journal *\/$/;"	m	struct:PgHdr	file:
inStmt	btreeInt.h	/^  u8 inStmt;            \/* True if we are in a statement subtransaction *\/$/;"	m	struct:BtShared
inStmt	pager.c	/^  u8 inStmt;                     \/* TRUE if in the statement subjournal *\/$/;"	m	struct:PgHistory	file:
inTempTrans	vdbeInt.h	/^  int inTempTrans;        \/* True if temp database is transactioned *\/$/;"	m	struct:Vdbe
inTrans	btreeInt.h	/^  u8 inTrans;        \/* TRANS_NONE, TRANS_READ or TRANS_WRITE *\/$/;"	m	struct:Btree
inTrans	sqliteInt.h	/^  u8 inTrans;          \/* 0: not writable.  1: Transaction.  2: Checkpoint *\/$/;"	m	struct:Db
inTransaction	btreeInt.h	/^  u8 inTransaction;     \/* Transaction state *\/$/;"	m	struct:BtShared
inVtabMethod	vdbeInt.h	/^  u8 inVtabMethod;        \/* See comments above *\/$/;"	m	struct:Vdbe
incrKey	sqliteInt.h	/^  u8 incrKey;         \/* Increase 2nd key by epsilon before comparison *\/$/;"	m	struct:KeyInfo
incrOpenFileCount	test_async.c	/^static void incrOpenFileCount(){$/;"	f	file:
incrVacuum	btreeInt.h	/^  u8 incrVacuum;        \/* True if incr-vacuum is enabled *\/$/;"	m	struct:BtShared
incrVacuumStep	btree.c	/^static int incrVacuumStep(BtShared *pBt, Pgno nFin){$/;"	f	file:
incrblobClose	tclsqlite.c	/^static int incrblobClose(ClientData instanceData, Tcl_Interp *interp){$/;"	f	file:
incrblobHandle	tclsqlite.c	/^static int incrblobHandle(ClientData instanceData, int dir, ClientData *hPtr){$/;"	f	file:
incrblobInput	tclsqlite.c	/^static int incrblobInput($/;"	f	file:
incrblobOutput	tclsqlite.c	/^static int incrblobOutput($/;"	f	file:
incrblobSeek	tclsqlite.c	/^static int incrblobSeek($/;"	f	file:
incrblobWatch	tclsqlite.c	/^static void incrblobWatch(ClientData instanceData, int mode){ $/;"	f	file:
info	btreeInt.h	/^  CellInfo info;            \/* A parse of the cell we are pointing at *\/$/;"	m	struct:BtCursor
init	sqliteInt.h	/^  } init;$/;"	m	struct:sqlite3	typeref:struct:sqlite3::sqlite3InitInfo
initMaskSet	where.c	285;"	d	file:
ino	os_unix.c	/^  ino_t ino;       \/* Inode number *\/$/;"	m	struct:lockKey	file:
ino	os_unix.c	/^  ino_t ino;   \/* Inode number *\/$/;"	m	struct:openKey	file:
input	parse.y	/^input ::= cmdlist.$/;"	l
insertCell	btree.c	/^static int insertCell($/;"	f	file:
insertConf	sqliteInt.h	/^  u8 insertConf;    \/* How to resolve conflicts that occur on INSERT *\/$/;"	m	struct:FKey
insertElement	hash.c	/^static void insertElement($/;"	f	file:
intKey	btreeInt.h	/^  u8 intKey;           \/* True if intkey flag is set *\/$/;"	m	struct:MemPage
intToKey	vdbeInt.h	26;"	d
interp	tclsqlite.c	/^  Tcl_Interp *interp;        \/* The interpreter used for this database *\/$/;"	m	struct:SqliteDb	file:
interp	tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlCollate	file:
interp	tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlFunc	file:
interp	test1.c	/^  Tcl_Interp *interp;$/;"	m	struct:TestCollationX	file:
interp	test8.c	/^  Tcl_Interp *interp;     \/* Tcl interpreter containing debug variables *\/$/;"	m	struct:echo_vtab	file:
interp	test8.c	/^  Tcl_Interp *interp;$/;"	m	struct:EchoModule	file:
interp	test_tclvar.c	/^  Tcl_Interp *interp;$/;"	m	struct:tclvar_vtab	file:
interp	test_thread.c	/^  Tcl_Interp *interp;      \/* Parent interpreter *\/$/;"	m	struct:SqlThread	file:
interp	test_thread.c	/^  Tcl_Interp *interp;      \/* The interpreter to execute it in. *\/$/;"	m	struct:EvalEvent	file:
interrupt_handler	shell.c	/^static void interrupt_handler(int NotUsed){$/;"	f	file:
interruptx	sqlite3ext.h	/^  void  (*interruptx)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
invalidateAllOverflowCache	btree.c	/^static void invalidateAllOverflowCache(BtShared *pBt){$/;"	f	file:
invalidateAllOverflowCache	btree.c	280;"	d	file:
invalidateCursorsOnModifiedBtrees	vdbeaux.c	/^static void invalidateCursorsOnModifiedBtrees(sqlite3 *db){$/;"	f	file:
invalidateOverflowCache	btree.c	/^static void invalidateOverflowCache(BtCursor *pCur){$/;"	f	file:
invalidateOverflowCache	btree.c	279;"	d	file:
invalidateTempStorage	pragma.c	/^static int invalidateTempStorage(Parse *pParse){$/;"	f	file:
ioDelay	test_async.c	/^  volatile int ioDelay;             \/* Extra delay between write operations *\/$/;"	m	struct:TestAsyncStaticData	file:
ioError	test_async.c	/^  int ioError;                 \/* True if an IO error has occured *\/$/;"	m	struct:TestAsyncStaticData	file:
io_trace_callback	test1.c	/^static void io_trace_callback(const char *zFormat, ...){$/;"	f	file:
iotrace	shell.c	/^static FILE *iotrace = 0;$/;"	v	file:
iotracePrintf	shell.c	/^static void iotracePrintf(const char *zFormat, ...){$/;"	f	file:
iotrace_file	test1.c	/^static FILE *iotrace_file = 0;$/;"	v	file:
isAgg	sqliteInt.h	/^    u8 isAgg;              \/* True if this is an aggregate like count(*) *\/$/;"	m	struct:ExprList::ExprList_item
isAgg	sqliteInt.h	/^  u8 isAgg;              \/* True if this is an aggregate query *\/$/;"	m	struct:Select
isCheck	sqliteInt.h	/^  u8 isCheck;          \/* True if resolving names in a CHECK constraint *\/$/;"	m	struct:NameContext
isCommit	sqliteInt.h	/^  u8 isCommit;              \/* True once the CREATE TABLE has been committed *\/$/;"	m	struct:Table
isDate	date.c	/^static int isDate($/;"	f	file:
isDeferred	sqliteInt.h	/^  u8 isDeferred;    \/* True if constraint checking is deferred till COMMIT *\/$/;"	m	struct:FKey
isDistinct	sqliteInt.h	/^  u8 isDistinct;         \/* True if the DISTINCT keyword is present *\/$/;"	m	struct:Select
isEphem	sqliteInt.h	/^  u8 isEphem;      \/* True if created using OP_OpenEphermeral *\/$/;"	m	struct:Table
isError	vdbeInt.h	/^  u8 isError;           \/* Set to true for an error *\/$/;"	m	struct:sqlite3_context
isHidden	sqliteInt.h	/^  u8 isHidden;     \/* True if this column is 'hidden' *\/$/;"	m	struct:Column
isIncrblobHandle	btreeInt.h	/^  u8 isIncrblobHandle;      \/* True if this cursor is an incr. io handle *\/$/;"	m	struct:BtCursor
isIndex	vdbeInt.h	/^  Bool isIndex;         \/* True if an index containing keys only - no data *\/$/;"	m	struct:Cursor
isInit	btreeInt.h	/^  u8 isInit;           \/* True if previously initialized. MUST BE FIRST! *\/$/;"	m	struct:MemPage
isInit	random.c	/^  unsigned char isInit;          \/* True if initialized *\/$/;"	m	struct:sqlite3PrngType	file:
isInit	test_md5.c	/^  int isInit;$/;"	m	struct:Context	file:
isInterrupted	sqliteInt.h	/^    int isInterrupted;          \/* True if sqlite3_interrupt has been called *\/$/;"	m	union:sqlite3::__anon2
isLikeOrGlob	where.c	/^static int isLikeOrGlob($/;"	f	file:
isMatchOfColumn	where.c	/^static int isMatchOfColumn($/;"	f	file:
isNT	os_win.c	/^  static int isNT(void){$/;"	f	file:
isNT	os_win.c	137;"	d	file:
isNumber	shell.c	/^static int isNumber(const char *z, int *realnum){$/;"	f	file:
isPattern	test8.c	/^  int isPattern;$/;"	m	struct:echo_vtab	file:
isPopulated	sqliteInt.h	/^    u8 isPopulated;   \/* Temporary table associated with SELECT is populated *\/$/;"	m	struct:SrcList::SrcList_item
isPrimKey	sqliteInt.h	/^  u8 isPrimKey;    \/* True if this column is part of the PRIMARY KEY *\/$/;"	m	struct:Column
isResolved	sqliteInt.h	/^  u8 isResolved;         \/* True once sqlite3SelectResolve() has run. *\/$/;"	m	struct:Select
isSortingIndex	where.c	/^static int isSortingIndex($/;"	f	file:
isTable	vdbeInt.h	/^  Bool isTable;         \/* True if a table requiring integer keys *\/$/;"	m	struct:Cursor
isView	delete.c	147;"	d	file:
isView	delete.c	148;"	d	file:
isView	insert.c	421;"	d	file:
isView	insert.c	422;"	d	file:
isView	update.c	151;"	d	file:
isView	update.c	152;"	d	file:
isVirtual	sqliteInt.h	/^  u8 isVirtual;             \/* True if this is a virtual table *\/$/;"	m	struct:Table
isWriteLock	build.c	/^  u8 isWriteLock;      \/* True for write lock.  False for a read lock *\/$/;"	m	struct:TableLock	file:
isatty	shell.c	60;"	d	file:
ix	where.c	/^  int ix[sizeof(Bitmask)*8];    \/* Cursor assigned to each bit *\/$/;"	m	struct:ExprMaskSet	file:
j	random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
jfd	pager.c	/^  sqlite3_file *fd, *jfd;     \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
jointype	sqliteInt.h	/^    u8 jointype;      \/* Type of join between this able and the previous *\/$/;"	m	struct:SrcList::SrcList_item
journalHdr	pager.c	/^  i64 journalHdr;             \/* Byte offset to previous journal header *\/$/;"	m	struct:Pager	file:
journalOff	pager.c	/^  i64 journalOff;             \/* Current byte offset in the journal file *\/$/;"	m	struct:Pager	file:
journalOpen	pager.c	/^  u8 journalOpen;             \/* True if journal file descriptors is valid *\/$/;"	m	struct:Pager	file:
journalStarted	pager.c	/^  u8 journalStarted;          \/* True if header of journal is synced *\/$/;"	m	struct:Pager	file:
jrnlBufferSize	pager.c	/^static int jrnlBufferSize(Pager *pPager){$/;"	f	file:
jrnlClose	journal.c	/^static int jrnlClose(sqlite3_file *pJfd){$/;"	f	file:
jrnlFileSize	journal.c	/^static int jrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){$/;"	f	file:
jrnlRead	journal.c	/^static int jrnlRead($/;"	f	file:
jrnlSync	journal.c	/^static int jrnlSync(sqlite3_file *pJfd, int flags){$/;"	f	file:
jrnlTruncate	journal.c	/^static int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){$/;"	f	file:
jrnlWrite	journal.c	/^static int jrnlWrite($/;"	f	file:
juliandayFunc	date.c	/^static void juliandayFunc($/;"	f	file:
key	os_unix.c	/^  struct lockKey key;  \/* The lookup key *\/$/;"	m	struct:lockInfo	typeref:struct:lockInfo::lockKey	file:
key	os_unix.c	/^  struct openKey key;   \/* The lookup key *\/$/;"	m	struct:openCnt	typeref:struct:openCnt::openKey	file:
keyClass	hash.h	/^  char keyClass;          \/* SQLITE_HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:Hash
keyConf	sqliteInt.h	/^  u8 keyConf;      \/* What to do in case of uniqueness conflict on iPKey *\/$/;"	m	struct:Table
keyInfoFromExprList	select.c	/^static KeyInfo *keyInfoFromExprList(Parse *pParse, ExprList *pList){$/;"	f	file:
keyToInt	vdbeInt.h	25;"	d
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= .$/;"	l
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= COLUMNKW.$/;"	l
lastRowid	sqliteInt.h	/^  i64 lastRowid;                \/* ROWID of most recent insert (see above) *\/$/;"	m	struct:sqlite3
lastRowid	vdbeInt.h	/^  i64 lastRowid;        \/* Last rowid from a Next or NextIdx operation *\/$/;"	m	struct:Cursor
lastRowid	vdbeInt.h	/^  i64 lastRowid;    \/* Last insert rowid (sqlite3.lastRowid) *\/$/;"	m	struct:Context
last_insert_rowid	func.c	/^static void last_insert_rowid($/;"	f	file:
last_insert_rowid	sqlite3ext.h	/^  sqlite_int64  (*last_insert_rowid)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
leaf	btreeInt.h	/^  u8 leaf;             \/* True if leaf flag is set *\/$/;"	m	struct:MemPage
leafData	btreeInt.h	/^  u8 leafData;         \/* True if tables stores data on leaves only *\/$/;"	m	struct:MemPage
leaveMutex	os_unix.c	/^static void leaveMutex(){$/;"	f	file:
leftColumn	where.c	/^  i16 leftColumn;         \/* Column number of X in "X <op> <expr>" *\/$/;"	m	struct:WhereTerm	file:
leftCursor	where.c	/^  i16 leftCursor;         \/* Cursor number of X in "X <op> <expr>" *\/$/;"	m	struct:WhereTerm	file:
legacyCountFinalize	test1.c	/^static void legacyCountFinalize(sqlite3_context *context){$/;"	f	file:
legacyCountStep	test1.c	/^static void legacyCountStep($/;"	f	file:
length	os_unix.c	/^  unsigned long long length;        \/* nbr of bytes to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
lengthFunc	func.c	/^static void lengthFunc($/;"	f	file:
libversion	sqlite3ext.h	/^  const char * (*libversion)(void);$/;"	m	struct:sqlite3_api_routines
libversion_number	sqlite3ext.h	/^  int  (*libversion_number)(void);$/;"	m	struct:sqlite3_api_routines
likeFunc	func.c	/^static void likeFunc($/;"	f	file:
likeInfoAlt	func.c	/^static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };$/;"	v	typeref:struct:compareInfo	file:
likeInfoNorm	func.c	/^static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };$/;"	v	typeref:struct:compareInfo	file:
likely	sqliteInt.h	26;"	d
likely	sqliteInt.h	29;"	d
list	mem3.c	/^    } list;$/;"	m	union:Mem3Block::__anon8	typeref:struct:Mem3Block::__anon8::__anon10	file:
listAdd	pager.c	/^static void listAdd(PagerLruList *pList, PagerLruLink *pLink, PgHdr *pPg){$/;"	f	file:
listRemove	pager.c	/^static void listRemove(PagerLruList *pList, PagerLruLink *pLink, PgHdr *pPg){$/;"	f	file:
loadAnalysis	analyze.c	/^static void loadAnalysis(Parse *pParse, int iDb){$/;"	f	file:
loadExt	func.c	/^static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
local	os_win.c	/^  winceLock local;        \/* Locks obtained by this instance of winFile *\/$/;"	m	struct:winFile	file:
local_getline	shell.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_getline	tclsqlite.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_ioerr	os_common.h	/^static void local_ioerr(){$/;"	f
localtime	os_win.c	/^struct tm *__cdecl localtime(const time_t *t)$/;"	f
localtimeOffset	date.c	/^static double localtimeOffset(DateTime *p){$/;"	f	file:
lock	os_unix.c	/^  struct flock lock;     \/* The locking operation *\/$/;"	m	struct:threadTestData	typeref:struct:threadTestData::flock	file:
lock	test_async.c	/^  AsyncFileLock lock;$/;"	m	struct:AsyncFileData	file:
lockBtree	btree.c	/^static int lockBtree(BtShared *pBt){$/;"	f	file:
lockBtreeWithRetry	btree.c	/^static int lockBtreeWithRetry(Btree *pRef){$/;"	f	file:
lockHash	os_unix.c	/^static Hash lockHash = {SQLITE_HASH_BINARY, 0, 0, 0, 0, 0};$/;"	v	file:
lockInfo	os_unix.c	/^struct lockInfo {$/;"	s	file:
lockKey	os_unix.c	/^struct lockKey {$/;"	s	file:
lockMutex	test_async.c	/^  pthread_mutex_t lockMutex;   \/* For access to aLock hash table *\/$/;"	m	struct:TestAsyncStaticData	file:
lockMutexHolder	test_async.c	/^  pthread_t lockMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
lockPath	os_unix.c	/^  char *lockPath;$/;"	m	struct:dotlockLockingContext	file:
lockTable	btree.c	/^static int lockTable(Btree *p, Pgno iTable, u8 eLock){$/;"	f	file:
lockTable	btree.c	84;"	d	file:
lockTrace	os_unix.c	/^static int lockTrace(int fd, int op, struct flock *p){$/;"	f	file:
locked	btreeInt.h	/^  u8 locked;         \/* True if db currently has pBt locked *\/$/;"	m	struct:Btree
lockingContext	os_unix.c	/^  void *lockingContext;     \/* Locking style specific state *\/$/;"	m	struct:unixFile	file:
locktype	os_os2.c	/^  unsigned char locktype;   \/* Type of lock currently held on this file *\/$/;"	m	struct:os2File	file:
locktype	os_unix.c	/^  int locktype;        \/* One of SHARED_LOCK, RESERVED_LOCK etc. *\/$/;"	m	struct:lockInfo	file:
locktype	os_unix.c	/^  unsigned char locktype;   \/* The type of lock held on this fd *\/$/;"	m	struct:unixFile	file:
locktype	os_win.c	/^  unsigned char locktype; \/* Type of lock currently held on this file *\/$/;"	m	struct:winFile	file:
locktypeName	os_unix.c	/^static const char *locktypeName(int locktype){$/;"	f	file:
lookupName	expr.c	/^static int lookupName($/;"	f	file:
lowerFunc	func.c	/^static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
lp	parse.y	/^lp ::= LP(X).                       {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
lru	pager.c	/^  PagerLruList lru;           \/* LRU list of free pages *\/$/;"	m	struct:Pager	file:
lru	vdbeInt.h	/^  int lru;              \/* Counter used for LRU cache replacement *\/$/;"	m	struct:Vdbe
lruListAdd	pager.c	/^static void lruListAdd(PgHdr *pPg){$/;"	f	file:
lruListRemove	pager.c	/^static void lruListRemove(PgHdr *pPg){$/;"	f	file:
lruListSetFirstSynced	pager.c	/^static void lruListSetFirstSynced(Pager *pPager){$/;"	f	file:
m	date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
magic	sqliteInt.h	/^  int magic;                    \/* Magic number for detect library misuse *\/$/;"	m	struct:sqlite3
magic	vdbeInt.h	/^  int magic;              \/* Magic number for sanity checking *\/$/;"	m	struct:Vdbe
main	shell.c	/^int main(int argc, char **argv){$/;"	f
mainPrompt	shell.c	/^static char mainPrompt[20];     \/* First line prompt. default: "sqlite> "*\/$/;"	v	file:
main_init	shell.c	/^static void main_init(struct callback_data *data) {$/;"	f	file:
makeClean	pager.c	/^static void makeClean(PgHdr *pPg){$/;"	f	file:
makeDirty	pager.c	/^static void makeDirty(PgHdr *pPg){$/;"	f	file:
malloc	sqlite3ext.h	/^  void *(*malloc)(int);$/;"	m	struct:sqlite3_api_routines
mallocFailed	sqliteInt.h	/^  u8   mallocFailed;   \/* Becomes true if any memory allocation fails *\/$/;"	m	struct:StrAccum
mallocFailed	sqliteInt.h	/^  u8 mallocFailed;              \/* True if we have seen a malloc failure *\/$/;"	m	struct:sqlite3
matchAll	func.c	/^  u8 matchAll;$/;"	m	struct:compareInfo	file:
matchOne	func.c	/^  u8 matchOne;$/;"	m	struct:compareInfo	file:
matchOrderByTermToExprList	select.c	/^static int matchOrderByTermToExprList($/;"	f	file:
matchSet	func.c	/^  u8 matchSet;$/;"	m	struct:compareInfo	file:
maxEmbedFrac	btreeInt.h	/^  u8 maxEmbedFrac;      \/* Maximum payload as % of total page size *\/$/;"	m	struct:BtShared
maxLeaf	btreeInt.h	/^  int maxLeaf;          \/* Maximum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
maxLocal	btreeInt.h	/^  int maxLocal;         \/* Maximum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
maxLocal	btreeInt.h	/^  u16 maxLocal;        \/* Copy of BtShared.maxLocal or BtShared.maxLeaf *\/$/;"	m	struct:MemPage
maxStmt	tclsqlite.c	/^  int maxStmt;               \/* The next maximum number of stmtList *\/$/;"	m	struct:SqliteDb	file:
mbcsToUnicode	os_win.c	/^static WCHAR *mbcsToUnicode(const char *zFilename){$/;"	f	file:
mbcsToUtf8	os_win.c	/^static char *mbcsToUtf8(const char *zFilename){$/;"	f	file:
md5_cmd	test_md5.c	/^static int md5_cmd(void*cd, Tcl_Interp *interp, int argc, const char **argv){$/;"	f	file:
md5file_cmd	test_md5.c	/^static int md5file_cmd(void*cd, Tcl_Interp*interp, int argc, const char **argv){$/;"	f	file:
md5finalize	test_md5.c	/^static void md5finalize(sqlite3_context *context){$/;"	f	file:
md5step	test_md5.c	/^static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
mem	mem1.c	/^} mem;$/;"	v	typeref:struct:__anon1	file:
mem	mem2.c	/^} mem;$/;"	v	typeref:struct:__anon5	file:
mem	mem3.c	/^} mem;$/;"	v	typeref:struct:__anon11	file:
mem	mem4.c	/^} mem;$/;"	v	typeref:struct:__anon7	file:
memDb	pager.c	/^  u8 memDb;                   \/* True to inhibit all file I\/O *\/$/;"	m	struct:Pager	file:
memTracePrint	vdbe.c	/^static void memTracePrint(FILE *out, Mem *p){$/;"	f	file:
memory_highwater	sqlite3ext.h	/^  sqlite3_int64 (*memory_highwater)(int);$/;"	m	struct:sqlite3_api_routines
memory_used	sqlite3ext.h	/^  sqlite3_int64 (*memory_used)(void);$/;"	m	struct:sqlite3_api_routines
memsys3Checkout	mem3.c	/^static void *memsys3Checkout(u32 i, int nBlock){$/;"	f	file:
memsys3Enter	mem3.c	/^static void memsys3Enter(void){$/;"	f	file:
memsys3Free	mem3.c	/^void memsys3Free(void *pOld){$/;"	f
memsys3FromMaster	mem3.c	/^static void *memsys3FromMaster(int nBlock){$/;"	f	file:
memsys3Link	mem3.c	/^static void memsys3Link(u32 i){$/;"	f	file:
memsys3LinkIntoList	mem3.c	/^static void memsys3LinkIntoList(u32 i, u32 *pRoot){$/;"	f	file:
memsys3Malloc	mem3.c	/^static void *memsys3Malloc(int nByte){$/;"	f	file:
memsys3Merge	mem3.c	/^static void memsys3Merge(u32 *pRoot){$/;"	f	file:
memsys3OutOfMemory	mem3.c	/^static void memsys3OutOfMemory(int nByte){$/;"	f	file:
memsys3Size	mem3.c	/^static int memsys3Size(void *p){$/;"	f	file:
memsys3Unlink	mem3.c	/^static void memsys3Unlink(u32 i){$/;"	f	file:
memsys3UnlinkFromList	mem3.c	/^static void memsys3UnlinkFromList(u32 i, u32 *pRoot){$/;"	f	file:
memsys4Enter	mem4.c	/^static void memsys4Enter(void){$/;"	f	file:
memsys4Free	mem4.c	/^static void memsys4Free(void *pPrior){$/;"	f	file:
memsys4Malloc	mem4.c	/^static void *memsys4Malloc(int nBytes){$/;"	f	file:
memsys4Size	mem4.c	/^static int memsys4Size(void *pPrior){$/;"	f	file:
merge_pagelist	pager.c	/^static PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB){$/;"	f	file:
minEmbedFrac	btreeInt.h	/^  u8 minEmbedFrac;      \/* Minimum payload as % of total page size *\/$/;"	m	struct:BtShared
minLeaf	btreeInt.h	/^  int minLeaf;          \/* Minimum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
minLeafFrac	btreeInt.h	/^  u8 minLeafFrac;       \/* Minimum leaf payload as % of total page size *\/$/;"	m	struct:BtShared
minLocal	btreeInt.h	/^  int minLocal;         \/* Minimum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
minLocal	btreeInt.h	/^  u16 minLocal;        \/* Copy of BtShared.minLocal or BtShared.minLeaf *\/$/;"	m	struct:MemPage
minMaxFinalize	func.c	/^static void minMaxFinalize(sqlite3_context *context){$/;"	f	file:
minMaxQuery	select.c	/^static int minMaxQuery(Parse *pParse, Select *p){$/;"	f	file:
minWriteFileFormat	vdbeInt.h	/^  u8 minWriteFileFormat;  \/* Minimum file format for writable database files *\/$/;"	m	struct:Vdbe
minmaxFunc	func.c	/^static void minmaxFunc($/;"	f	file:
minmaxStep	func.c	/^static void minmaxStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
mmapAlloc	mem4.c	/^static void *mmapAlloc(int nBytes){$/;"	f	file:
mmapFree	mem4.c	/^static int mmapFree(void *p){$/;"	f	file:
mmapHeap	mem4.c	/^  char *mmapHeap;   \/* first byte of the heap *\/ $/;"	m	struct:__anon7	file:
mmapUnmap	mem4.c	/^static void mmapUnmap(void){$/;"	f	file:
mnMaster	mem3.c	/^  u32 mnMaster;$/;"	m	struct:__anon11	file:
mnPage	mem4.c	/^  int mnPage;$/;"	m	struct:__anon7	file:
mode	shell.c	/^  int mode;              \/* An output mode setting *\/$/;"	m	struct:callback_data	file:
mode	shell.c	/^  int mode;$/;"	m	struct:previous_mode_data	file:
modeDescr	shell.c	/^static const char *modeDescr[MODE_NUM_OF] = {$/;"	v	file:
modifyPagePointer	btree.c	/^static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){$/;"	f	file:
moduleDestroy	test8.c	/^static void moduleDestroy(void *p){$/;"	f	file:
moveToChild	btree.c	/^static int moveToChild(BtCursor *pCur, u32 newPgno){$/;"	f	file:
moveToLeftmost	btree.c	/^static int moveToLeftmost(BtCursor *pCur){$/;"	f	file:
moveToRightmost	btree.c	/^static int moveToRightmost(BtCursor *pCur){$/;"	f	file:
moveToRoot	btree.c	/^static int moveToRoot(BtCursor *pCur){$/;"	f	file:
movetoTarget	vdbeInt.h	/^  i64 movetoTarget;     \/* Argument to the deferred sqlite3BtreeMoveto() *\/$/;"	m	struct:Cursor
mprintf	sqlite3ext.h	/^  char * (*mprintf)(const char*,...);$/;"	m	struct:sqlite3_api_routines
multiSelect	select.c	/^static int multiSelect($/;"	f	file:
multiSelectCollSeq	select.c	/^static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){$/;"	f	file:
mutex	btreeInt.h	/^  sqlite3_mutex *mutex; \/* Non-recursive mutex required to access this struct *\/$/;"	m	struct:BtShared
mutex	mem1.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon1	file:
mutex	mem2.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon5	file:
mutex	mem3.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon11	file:
mutex	mem4.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon7	file:
mutex	mutex_os2.c	/^  HMTX mutex;       \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	mutex_unix.c	/^  pthread_mutex_t mutex;     \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	mutex_w32.c	/^  CRITICAL_SECTION mutex;    \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	sqliteInt.h	/^  sqlite3_mutex *mutex;         \/* Connection mutex *\/$/;"	m	struct:sqlite3
mutexIsNT	mutex_w32.c	/^  static int mutexIsNT(void){$/;"	f	file:
mutexIsNT	mutex_w32.c	46;"	d	file:
mutexName	mutex_os2.c	/^  PSZ  mutexName;   \/* Mutex name controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex_alloc	sqlite3ext.h	/^  sqlite3_mutex *(*mutex_alloc)(int);$/;"	m	struct:sqlite3_api_routines
mutex_enter	sqlite3ext.h	/^  void (*mutex_enter)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_free	sqlite3ext.h	/^  void (*mutex_free)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_leave	sqlite3ext.h	/^  void (*mutex_leave)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_try	sqlite3ext.h	/^  int (*mutex_try)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mxErr	btreeInt.h	/^  int mxErr;        \/* Stop accumulating errors when this reaches zero *\/$/;"	m	struct:IntegrityCk
mxPage	pager.c	/^  int mxPage;                 \/* Maximum number of pages to hold in cache *\/$/;"	m	struct:Pager	file:
mxPgno	pager.c	/^  Pgno mxPgno;                \/* Maximum allowed size of the database *\/$/;"	m	struct:Pager	file:
mxUsed	mem1.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon1	file:
mxUsed	mem2.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon5	file:
mxUsed	mem4.c	/^  sqlite3_int64 mxUsed;$/;"	m	struct:__anon7	file:
mxUsedMMap	mem4.c	/^  sqlite3_int64 mxUsedMMap;$/;"	m	struct:__anon7	file:
n	func.c	/^  i64 n;$/;"	m	struct:CountCtx	file:
n	sqliteInt.h	/^  unsigned n    : 31;     \/* Number of characters in this token *\/$/;"	m	struct:Token
n	test1.c	/^  int n;$/;"	m	struct:t1CountCtx	file:
n	vdbeInt.h	/^  int n;              \/* Number of characters in string value, excluding '\\0' *\/$/;"	m	struct:Mem
n	where.c	/^  int n;                        \/* Number of assigned cursor values *\/$/;"	m	struct:ExprMaskSet	file:
nAccumulator	sqliteInt.h	/^  int nAccumulator;       \/* Number of columns that show through to the output.$/;"	m	struct:AggInfo
nAlloc	sqliteInt.h	/^  i16 nAlloc;      \/* Number of entries allocated in a[] below *\/$/;"	m	struct:SrcList
nAlloc	sqliteInt.h	/^  int  nAlloc;     \/* Amount of space allocated in zText *\/$/;"	m	struct:StrAccum
nAlloc	sqliteInt.h	/^  int nAlloc;            \/* Number of entries allocated below *\/$/;"	m	struct:ExprList
nAlloc	sqliteInt.h	/^  int nAlloc;      \/* Number of entries allocated for a[] below *\/$/;"	m	struct:IdList
nAlloc	table.c	/^  int nAlloc;$/;"	m	struct:TabResult	file:
nAlloc	test1.c	/^  int nAlloc;  \/* Space allocated *\/$/;"	m	struct:dstr	file:
nAlloc	test_onefile.c	/^  int nAlloc;$/;"	m	struct:tmp_file	file:
nArg	sqliteInt.h	/^  i16 nArg;            \/* Number of arguments.  -1 means unlimited *\/$/;"	m	struct:FuncDef
nAux	vdbeInt.h	/^  int nAux;                     \/* Number of entries allocated for apAux[] *\/$/;"	m	struct:VdbeFunc
nBacktrace	mem2.c	/^  char nBacktrace;                    \/* Number of backtraces on this alloc *\/$/;"	m	struct:MemBlockHdr	file:
nBacktrace	mem2.c	/^  int nBacktrace;$/;"	m	struct:__anon5	file:
nBacktraceSlots	mem2.c	/^  char nBacktraceSlots;               \/* Available backtrace slots *\/$/;"	m	struct:MemBlockHdr	file:
nBenign	fault.c	/^  int nBenign;      \/* Number of benign failures seen since last config *\/$/;"	m	struct:FaultInjector	file:
nBlob	test_onefile.c	/^  int nBlob;                  \/* Total size of allocated blob *\/$/;"	m	struct:fs_real_file	file:
nBuf	journal.c	/^  int nBuf;                       \/* Size of zBuf[] in bytes *\/$/;"	m	struct:JournalFile	file:
nBuf	test6.c	/^  int nBuf;                    \/* Number of bytes written *\/$/;"	m	struct:WriteBuffer	file:
nBusy	sqliteInt.h	/^  int nBusy;                 \/* Incremented with each busy call *\/$/;"	m	struct:BusyHandler
nByte	test_async.c	/^  int nByte;          \/* See above *\/$/;"	m	struct:AsyncWrite	file:
nByte	test_server.c	/^  int nByte;                   \/* Size of the zIn parameter for prepare() *\/$/;"	m	struct:SqlMessage	file:
nByte	vdbeblob.c	/^  int nByte;              \/* Size of open blob, in bytes *\/$/;"	m	struct:Incrblob	file:
nCallback	vdbeInt.h	/^  int nCallback;          \/* Number of callbacks invoked so far *\/$/;"	m	struct:Vdbe
nCell	btreeInt.h	/^  u16 nCell;           \/* Number of cells on this page, local and ovfl *\/$/;"	m	struct:MemPage
nChange	sqliteInt.h	/^  int nChange;                  \/* Value returned by sqlite3_changes() *\/$/;"	m	struct:sqlite3
nChange	vdbeInt.h	/^  int nChange;            \/* Number of db changes made since last reset *\/$/;"	m	struct:Vdbe
nChange	vdbeInt.h	/^  int nChange;      \/* Statement changes (Vdbe.nChanges)     *\/$/;"	m	struct:Context
nChar	sqliteInt.h	/^  int  nChar;      \/* Length of the string so far *\/$/;"	m	struct:StrAccum
nChild	where.c	/^  u8 nChild;              \/* Number of children that must disable us *\/$/;"	m	struct:WhereTerm	file:
nCol	sqliteInt.h	/^  int nCol;         \/* Number of columns in this key *\/$/;"	m	struct:FKey
nCol	sqliteInt.h	/^  int nCol;        \/* Number of columns in this table *\/$/;"	m	struct:Table
nCol	test8.c	/^  int nCol;               \/* Number of columns in the real table *\/$/;"	m	struct:echo_vtab	file:
nColumn	sqliteInt.h	/^  int nColumn;            \/* Number of used entries in aCol[] *\/$/;"	m	struct:AggInfo
nColumn	sqliteInt.h	/^  int nColumn;     \/* Number of columns in the table used by this index *\/$/;"	m	struct:Index
nColumn	table.c	/^  int nColumn;$/;"	m	struct:TabResult	file:
nColumnAlloc	sqliteInt.h	/^  int nColumnAlloc;       \/* Number of slots allocated for aCol[] *\/$/;"	m	struct:AggInfo
nCursor	vdbeInt.h	/^  int nCursor;        \/* Number of slots in apCsr[] *\/$/;"	m	struct:Vdbe
nData	btreeInt.h	/^  u32 nData;     \/* Number of bytes of data *\/$/;"	m	struct:CellInfo
nData	table.c	/^  int nData;$/;"	m	struct:TabResult	file:
nData	test6.c	/^  int nData;                           \/* Size of buffer allocated at zData *\/$/;"	m	struct:CrashFile	file:
nData	vdbeInt.h	/^  int nData;            \/* Number of bytes in pData *\/$/;"	m	struct:Cursor
nDatabase	test_onefile.c	/^  int nDatabase;              \/* Current size of database region *\/$/;"	m	struct:fs_real_file	file:
nDb	sqliteInt.h	/^  int nDb;                      \/* Number of backends currently in use *\/$/;"	m	struct:sqlite3
nDepth	sqliteInt.h	/^  int nDepth;          \/* Depth of subquery recursion. 1 for no recursion *\/$/;"	m	struct:NameContext
nEntry	vdbeInt.h	/^  int nEntry;         \/* Total number of entries *\/$/;"	m	struct:Fifo
nEq	sqliteInt.h	/^  int nEq;              \/* Number of == or IN constraints on this loop *\/$/;"	m	struct:WhereLevel
nErr	btreeInt.h	/^  int nErr;         \/* Number of messages written to zErrMsg so far *\/$/;"	m	struct:IntegrityCk
nErr	sqliteInt.h	/^  int nErr;            \/* Number of errors encountered while resolving names *\/$/;"	m	struct:NameContext
nErr	sqliteInt.h	/^  int nErr;            \/* Number of errors seen *\/$/;"	m	struct:Parse
nExpr	sqliteInt.h	/^  int nExpr;             \/* Number of expressions on the list *\/$/;"	m	struct:ExprList
nExt	loadext.c	/^  int nExt;        \/* Number of entries in aExt[] *\/          $/;"	m	struct:__anon13	file:
nExtension	sqliteInt.h	/^  int nExtension;               \/* Number of loaded extensions *\/$/;"	m	struct:sqlite3
nExtra	pager.c	/^  int nExtra;                 \/* Add this many bytes to each in-memory page *\/$/;"	m	struct:Pager	file:
nFail	fault.c	/^  int nFail;        \/* Number of failures seen since last config *\/$/;"	m	struct:FaultInjector	file:
nField	sqliteInt.h	/^  int nField;         \/* Number of entries in aColl[] *\/$/;"	m	struct:KeyInfo
nField	vdbeInt.h	/^  int nField;           \/* Number of fields in the header *\/$/;"	m	struct:Cursor
nFile	test_async.c	/^  int nFile;                   \/* Number of open files (from sqlite pov) *\/$/;"	m	struct:TestAsyncStaticData	file:
nFree	btreeInt.h	/^  u16 nFree;           \/* Number of free bytes on the page *\/$/;"	m	struct:MemPage
nFunc	sqliteInt.h	/^  int nFunc;              \/* Number of entries in aFunc[] *\/$/;"	m	struct:AggInfo
nFuncAlloc	sqliteInt.h	/^  int nFuncAlloc;         \/* Number of slots allocated for aFunc[] *\/$/;"	m	struct:AggInfo
nHash	pager.c	/^  int nHash;                  \/* Size of the pager hash table *\/$/;"	m	struct:Pager	file:
nHeader	btreeInt.h	/^  u16 nHeader;   \/* Size of the cell content header in bytes *\/$/;"	m	struct:CellInfo
nHeight	sqliteInt.h	/^  int nHeight;            \/* Expression tree height of current sub-select *\/$/;"	m	struct:Parse
nHeight	sqliteInt.h	/^  int nHeight;           \/* Height of the tree headed by this node *\/$/;"	m	struct:Expr
nHit	pager.c	/^  int nHit, nMiss;            \/* Cache hits and missing *\/$/;"	m	struct:Pager	file:
nId	sqliteInt.h	/^  int nId;         \/* Number of identifiers on the list *\/$/;"	m	struct:IdList
nIn	sqliteInt.h	/^  int nIn;              \/* Number of IN operators constraining this loop *\/$/;"	m	struct:WhereLevel
nJournal	test_onefile.c	/^  int nJournal;               \/* Current size of journal region *\/$/;"	m	struct:fs_real_file	file:
nKey	btreeInt.h	/^  i64 nKey;        \/* Size of pKey, or last integer key *\/$/;"	m	struct:BtCursor
nKey	btreeInt.h	/^  i64 nKey;      \/* The key for INTKEY tables, or number of bytes in key *\/$/;"	m	struct:CellInfo
nKey	hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
nLabel	vdbeInt.h	/^  int nLabel;         \/* Number of labels used *\/$/;"	m	struct:Vdbe
nLabelAlloc	vdbeInt.h	/^  int nLabelAlloc;    \/* Number of slots allocated in aLabel[] *\/$/;"	m	struct:Vdbe
nLevel	sqliteInt.h	/^  int nLevel;          \/* Number of nested loop *\/$/;"	m	struct:WhereInfo
nLocal	btreeInt.h	/^  u16 nLocal;    \/* Amount of payload held locally *\/$/;"	m	struct:CellInfo
nLock	os_unix.c	/^  int nLock;            \/* Number of outstanding locks *\/$/;"	m	struct:openCnt	file:
nMem	sqliteInt.h	/^  int nMem;            \/* Number of memory cells used so far *\/$/;"	m	struct:Parse
nMem	vdbeInt.h	/^  int nMem;               \/* Number of memory locations currently allocated *\/$/;"	m	struct:Vdbe
nMiss	pager.c	/^  int nHit, nMiss;            \/* Cache hits and missing *\/$/;"	m	struct:Pager	file:
nModuleArg	sqliteInt.h	/^  int nModuleArg;           \/* Number of arguments to the module *\/$/;"	m	struct:Table
nMutex	btree.h	/^  int nMutex;$/;"	m	struct:BtreeMutexArray
nName	test_async.c	/^  int nName;                 \/* Number of characters in zName *\/$/;"	m	struct:AsyncFileData	file:
nOp	vdbeInt.h	/^  int nOp;            \/* Number of instructions in the program *\/$/;"	m	struct:Vdbe
nOpAlloc	vdbeInt.h	/^  int nOpAlloc;       \/* Number of slots allocated for aOp[] *\/$/;"	m	struct:Vdbe
nOverflow	btreeInt.h	/^  u8 nOverflow;        \/* Number of overflow cell bodies in aCell[] *\/$/;"	m	struct:MemPage
nPage	btreeInt.h	/^  int nPage;        \/* Number of pages in the database *\/$/;"	m	struct:IntegrityCk
nPage	mem4.c	/^  int nPage;$/;"	m	struct:__anon7	file:
nPage	pager.c	/^  int nPage;                  \/* Total number of in-memory pages *\/$/;"	m	struct:Pager	file:
nPayload	btreeInt.h	/^  u32 nPayload;  \/* Total amount of payload *\/$/;"	m	struct:CellInfo
nPending	os_unix.c	/^  int nPending;         \/* Number of pending close() operations *\/$/;"	m	struct:openCnt	file:
nProgressOps	sqliteInt.h	/^  int nProgressOps;             \/* Number of opcodes for progress callback *\/$/;"	m	struct:sqlite3
nQPlan	where.c	/^static int nQPlan = 0;              \/* Next free slow in _query_plan[] *\/$/;"	v	file:
nRangeReg	sqliteInt.h	/^  int nRangeReg;       \/* Size of the temporary register block *\/$/;"	m	struct:Parse
nRead	pager.c	/^  int nRead, nWrite;          \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
nReaders	os_win.c	/^  int nReaders;       \/* Number of reader locks obtained *\/$/;"	m	struct:winceLock	file:
nRec	pager.c	/^  int nRec;                   \/* Number of pages written to the journal *\/$/;"	m	struct:Pager	file:
nRef	btreeInt.h	/^  int nRef;             \/* Number of references to this structure *\/$/;"	m	struct:BtShared
nRef	mutex_os2.c	/^  int  nRef;        \/* Number of references *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	mutex_unix.c	/^  int nRef;                  \/* Number of entrances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	mutex_w32.c	/^  int nRef;                  \/* Number of enterances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	os_unix.c	/^  int nRef;             \/* Number of pointers to this structure *\/$/;"	m	struct:openCnt	file:
nRef	os_unix.c	/^  int nRef;            \/* Number of pointers to this structure *\/$/;"	m	struct:lockInfo	file:
nRef	pager.c	/^  int nRef;                   \/* Number of in-memory pages with PgHdr.nRef>0 *\/$/;"	m	struct:Pager	file:
nRef	pager.c	/^  short int nRef;                \/* Number of users of this page *\/$/;"	m	struct:PgHdr	file:
nRef	sqliteInt.h	/^  int nRef;            \/* Number of names resolved by this context *\/$/;"	m	struct:NameContext
nRef	sqliteInt.h	/^  int nRef;          \/* Number of pointers to this Table *\/$/;"	m	struct:Table
nRef	test_onefile.c	/^  int nRef;                   \/* Number of pointers to this structure *\/$/;"	m	struct:fs_real_file	file:
nRefSqlite3	test3.c	/^static int nRefSqlite3 = 0;$/;"	v	file:
nRepeat	fault.c	/^  int nRepeat;      \/* Number of times to repeat the failure *\/$/;"	m	struct:FaultInjector	file:
nResColumn	vdbeInt.h	/^  int nResColumn;         \/* Number of columns in one row of the result set *\/$/;"	m	struct:Vdbe
nResult	table.c	/^  int nResult;$/;"	m	struct:TabResult	file:
nRow	table.c	/^  int nRow;$/;"	m	struct:TabResult	file:
nSet	sqliteInt.h	/^  int nSet;            \/* Number of sets used so far *\/$/;"	m	struct:Parse
nSize	btreeInt.h	/^  u16 nSize;     \/* Size of the cell content on the main b-tree page *\/$/;"	m	struct:CellInfo
nSize	test_onefile.c	/^  int nSize;$/;"	m	struct:tmp_file	file:
nSlot	vdbeInt.h	/^  int nSlot;         \/* Number of entries aSlot[] *\/$/;"	m	struct:FifoPage
nSlot	where.c	/^  int nSlot;               \/* Number of entries in a[] *\/$/;"	m	struct:WhereClause	file:
nSortingColumn	sqliteInt.h	/^  int nSortingColumn;     \/* Number of columns in the sorting index *\/$/;"	m	struct:AggInfo
nSql	tclsqlite.c	/^  int nSql;                \/* chars in zSql[] *\/$/;"	m	struct:SqlPreparedStmt	file:
nSql	vdbeInt.h	/^  int nSql;             \/* Number of bytes in zSql *\/$/;"	m	struct:Vdbe
nSrc	sqliteInt.h	/^  i16 nSrc;        \/* Number of tables or subqueries in the FROM clause *\/$/;"	m	struct:SrcList
nStmt	tclsqlite.c	/^  int nStmt;                 \/* Number of statements in stmtList *\/$/;"	m	struct:SqliteDb	file:
nTab	sqliteInt.h	/^  int nTab;            \/* Number of previously allocated VDBE cursors *\/$/;"	m	struct:Parse
nTable	sqliteInt.h	/^  int nTable;                   \/* Number of tables in the database *\/$/;"	m	struct:sqlite3
nTableLock	sqliteInt.h	/^  int nTableLock;        \/* Number of locks in aTableLock *\/$/;"	m	struct:Parse
nTempInUse	sqliteInt.h	/^  u8 nTempInUse;       \/* Number of aTempReg[] currently checked out *\/$/;"	m	struct:Parse
nTempReg	sqliteInt.h	/^  u8 nTempReg;         \/* Number of temporary registers in aTempReg[] *\/$/;"	m	struct:Parse
nTerm	where.c	/^  int nTerm;               \/* Number of terms *\/$/;"	m	struct:WhereClause	file:
nTitle	mem2.c	/^  int nTitle;        \/* Bytes of zTitle to save.  Includes '\\0' and padding *\/$/;"	m	struct:__anon5	file:
nTitle	mem2.c	/^  short nTitle;                       \/* Bytes of title; includes '\\0' *\/$/;"	m	struct:MemBlockHdr	file:
nTotalChange	sqliteInt.h	/^  int nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/$/;"	m	struct:sqlite3
nTransaction	btreeInt.h	/^  int nTransaction;     \/* Number of open transactions (read + write) *\/$/;"	m	struct:BtShared
nTrunc	btreeInt.h	/^  Pgno nTrunc;          \/* Non-zero if the db will be truncated (incr vacuum) *\/$/;"	m	struct:BtShared
nUsed	test1.c	/^  int nUsed;   \/* Space used *\/$/;"	m	struct:dstr	file:
nVTrans	sqliteInt.h	/^  int nVTrans;                  \/* Allocated size of aVTrans *\/$/;"	m	struct:sqlite3
nVar	sqliteInt.h	/^  int nVar;            \/* Number of '?' variables seen in the SQL so far *\/$/;"	m	struct:Parse
nVar	vdbeInt.h	/^  int nVar;           \/* Number of entries in aVar[] *\/$/;"	m	struct:Vdbe
nVarExpr	sqliteInt.h	/^  int nVarExpr;        \/* Number of used slots in apVarExpr[] *\/$/;"	m	struct:Parse
nVarExprAlloc	sqliteInt.h	/^  int nVarExprAlloc;   \/* Number of allocated slots in apVarExpr[] *\/$/;"	m	struct:Parse
nWrite	pager.c	/^  int nRead, nWrite;          \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
name	sqliteInt.h	/^  char *name;             \/* The name of the trigger                        *\/$/;"	m	struct:Trigger
nameClash	sqliteInt.h	/^  u8 nameClash;        \/* A permanent table name clashes with temp table name *\/$/;"	m	struct:Parse
nameResolverStep	expr.c	/^static int nameResolverStep(void *pArg, Expr *pExpr){$/;"	f	file:
nameToken	sqliteInt.h	/^  Token nameToken;        \/* Token containing zName. Use during parsing only *\/$/;"	m	struct:Trigger
name_to_enc	test5.c	/^static u8 name_to_enc(Tcl_Interp *interp, Tcl_Obj *pObj){$/;"	f	file:
needCollSeq	sqliteInt.h	/^  u8 needCollSeq;      \/* True if sqlite3GetFuncCollSeq() might be called *\/$/;"	m	struct:FuncDef
needCsvQuote	shell.c	/^static const char needCsvQuote[] = {$/;"	v	file:
needRead	pager.c	/^  u8 needRead;                   \/* Read content if PagerWrite() is called *\/$/;"	m	struct:PgHdr	file:
needSync	pager.c	/^  u8 needSync;                   \/* Sync journal before writing this page *\/$/;"	m	struct:PgHdr	file:
needSync	pager.c	/^  u8 needSync;                \/* True if an fsync() is needed on the journal *\/$/;"	m	struct:Pager	file:
nested	sqliteInt.h	/^  u8 nested;           \/* Number of nested calls to the parser\/code generator *\/$/;"	m	struct:Parse
newColMask	sqliteInt.h	/^  u32 newColMask;$/;"	m	struct:TriggerStack
newDatabase	btree.c	/^static int newDatabase(BtShared *pBt){$/;"	f	file:
newIdx	sqliteInt.h	/^  int newIdx;          \/* Index of vdbe cursor to "new" temp table *\/$/;"	m	struct:TriggerStack
newTnum	sqliteInt.h	/^    int newTnum;                \/* Rootpage of table being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
next	hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
next	mem3.c	/^      u32 next;       \/* Index in mem.aPool[] of next free chunk *\/$/;"	m	struct:Mem3Block::__anon8::__anon10	file:
next2	test_tclvar.c	/^static int next2(Tcl_Interp *interp, tclvar_cursor *pCur, Tcl_Obj *pObj){$/;"	f	file:
nextAutovac	sqliteInt.h	/^  signed char nextAutovac;      \/* Autovac setting after VACUUM if >=0 *\/$/;"	m	struct:sqlite3
nextRowid	vdbeInt.h	/^  i64 nextRowid;        \/* Next rowid returned by OP_NewRowid *\/$/;"	m	struct:Cursor
nextRowidValid	vdbeInt.h	/^  Bool nextRowidValid;  \/* True if the nextRowid field is valid *\/$/;"	m	struct:Cursor
noCase	func.c	/^  u8 noCase;$/;"	m	struct:compareInfo	file:
noLockingStyle	os_unix.c	/^        noLockingStyle,              \/* useful for read-only file system *\/$/;"	e	enum:__anon4	file:
noReadlock	pager.c	/^  u8 noReadlock;              \/* Do not bother to obtain readlocks *\/$/;"	m	struct:Pager	file:
noSync	pager.c	/^  u8 noSync;                  \/* Do not sync the journal if true *\/$/;"	m	struct:Pager	file:
nocaseCollatingFunc	main.c	/^static int nocaseCollatingFunc($/;"	f	file:
nolockLockingContext	os_unix.c	/^typedef void nolockLockingContext;$/;"	t	file:
nolockUnixCheckReservedLock	os_unix.c	/^static int nolockUnixCheckReservedLock(sqlite3_file *id) {$/;"	f	file:
nolockUnixClose	os_unix.c	/^static int nolockUnixClose(sqlite3_file *id) {$/;"	f	file:
nolockUnixLock	os_unix.c	/^static int nolockUnixLock(sqlite3_file *id, int locktype) {$/;"	f	file:
nolockUnixUnlock	os_unix.c	/^static int nolockUnixUnlock(sqlite3_file *id, int locktype) {$/;"	f	file:
notNull	sqliteInt.h	/^  u8 notNull;      \/* True if there is a NOT NULL constraint *\/$/;"	m	struct:Column
notUsed1	sqliteInt.h	/^    double notUsed1;            \/* Spacer *\/$/;"	m	union:sqlite3::__anon2
nowUsed	mem1.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon1	file:
nowUsed	mem2.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon5	file:
nowUsed	mem4.c	/^  sqlite3_int64 nowUsed;$/;"	m	struct:__anon7	file:
nowUsedMMap	mem4.c	/^  sqlite3_int64 nowUsedMMap;$/;"	m	struct:__anon7	file:
nullRow	vdbeInt.h	/^  Bool nullRow;         \/* True if pointing to a row with no data *\/$/;"	m	struct:Cursor
nullifFunc	func.c	/^static void nullifFunc($/;"	f	file:
nullvalue	shell.c	/^  char nullvalue[20];    \/* The text to print when a NULL comes back from$/;"	m	struct:callback_data	file:
nxt	sqliteInt.h	/^  int nxt;              \/* Jump here to start the next IN combination *\/$/;"	m	struct:WhereLevel
offset	os_unix.c	/^  unsigned long long offset;        \/* offset to first byte to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
offsetof	sqliteInt.h	230;"	d
okVar	vdbeInt.h	/^  int okVar;          \/* True if azVar[] has been initialized *\/$/;"	m	struct:Vdbe
oldColMask	sqliteInt.h	/^  u32 oldColMask;$/;"	m	struct:TriggerStack
oldIdx	sqliteInt.h	/^  int oldIdx;          \/* Index of vdbe cursor to "old" temp table *\/$/;"	m	struct:TriggerStack
onError	sqliteInt.h	/^  u8 onError;      \/* OE_Abort, OE_Ignore, OE_Replace, or OE_None *\/$/;"	m	struct:Index
one_input_line	shell.c	/^static char *one_input_line(const char *zPrior, FILE *in){$/;"	f	file:
op	sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
op	sqliteInt.h	/^  int op;              \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT *\/$/;"	m	struct:TriggerStep
op	sqliteInt.h	/^  u8 op;                  \/* One of TK_DELETE, TK_UPDATE, TK_INSERT         *\/$/;"	m	struct:Trigger
op	sqliteInt.h	/^  u8 op;                 \/* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT *\/$/;"	m	struct:Select
op	sqliteInt.h	/^  u8 op;                 \/* Operation performed by this node *\/$/;"	m	struct:Expr
op	test_async.c	/^  int op;                      \/* One of ASYNC_xxx etc. *\/$/;"	m	struct:AsyncWrite	file:
op	test_server.c	/^  int op;                      \/* Opcode for the message *\/$/;"	m	struct:SqlMessage	file:
opcode	vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOp
opcode	vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOpList
opcodeProperty	vdbe.c	/^static unsigned char opcodeProperty[] = OPFLG_INITIALIZER;$/;"	v	file:
open	sqlite3ext.h	/^  int  (*open)(const char*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
open16	sqlite3ext.h	/^  int  (*open16)(const void*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
openCnt	os_unix.c	/^struct openCnt {$/;"	s	file:
openDatabase	main.c	/^static int openDatabase($/;"	f	file:
openDirectory	os_unix.c	/^static int openDirectory(const char *zFilename, int *pFd){$/;"	f	file:
openFlags	sqliteInt.h	/^  int openFlags;                \/* Flags passed to sqlite3_vfs.xOpen() *\/$/;"	m	struct:sqlite3
openHash	os_unix.c	/^static Hash openHash = {SQLITE_HASH_BINARY, 0, 0, 0, 0, 0};$/;"	v	file:
openKey	os_unix.c	/^struct openKey {$/;"	s	file:
openStatTable	analyze.c	/^static void openStatTable($/;"	f	file:
open_db	shell.c	/^static void open_db(struct callback_data *p){$/;"	f	file:
open_v2	sqlite3ext.h	/^  int (*open_v2)(const char*,sqlite3**,int,const char*);$/;"	m	struct:sqlite3_api_routines
openedStatement	vdbeInt.h	/^  int openedStatement;  \/* True if this VM has opened a statement journal *\/$/;"	m	struct:Vdbe
operatorMask	where.c	/^static int operatorMask(int op){$/;"	f	file:
opnum	test4.c	/^  int opnum;             \/* Operation number *\/$/;"	m	struct:Thread	file:
opnum	test7.c	/^  volatile int opnum;      \/* Operation number *\/$/;"	m	struct:Thread	file:
orTermHasOkDuplicate	where.c	/^static int orTermHasOkDuplicate(WhereClause *pOr, WhereTerm *pOrTerm){$/;"	f	file:
orTermIsOptCandidate	where.c	/^static int orTermIsOptCandidate(WhereTerm *pOrTerm, int iCursor, int iColumn){$/;"	f	file:
orconf	sqliteInt.h	/^  int orconf;          \/* Current orconf policy *\/$/;"	m	struct:TriggerStack
orconf	sqliteInt.h	/^  int orconf;          \/* OE_Rollback etc. *\/$/;"	m	struct:TriggerStep
origDbSize	pager.c	/^  int origDbSize;             \/* dbSize before the current change *\/$/;"	m	struct:Pager	file:
os2Access	os_os2.c	/^static int os2Access($/;"	f	file:
os2CheckReservedLock	os_os2.c	/^int os2CheckReservedLock( sqlite3_file *id ){$/;"	f
os2Close	os_os2.c	/^int os2Close( sqlite3_file *id ){$/;"	f
os2CurrentTime	os_os2.c	/^int os2CurrentTime( sqlite3_vfs *pVfs, double *prNow ){$/;"	f
os2Delete	os_os2.c	/^int os2Delete($/;"	f
os2DeviceCharacteristics	os_os2.c	/^static int os2DeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
os2DlClose	os_os2.c	/^void os2DlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
os2DlClose	os_os2.c	857;"	d	file:
os2DlError	os_os2.c	/^static void os2DlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
os2DlError	os_os2.c	855;"	d	file:
os2DlOpen	os_os2.c	/^static void *os2DlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
os2DlOpen	os_os2.c	854;"	d	file:
os2DlSym	os_os2.c	/^void *os2DlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
os2DlSym	os_os2.c	856;"	d	file:
os2File	os_os2.c	/^struct os2File {$/;"	s	file:
os2File	os_os2.c	/^typedef struct os2File os2File;$/;"	t	typeref:struct:os2File	file:
os2FileControl	os_os2.c	/^static int os2FileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
os2FileSize	os_os2.c	/^int os2FileSize( sqlite3_file *id, sqlite3_int64 *pSize ){$/;"	f
os2FullPathname	os_os2.c	/^static int os2FullPathname($/;"	f	file:
os2GetTempname	os_os2.c	/^static int os2GetTempname( sqlite3_vfs *pVfs, int nBuf, char *zBuf ){$/;"	f	file:
os2IoMethod	os_os2.c	/^static const sqlite3_io_methods os2IoMethod = {$/;"	v	file:
os2Lock	os_os2.c	/^int os2Lock( sqlite3_file *id, int locktype ){$/;"	f
os2Open	os_os2.c	/^static int os2Open($/;"	f	file:
os2Randomness	os_os2.c	/^static int os2Randomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf ){$/;"	f	file:
os2Read	os_os2.c	/^int os2Read($/;"	f
os2SectorSize	os_os2.c	/^static int os2SectorSize(sqlite3_file *id){$/;"	f	file:
os2Sleep	os_os2.c	/^static int os2Sleep( sqlite3_vfs *pVfs, int microsec ){$/;"	f	file:
os2Sync	os_os2.c	/^int os2Sync( sqlite3_file *id, int flags ){$/;"	f
os2Truncate	os_os2.c	/^int os2Truncate( sqlite3_file *id, i64 nByte ){$/;"	f
os2Unlock	os_os2.c	/^int os2Unlock( sqlite3_file *id, int locktype ){$/;"	f
os2Write	os_os2.c	/^int os2Write($/;"	f
osUnlock	pager.c	/^static int osUnlock(sqlite3_file *pFd, int eLock){$/;"	f	file:
out	shell.c	/^  FILE *out;             \/* Write results here *\/$/;"	m	struct:callback_data	file:
outfile	shell.c	/^  char outfile[FILENAME_MAX]; \/* Filename for *out *\/$/;"	m	struct:callback_data	file:
output_c_string	shell.c	/^static void output_c_string(FILE *out, const char *z){$/;"	f	file:
output_csv	shell.c	/^static void output_csv(struct callback_data *p, const char *z, int bSep){$/;"	f	file:
output_html_string	shell.c	/^static void output_html_string(FILE *out, const char *z){$/;"	f	file:
output_quoted_string	shell.c	/^static void output_quoted_string(FILE *out, const char *z){$/;"	f	file:
overflow	func.c	/^  u8 overflow;      \/* True if integer overflow seen *\/$/;"	m	struct:SumCtx	file:
overload_function	sqlite3ext.h	/^  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);$/;"	m	struct:sqlite3_api_routines
overloadedGlobFunction	test8.c	/^static void overloadedGlobFunction($/;"	f	file:
owner	mutex_os2.c	/^  TID  owner;       \/* Thread holding this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
owner	mutex_unix.c	/^  pthread_t owner;           \/* Thread that is within this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
owner	mutex_w32.c	/^  DWORD owner;               \/* Thread holding this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
p	vdbe.h	/^    void *p;               \/* Generic pointer *\/$/;"	m	union:VdbeOp::__anon12
p1	sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p1	vdbe.h	/^  int p1;             \/* First operand *\/$/;"	m	struct:VdbeOp
p1	vdbe.h	/^  signed char p1;     \/* First operand *\/$/;"	m	struct:VdbeOpList
p2	sqliteInt.h	/^  int op, p1, p2;       \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p2	vdbe.h	/^  int p2;             \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOp
p2	vdbe.h	/^  signed char p2;     \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOpList
p3	vdbe.h	/^  int p3;             \/* The third parameter *\/$/;"	m	struct:VdbeOp
p3	vdbe.h	/^  signed char p3;     \/* Third parameter *\/$/;"	m	struct:VdbeOpList
p4	vdbe.h	/^  } p4;$/;"	m	struct:VdbeOp	typeref:union:VdbeOp::__anon12
p4type	vdbe.h	/^  signed char p4type; \/* One of the P4_xxx constants for p4 *\/$/;"	m	struct:VdbeOp
p5	vdbe.h	/^  u8 p5;              \/* Fifth parameter is an unsigned character *\/$/;"	m	struct:VdbeOp
pAggInfo	sqliteInt.h	/^  AggInfo *pAggInfo;     \/* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION *\/$/;"	m	struct:Expr
pAggInfo	sqliteInt.h	/^  AggInfo *pAggInfo;   \/* Information about aggregates at this level *\/$/;"	m	struct:NameContext
pAll	pager.c	/^  PgHdr *pAll;                \/* List of all pages *\/$/;"	m	struct:Pager	file:
pArg	btreeInt.h	/^  void *pArg;               \/* First arg to xCompare() *\/$/;"	m	struct:BtCursor
pArg	sqliteInt.h	/^  void *pArg;                \/* First arg to busy callback *\/$/;"	m	struct:BusyHandler
pAuthArg	sqliteInt.h	/^  void *pAuthArg;               \/* 1st argument to the access auth function *\/$/;"	m	struct:sqlite3
pAux	sqliteInt.h	/^  void *pAux;                          \/* pAux passed to create_module() *\/$/;"	m	struct:Module
pAux	sqliteInt.h	/^  void *pAux;               \/* Auxiliary data.  Usually NULL *\/$/;"	m	struct:Db
pAux	vdbeInt.h	/^    void *pAux;                   \/* Aux data for the i-th argument *\/$/;"	m	struct:VdbeFunc::AuxData
pBaseRead	test_async.c	/^  sqlite3_file *pBaseRead;   \/* Read handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBaseWrite	test_async.c	/^  sqlite3_file *pBaseWrite;  \/* Write handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBestIdx	sqliteInt.h	/^  sqlite3_index_info *pBestIdx;  \/* Index information for this level *\/$/;"	m	struct:WhereLevel
pBlob	tclsqlite.c	/^  sqlite3_blob *pBlob;      \/* sqlite3 blob handle *\/$/;"	m	struct:IncrblobChannel	file:
pBt	btreeInt.h	/^  BtShared *pBt;            \/* The BtShared this cursor points to *\/$/;"	m	struct:BtCursor
pBt	btreeInt.h	/^  BtShared *pBt;       \/* Pointer to BtShared that this page is part of *\/$/;"	m	struct:MemPage
pBt	btreeInt.h	/^  BtShared *pBt;     \/* Sharable content of this btree *\/$/;"	m	struct:Btree
pBt	btreeInt.h	/^  BtShared *pBt;    \/* The tree being checked out *\/$/;"	m	struct:IntegrityCk
pBt	sqliteInt.h	/^  Btree *pBt;          \/* The B*Tree structure for this database file *\/$/;"	m	struct:Db
pBt	vdbeInt.h	/^  Btree *pBt;           \/* Separate file holding temporary table *\/$/;"	m	struct:Cursor
pBtree	btreeInt.h	/^  Btree *pBtree;            \/* The Btree to which this cursor belongs *\/$/;"	m	struct:BtCursor
pBtree	btreeInt.h	/^  Btree *pBtree;        \/* Btree handle holding this lock *\/$/;"	m	struct:BtLock
pBusyHandler	pager.c	/^  BusyHandler *pBusyHandler;  \/* Pointer to sqlite.busyHandler *\/$/;"	m	struct:Pager	file:
pCell	btreeInt.h	/^    u8 *pCell;          \/* Pointers to the body of the overflow cell *\/$/;"	m	struct:MemPage::_OvflCell
pCell	btreeInt.h	/^  u8 *pCell;     \/* Pointer to the start of cell content *\/$/;"	m	struct:CellInfo
pCheck	sqliteInt.h	/^  Expr *pCheck;      \/* The AND of all CHECK constraints *\/$/;"	m	struct:Table
pCmp	test1.c	/^  Tcl_Obj *pCmp;$/;"	m	struct:TestCollationX	file:
pCodecArg	pager.c	/^  void *pCodecArg;            \/* First argument to xCodec() *\/$/;"	m	struct:Pager	file:
pColl	sqliteInt.h	/^  CollSeq *pColl;        \/* The collation type of the column or 0 *\/$/;"	m	struct:Expr
pColl	vdbe.h	/^    CollSeq *pColl;        \/* Used when p4type is P4_COLLSEQ *\/$/;"	m	union:VdbeOp::__anon12
pColl	vdbeInt.h	/^  CollSeq *pColl;       \/* Collating sequence *\/$/;"	m	struct:sqlite3_context
pCollNeededArg	sqliteInt.h	/^  void *pCollNeededArg;$/;"	m	struct:sqlite3
pCollate	tclsqlite.c	/^  SqlCollate *pCollate;      \/* List of SQL collation functions *\/$/;"	m	struct:SqliteDb	file:
pCollateNeeded	tclsqlite.c	/^  Tcl_Obj *pCollateNeeded;   \/* Collation needed script *\/$/;"	m	struct:SqliteDb	file:
pColumnList	test_schema.c	/^  sqlite3_stmt *pColumnList;$/;"	m	struct:schema_cursor	file:
pColumns	sqliteInt.h	/^  IdList *pColumns;       \/* If this is an UPDATE OF <column-list> trigger,$/;"	m	struct:Trigger
pCommitArg	sqliteInt.h	/^  void *pCommitArg;                 \/* Argument to xCommitCallback() *\/   $/;"	m	struct:sqlite3
pCsr	vdbeblob.c	/^  BtCursor *pCsr;         \/* Cursor pointing at blob row *\/$/;"	m	struct:Incrblob	file:
pCursor	btreeInt.h	/^  BtCursor *pCursor;    \/* A list of all open cursors *\/$/;"	m	struct:BtShared
pCursor	vdbeInt.h	/^  BtCursor *pCursor;    \/* The cursor structure of the backend *\/$/;"	m	struct:Cursor
pData	pager.c	/^  void *pData;                   \/* Page data *\/$/;"	m	struct:PgHdr	file:
pData	test_async.c	/^  AsyncFileData *pData;$/;"	m	struct:AsyncFile	file:
pData	vdbeInt.h	/^  char *pData;          \/* Data for a NEW or OLD pseudo-table *\/$/;"	m	struct:Cursor
pDb	tclsqlite.c	/^  SqliteDb *pDb;            \/* Associated database connection *\/$/;"	m	struct:IncrblobChannel	file:
pDb	test_server.c	/^  sqlite3 *pDb;                \/* The SQLite connection *\/$/;"	m	struct:SqlMessage	file:
pDbList	test_schema.c	/^  sqlite3_stmt *pDbList;$/;"	m	struct:schema_cursor	file:
pDbPage	btreeInt.h	/^  DbPage *pDbPage;     \/* Pager page handle *\/$/;"	m	struct:MemPage
pDef	vdbeInt.h	/^    FuncDef *pDef;      \/* Used only when flags==MEM_Agg *\/$/;"	m	union:Mem::__anon6
pDel	test1.c	/^  Tcl_Obj *pDel;$/;"	m	struct:TestCollationX	file:
pDflt	sqliteInt.h	/^  Expr *pDflt;     \/* Default value of this column *\/$/;"	m	struct:Column
pDfltColl	sqliteInt.h	/^  CollSeq *pDfltColl;           \/* The default collating sequence (BINARY) *\/$/;"	m	struct:sqlite3
pDirty	pager.c	/^  PgHdr *pDirty, *pPrevDirty;    \/* Dirty pages *\/$/;"	m	struct:PgHdr	file:
pDirty	pager.c	/^  PgHdr *pDirty;              \/* List of all dirty pages *\/$/;"	m	struct:Pager	file:
pEList	sqliteInt.h	/^  ExprList *pEList;      \/* The fields of the result *\/$/;"	m	struct:Select
pEList	sqliteInt.h	/^  ExprList *pEList;    \/* Optional list of named expressions *\/$/;"	m	struct:NameContext
pErr	sqliteInt.h	/^  sqlite3_value *pErr;          \/* Most recent error message *\/$/;"	m	struct:sqlite3
pExclusive	btreeInt.h	/^  Btree *pExclusive;    \/* Btree with an EXCLUSIVE lock on the whole db *\/$/;"	m	struct:BtShared
pExpr	sqliteInt.h	/^    Expr *pExpr;             \/* Expression encoding the function *\/$/;"	m	struct:AggInfo::AggInfo_func
pExpr	sqliteInt.h	/^    Expr *pExpr;             \/* The original expression *\/$/;"	m	struct:AggInfo::AggInfo_col
pExpr	sqliteInt.h	/^    Expr *pExpr;           \/* The list of expressions *\/$/;"	m	struct:ExprList::ExprList_item
pExpr	where.c	/^  Expr *pExpr;            \/* Pointer to the subexpression *\/$/;"	m	struct:WhereTerm	file:
pExprList	sqliteInt.h	/^  ExprList *pExprList; \/* Valid for UPDATE statements and sometimes $/;"	m	struct:TriggerStep
pFKey	sqliteInt.h	/^  FKey *pFKey;       \/* Linked list of all foreign keys in this table *\/$/;"	m	struct:Table
pFetch	sqliteInt.h	/^  sqlite3_stmt *pFetch;         \/* Used by SSE to fetch stored statements *\/$/;"	m	struct:sqlite3
pFile	test6.c	/^  CrashFile *pFile;            \/* File this write() applies to *\/$/;"	m	struct:WriteBuffer	file:
pFile	test_async.c	/^  sqlite3_file *pFile;$/;"	m	struct:AsyncLock	file:
pFile	test_onefile.c	/^  sqlite3_file *pFile;$/;"	m	struct:fs_real_file	file:
pFileData	test_async.c	/^  AsyncFileData *pFileData;    \/* File to write data to or sync *\/$/;"	m	struct:AsyncWrite	file:
pFileList	test_onefile.c	/^  fs_real_file *pFileList;$/;"	m	struct:fs_vfs_t	file:
pFirst	mem2.c	/^  struct MemBlockHdr *pFirst;$/;"	m	struct:__anon5	typeref:struct:__anon5::MemBlockHdr	file:
pFirst	pager.c	/^  PgHdr *pFirst;         \/* First page in LRU list *\/$/;"	m	struct:PagerLruList	file:
pFirst	vdbeInt.h	/^  FifoPage *pFirst;   \/* First page on the list *\/$/;"	m	struct:Fifo
pFirstSynced	pager.c	/^  PgHdr *pFirstSynced;   \/* First page in list with PgHdr.needSync==0 *\/$/;"	m	struct:PagerLruList	file:
pFrom	sqliteInt.h	/^  Table *pFrom;     \/* The table that constains the REFERENCES clause *\/$/;"	m	struct:FKey
pFunc	sqliteInt.h	/^    FuncDef *pFunc;          \/* The aggregate function implementation *\/$/;"	m	struct:AggInfo::AggInfo_func
pFunc	tclsqlite.c	/^  SqlFunc *pFunc;            \/* List of SQL functions *\/$/;"	m	struct:SqliteDb	file:
pFunc	vdbe.h	/^    FuncDef *pFunc;        \/* Used when p4type is P4_FUNCDEF *\/$/;"	m	union:VdbeOp::__anon12
pFunc	vdbeInt.h	/^  FuncDef *pFunc;               \/* The definition of the function *\/$/;"	m	struct:VdbeFunc
pFunc	vdbeInt.h	/^  FuncDef *pFunc;       \/* Pointer to function information.  MUST BE FIRST *\/$/;"	m	struct:sqlite3_context
pGroupBy	sqliteInt.h	/^  ExprList *pGroupBy;     \/* The group by clause *\/$/;"	m	struct:AggInfo
pGroupBy	sqliteInt.h	/^  ExprList *pGroupBy;    \/* The GROUP BY clause *\/$/;"	m	struct:Select
pHaving	sqliteInt.h	/^  Expr *pHaving;         \/* The HAVING clause *\/$/;"	m	struct:Select
pI64	vdbe.h	/^    i64 *pI64;             \/* Used when p4type is P4_INT64 *\/$/;"	m	union:VdbeOp::__anon12
pIdList	sqliteInt.h	/^  IdList *pIdList;     \/* Valid for INSERT statements only *\/$/;"	m	struct:TriggerStep
pIdx	sqliteInt.h	/^  Index *pIdx;          \/* Index used.  NULL if no index *\/$/;"	m	struct:WhereLevel
pIdxInfo	sqliteInt.h	/^  sqlite3_index_info *pIdxInfo;  \/* Index info for n-th source table *\/$/;"	m	struct:WhereLevel
pIncrKey	vdbeInt.h	/^  u8 *pIncrKey;         \/* Pointer to pKeyInfo->incrKey *\/$/;"	m	struct:Cursor
pIncrblob	tclsqlite.c	/^  IncrblobChannel *pIncrblob;\/* Linked list of open incrblob channels *\/$/;"	m	struct:SqliteDb	file:
pIndex	sqliteInt.h	/^  Index *pIndex;   \/* List of SQL indexes on this table. *\/$/;"	m	struct:Table
pKey	btreeInt.h	/^  void *pKey;      \/* Saved key that was cursor's last known position *\/$/;"	m	struct:BtCursor
pKey	hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
pKeyInfo	vdbe.h	/^    KeyInfo *pKeyInfo;     \/* Used when p4type is P4_KEYINFO *\/$/;"	m	union:VdbeOp::__anon12
pKeyInfo	vdbeInt.h	/^  KeyInfo *pKeyInfo;    \/* Info about index keys needed by index cursors *\/$/;"	m	struct:Cursor
pLast	mem2.c	/^  struct MemBlockHdr *pLast;$/;"	m	struct:__anon5	typeref:struct:__anon5::MemBlockHdr	file:
pLast	pager.c	/^  PgHdr *pLast;          \/* Last page in LRU list (the most recently used) *\/$/;"	m	struct:PagerLruList	file:
pLast	sqliteInt.h	/^  TriggerStep *pLast;  \/* Last element in link-list. Valid for 1st elem only *\/$/;"	m	struct:TriggerStep
pLast	vdbeInt.h	/^  FifoPage *pLast;    \/* Last page on the list *\/$/;"	m	struct:Fifo
pLeft	sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pLimit	sqliteInt.h	/^  Expr *pLimit;          \/* LIMIT expression. NULL means not used. *\/$/;"	m	struct:Select
pList	sqliteInt.h	/^  ExprList *pList;       \/* A list of expressions used as function arguments$/;"	m	struct:Expr
pList	test_async.c	/^  AsyncFileLock *pList;$/;"	m	struct:AsyncLock	file:
pList1	test_tclvar.c	/^  Tcl_Obj *pList1;     \/* Result of [info vars ?pattern?] *\/$/;"	m	struct:tclvar_cursor	file:
pList2	test_tclvar.c	/^  Tcl_Obj *pList2;     \/* Result of [array names [lindex $pList1 $i1]] *\/$/;"	m	struct:tclvar_cursor	file:
pLock	btreeInt.h	/^  BtLock *pLock;        \/* List of locks held on this shared-btree struct *\/$/;"	m	struct:BtShared
pLock	os_unix.c	/^  struct lockInfo *pLock;   \/* Info about locks on this inode *\/$/;"	m	struct:unixFile	typeref:struct:unixFile::lockInfo	file:
pMaskSet	where.c	/^  ExprMaskSet *pMaskSet;   \/* Mapping of table indices to bitmasks *\/$/;"	m	struct:WhereClause	file:
pMem	vdbe.h	/^    Mem *pMem;             \/* Used when p4type is P4_MEM *\/$/;"	m	union:VdbeOp::__anon12
pMem	vdbeInt.h	/^  Mem *pMem;            \/* Memory cell used to store aggregate context *\/$/;"	m	struct:sqlite3_context
pMethod	journal.c	/^  sqlite3_io_methods *pMethod;    \/* I\/O methods on journal files *\/$/;"	m	struct:JournalFile	file:
pMethod	os_os2.c	/^  const sqlite3_io_methods *pMethod;  \/* Always the first entry *\/$/;"	m	struct:os2File	file:
pMethod	os_unix.c	/^  sqlite3_io_methods const *pMethod;  \/* Always the first entry *\/$/;"	m	struct:unixFile	file:
pMethod	os_win.c	/^  const sqlite3_io_methods *pMethod;\/* Must be first *\/$/;"	m	struct:winFile	file:
pMethod	test6.c	/^  const sqlite3_io_methods *pMethod;   \/* Must be first *\/$/;"	m	struct:CrashFile	file:
pMethod	test_async.c	/^  sqlite3_io_methods *pMethod;$/;"	m	struct:AsyncFile	file:
pMod	sqliteInt.h	/^  Module *pMod;             \/* Pointer to the implementation of the module *\/$/;"	m	struct:Table
pModule	sqliteInt.h	/^  const sqlite3_module *pModule;       \/* Callback pointers *\/$/;"	m	struct:Module
pModule	vdbeInt.h	/^  const sqlite3_module *pModule;     \/* Module for cursor pVtabCursor *\/$/;"	m	struct:Cursor
pNC	expr.c	/^  NameContext *pNC;    \/* Namespace of first enclosing query *\/$/;"	m	struct:QueryCoder	file:
pName	sqliteInt.h	/^  const Token *pName; \/* Name of the container - used for error messages *\/$/;"	m	struct:DbFixer
pNewTable	sqliteInt.h	/^  Table *pNewTable;    \/* A table being constructed by CREATE TABLE *\/$/;"	m	struct:Parse
pNewTrigger	sqliteInt.h	/^  Trigger *pNewTrigger;     \/* Trigger under construct by a CREATE TRIGGER *\/$/;"	m	struct:Parse
pNext	btreeInt.h	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor
pNext	btreeInt.h	/^  BtLock *pNext;        \/* Next in BtShared.pLock list *\/$/;"	m	struct:BtLock
pNext	btreeInt.h	/^  BtShared *pNext;      \/* Next on a list of sharable BtShared structs *\/$/;"	m	struct:BtShared
pNext	btreeInt.h	/^  Btree *pNext;      \/* List of other sharable Btrees from the same db *\/$/;"	m	struct:Btree
pNext	mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::MemBlockHdr	file:
pNext	pager.c	/^  Pager *pNext;               \/* Doubly linked list of pagers on which *\/$/;"	m	struct:Pager	file:
pNext	pager.c	/^  PgHdr *pNext;$/;"	m	struct:PagerLruLink	file:
pNext	sqliteInt.h	/^  FuncDef *pNext;      \/* Next function with same name *\/$/;"	m	struct:FuncDef
pNext	sqliteInt.h	/^  Index *pNext;    \/* The next index associated with the same table *\/$/;"	m	struct:Index
pNext	sqliteInt.h	/^  NameContext *pNext;  \/* Next outer name context.  NULL for outermost *\/$/;"	m	struct:NameContext
pNext	sqliteInt.h	/^  Select *pNext;         \/* Next select to the left in a compound *\/$/;"	m	struct:Select
pNext	sqliteInt.h	/^  Trigger *pNext;         \/* Next trigger associated with the table *\/$/;"	m	struct:Trigger
pNext	sqliteInt.h	/^  TriggerStack *pNext; \/* Next trigger down on the trigger stack *\/$/;"	m	struct:TriggerStack
pNext	sqliteInt.h	/^  TriggerStep *pNext;  \/* Next in the link-list *\/$/;"	m	struct:TriggerStep
pNext	tclsqlite.c	/^  IncrblobChannel *pNext;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pNext	tclsqlite.c	/^  SqlCollate *pNext;    \/* Next function on the list of them all *\/$/;"	m	struct:SqlCollate	file:
pNext	tclsqlite.c	/^  SqlFunc *pNext;       \/* Next function on the list of them all *\/$/;"	m	struct:SqlFunc	file:
pNext	tclsqlite.c	/^  SqlPreparedStmt *pNext;  \/* Next in linked list *\/$/;"	m	struct:SqlPreparedStmt	file:
pNext	test6.c	/^  WriteBuffer *pNext;          \/* Next in CrashGlobal.pWriteList *\/$/;"	m	struct:WriteBuffer	file:
pNext	test_async.c	/^  AsyncFileLock *pNext;$/;"	m	struct:AsyncFileLock	file:
pNext	test_async.c	/^  AsyncWrite *pNext;  \/* Next write operation (to any file) *\/$/;"	m	struct:AsyncWrite	file:
pNext	test_onefile.c	/^  fs_real_file *pNext;$/;"	m	struct:fs_real_file	file:
pNext	test_server.c	/^  SqlMessage *pNext;           \/* Next message in the queue *\/$/;"	m	struct:SqlMessage	file:
pNext	vdbeInt.h	/^  FifoPage *pNext;   \/* Next page in the fifo *\/$/;"	m	struct:FifoPage
pNext	vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pNextAll	pager.c	/^  PgHdr *pNextAll;               \/* A list of all pages *\/$/;"	m	struct:PgHdr	file:
pNextFrom	sqliteInt.h	/^  FKey *pNextFrom;  \/* Next foreign key in pFrom *\/$/;"	m	struct:FKey
pNextHash	pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pNextStmt	pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHistory	file:
pNextTo	sqliteInt.h	/^  FKey *pNextTo;    \/* Next foreign key that points to zTo *\/$/;"	m	struct:FKey
pOffset	sqliteInt.h	/^  Expr *pOffset;         \/* OFFSET expression. NULL means not used. *\/$/;"	m	struct:Select
pOn	sqliteInt.h	/^    Expr *pOn;        \/* The ON clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pOpen	os_unix.c	/^  struct openCnt *pOpen;    \/* Info about all open fd's on this inode *\/$/;"	m	struct:unixFile	typeref:struct:unixFile::openCnt	file:
pOrderBy	sqliteInt.h	/^  ExprList *pOrderBy;    \/* The ORDER BY clause *\/$/;"	m	struct:Select
pOrig	pager.c	/^  u8 *pOrig;     \/* Original page text.  Restore to this on a full rollback *\/$/;"	m	struct:PgHistory	file:
pOrig	test6.c	/^  sqlite3_vfs *pOrig;                   \/* Wrapped vfs structure *\/$/;"	m	struct:crashAppData	file:
pPage	btreeInt.h	/^  MemPage *pPage;           \/* Page that contains the entry *\/$/;"	m	struct:BtCursor
pPage1	btreeInt.h	/^  MemPage *pPage1;      \/* First page of the database *\/$/;"	m	struct:BtShared
pPager	btreeInt.h	/^  Pager *pPager;        \/* The page cache *\/$/;"	m	struct:BtShared
pPager	btreeInt.h	/^  Pager *pPager;    \/* The associated pager.  Also accessible by pBt->pPager *\/$/;"	m	struct:IntegrityCk
pPager	pager.c	/^  Pager *pPager;                 \/* The pager to which this page belongs *\/$/;"	m	struct:PgHdr	file:
pParent	btreeInt.h	/^  MemPage *pParent;    \/* The parent of this page.  NULL for root *\/$/;"	m	struct:MemPage
pParent	test_onefile.c	/^  sqlite3_vfs *pParent;$/;"	m	struct:fs_vfs_t	file:
pParse	expr.c	/^  Parse *pParse;       \/* The parsing context *\/$/;"	m	struct:QueryCoder	file:
pParse	sqliteInt.h	/^  Parse *pParse;              \/* The Parse structure *\/$/;"	m	struct:AuthContext
pParse	sqliteInt.h	/^  Parse *pParse;       \/* The parser *\/$/;"	m	struct:NameContext
pParse	sqliteInt.h	/^  Parse *pParse;      \/* The parsing context.  Error messages written here *\/$/;"	m	struct:DbFixer
pParse	sqliteInt.h	/^  Parse *pParse;$/;"	m	struct:WhereInfo
pParse	where.c	/^  Parse *pParse;           \/* The parser context *\/$/;"	m	struct:WhereClause	file:
pPrev	btreeInt.h	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor
pPrev	btreeInt.h	/^  Btree *pPrev;      \/* Back pointer of the same list *\/$/;"	m	struct:Btree
pPrev	mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::	file:
pPrev	pager.c	/^  Pager *pPrev;               \/* sqlite3_release_memory() will work *\/$/;"	m	struct:Pager	file:
pPrev	pager.c	/^  PgHdr *pPrev;$/;"	m	struct:PagerLruLink	file:
pPrev	tclsqlite.c	/^  IncrblobChannel *pPrev;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pPrev	tclsqlite.c	/^  SqlPreparedStmt *pPrev;  \/* Previous on the list *\/$/;"	m	struct:SqlPreparedStmt	file:
pPrev	test_server.c	/^  SqlMessage *pPrev;           \/* Previous message in the queue *\/$/;"	m	struct:SqlMessage	file:
pPrev	vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pPrevDirty	pager.c	/^  PgHdr *pDirty, *pPrevDirty;    \/* Dirty pages *\/$/;"	m	struct:PgHdr	file:
pPrevHash	pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pPrevStmt	pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHistory	file:
pPrior	sqliteInt.h	/^  Select *pPrior;        \/* Prior select in a compound select statement *\/$/;"	m	struct:Select
pProfileArg	sqliteInt.h	/^  void *pProfileArg;                        \/* Argument to profile function *\/$/;"	m	struct:sqlite3
pProgressArg	sqliteInt.h	/^  void *pProgressArg;           \/* Argument to the progress callback *\/$/;"	m	struct:sqlite3
pQueueFirst	test_async.c	/^  AsyncWrite *pQueueFirst;     \/* Next write operation to be processed *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueHead	test_server.c	/^  SqlMessage *pQueueHead;       \/* Head of the message queue *\/$/;"	m	struct:ServerState	file:
pQueueLast	test_async.c	/^  AsyncWrite *pQueueLast;      \/* Last write operation on the list *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueTail	test_server.c	/^  SqlMessage *pQueueTail;       \/* Tail of the message queue *\/$/;"	m	struct:ServerState	file:
pReal	journal.c	/^  sqlite3_file *pReal;            \/* The "real" underlying file descriptor *\/$/;"	m	struct:JournalFile	file:
pReal	test_devsym.c	/^  sqlite3_file *pReal;$/;"	m	struct:devsym_file	file:
pReal	test_onefile.c	/^  fs_real_file *pReal;$/;"	m	struct:fs_file	file:
pReal	vdbe.h	/^    double *pReal;         \/* Used when p4type is P4_REAL *\/$/;"	m	union:VdbeOp::__anon12
pRealFile	test6.c	/^  sqlite3_file *pRealFile;             \/* Underlying "real" file handle *\/$/;"	m	struct:CrashFile	file:
pResultSet	vdbeInt.h	/^  Mem *pResultSet;        \/* Pointer to an array of results *\/$/;"	m	struct:Vdbe
pRight	sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pRightmost	sqliteInt.h	/^  Select *pRightmost;    \/* Right-most select in a compound select statement *\/$/;"	m	struct:Select
pRollbackArg	sqliteInt.h	/^  void *pRollbackArg;               \/* Argument to xRollbackCallback() *\/   $/;"	m	struct:sqlite3
pRollbackHook	tclsqlite.c	/^  Tcl_Obj *pRollbackHook;    \/* Rollback hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pSchema	btreeInt.h	/^  void *pSchema;        \/* Pointer to space allocated by sqlite3BtreeSchema() *\/$/;"	m	struct:BtShared
pSchema	sqliteInt.h	/^  Schema *pSchema;          \/* Schema that contains this table *\/$/;"	m	struct:Table
pSchema	sqliteInt.h	/^  Schema *pSchema;        \/* Schema containing the trigger *\/$/;"	m	struct:Trigger
pSchema	sqliteInt.h	/^  Schema *pSchema;     \/* Pointer to database schema (possibly shared) *\/$/;"	m	struct:Db
pSchema	sqliteInt.h	/^  Schema *pSchema; \/* Schema containing this index *\/$/;"	m	struct:Index
pScript	tclsqlite.c	/^  Tcl_Obj *pScript;     \/* The Tcl_Obj representation of the script *\/$/;"	m	struct:SqlFunc	file:
pSelect	sqliteInt.h	/^    Select *pSelect;  \/* A SELECT statement used in place of a table name *\/$/;"	m	struct:SrcList::SrcList_item
pSelect	sqliteInt.h	/^  Select *pSelect;       \/* When the expression is a sub-select.  Also the$/;"	m	struct:Expr
pSelect	sqliteInt.h	/^  Select *pSelect;     \/* Valid for SELECT and sometimes $/;"	m	struct:TriggerStep
pSelect	sqliteInt.h	/^  Select *pSelect; \/* NULL for tables.  Points to definition if a view. *\/$/;"	m	struct:Table
pSeqTab	sqliteInt.h	/^  Table *pSeqTab;      \/* The sqlite_sequence table used by AUTOINCREMENT *\/$/;"	m	struct:Schema
pSrc	sqliteInt.h	/^  SrcList *pSrc;         \/* The FROM clause *\/$/;"	m	struct:Select
pSrcList	sqliteInt.h	/^  SrcList *pSrcList;   \/* One or more tables used to resolve names *\/$/;"	m	struct:NameContext
pStmt	pager.c	/^  PgHdr *pStmt;               \/* List of pages in the statement subjournal *\/$/;"	m	struct:Pager	file:
pStmt	pager.c	/^  u8 *pStmt;     \/* Text as it was at the beginning of the current statement *\/$/;"	m	struct:PgHistory	file:
pStmt	tclsqlite.c	/^  sqlite3_stmt *pStmt;     \/* The prepared statement *\/$/;"	m	struct:SqlPreparedStmt	file:
pStmt	test4.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	test7.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	test8.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:echo_cursor	file:
pStmt	test_server.c	/^  sqlite3_stmt *pStmt;         \/* A specific statement *\/$/;"	m	struct:SqlMessage	file:
pStmt	vdbeblob.c	/^  sqlite3_stmt *pStmt;    \/* Statement holding cursor open *\/$/;"	m	struct:Incrblob	file:
pTab	sqliteInt.h	/^    Table *pTab;             \/* Source table *\/$/;"	m	struct:AggInfo::AggInfo_col
pTab	sqliteInt.h	/^    Table *pTab;      \/* An SQL table corresponding to zName *\/$/;"	m	struct:SrcList::SrcList_item
pTab	sqliteInt.h	/^  Table *pTab;           \/* Table for OP_Column expressions. *\/$/;"	m	struct:Expr
pTab	sqliteInt.h	/^  Table *pTab;         \/* Table that triggers are currently being coded on *\/$/;"	m	struct:TriggerStack
pTabList	sqliteInt.h	/^  SrcList *pTabList;   \/* List of tables in the join *\/$/;"	m	struct:WhereInfo
pTabSchema	sqliteInt.h	/^  Schema *pTabSchema;     \/* Schema containing the table *\/$/;"	m	struct:Trigger
pTable	sqliteInt.h	/^  Table *pTable;   \/* The SQL table being indexed *\/$/;"	m	struct:Index
pTableList	test_schema.c	/^  sqlite3_stmt *pTableList;$/;"	m	struct:schema_cursor	file:
pTestCollateInterp	test1.c	/^static Tcl_Interp* pTestCollateInterp;$/;"	v	file:
pTmpSpace	pager.c	/^  char *pTmpSpace;            \/* Pager.pageSize bytes of space for tmp use *\/$/;"	m	struct:Pager	file:
pTraceArg	sqliteInt.h	/^  void *pTraceArg;                          \/* Argument to the trace function *\/$/;"	m	struct:sqlite3
pTrig	sqliteInt.h	/^  Trigger *pTrig;      \/* The trigger that this step is a part of *\/$/;"	m	struct:TriggerStep
pTrigger	sqliteInt.h	/^  Trigger *pTrigger;   \/* The trigger currently being coded *\/$/;"	m	struct:TriggerStack
pTrigger	sqliteInt.h	/^  Trigger *pTrigger; \/* List of SQL triggers on this table *\/$/;"	m	struct:Table
pUpdateArg	sqliteInt.h	/^  void *pUpdateArg;$/;"	m	struct:sqlite3
pUpdateHook	tclsqlite.c	/^  Tcl_Obj *pUpdateHook;      \/* Update hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pUser	sqliteInt.h	/^  void *pUser;          \/* First argument to xCmp() *\/$/;"	m	struct:CollSeq
pUserData	sqliteInt.h	/^  void *pUserData;     \/* User data parameter *\/$/;"	m	struct:FuncDef
pUsing	sqliteInt.h	/^    IdList *pUsing;   \/* The USING clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pVTab	sqliteInt.h	/^  Table *pVTab;                 \/* vtab with active Connect\/Create method *\/$/;"	m	struct:sqlite3
pVdbe	sqliteInt.h	/^  Vdbe *pVdbe;         \/* An engine for executing database bytecode *\/$/;"	m	struct:Parse
pVdbe	sqliteInt.h	/^  struct Vdbe *pVdbe;           \/* List of active virtual machines *\/$/;"	m	struct:sqlite3	typeref:struct:sqlite3::Vdbe
pVdbeFunc	vdbe.h	/^    VdbeFunc *pVdbeFunc;   \/* Used when p4type is P4_VDBEFUNC *\/$/;"	m	union:VdbeOp::__anon12
pVdbeFunc	vdbeInt.h	/^  VdbeFunc *pVdbeFunc;  \/* Auxilary data, if created. *\/$/;"	m	struct:sqlite3_context
pVfs	journal.c	/^  sqlite3_vfs *pVfs;              \/* The "real" underlying VFS *\/$/;"	m	struct:JournalFile	file:
pVfs	pager.c	/^  sqlite3_vfs *pVfs;          \/* OS functions to use for IO *\/$/;"	m	struct:Pager	file:
pVfs	sqliteInt.h	/^  sqlite3_vfs *pVfs;            \/* OS Interface *\/$/;"	m	struct:sqlite3
pVfs	test_devsym.c	/^  sqlite3_vfs *pVfs;$/;"	m	struct:DevsymGlobal	file:
pVirtualLock	sqliteInt.h	/^  Table *pVirtualLock;       \/* Require virtual table lock on this table *\/$/;"	m	struct:Parse
pVtab	sqliteInt.h	/^  sqlite3_vtab *pVtab;      \/* Pointer to the module instance *\/$/;"	m	struct:Table
pVtab	vdbe.h	/^    sqlite3_vtab *pVtab;   \/* Used when p4type is P4_VTAB *\/$/;"	m	union:VdbeOp::__anon12
pVtabCursor	vdbeInt.h	/^  sqlite3_vtab_cursor *pVtabCursor;  \/* The cursor for a virtual table *\/$/;"	m	struct:Cursor
pWC	where.c	/^  WhereClause *pWC;       \/* The clause this term is part of *\/$/;"	m	struct:WhereTerm	file:
pWhen	sqliteInt.h	/^  Expr *pWhen;            \/* The WHEN clause of the expresion (may be NULL) *\/$/;"	m	struct:Trigger
pWhere	sqliteInt.h	/^  Expr *pWhere;          \/* The WHERE clause *\/$/;"	m	struct:Select
pWhere	sqliteInt.h	/^  Expr *pWhere;        \/* Valid for DELETE, UPDATE steps *\/$/;"	m	struct:TriggerStep
pWriteList	test6.c	/^  WriteBuffer *pWriteList;     \/* Head of write-list *\/$/;"	m	struct:CrashGlobal	file:
pWriteListEnd	test6.c	/^  WriteBuffer *pWriteListEnd;  \/* End of write-list *\/$/;"	m	struct:CrashGlobal	file:
pageDestructor	btree.c	/^static void pageDestructor(DbPage *pData, int pageSize){$/;"	f	file:
pageHash	pager.c	/^  u32 pageHash;$/;"	m	struct:PgHdr	file:
pageInStatement	pager.c	/^static int pageInStatement(PgHdr *pPg){$/;"	f	file:
pageReinit	btree.c	/^static void pageReinit(DbPage *pData, int pageSize){$/;"	f	file:
pageSize	btreeInt.h	/^  u16 pageSize;         \/* Total number of bytes on a page *\/$/;"	m	struct:BtShared
pageSize	pager.c	/^  int pageSize;               \/* Number of bytes in a page *\/$/;"	m	struct:Pager	file:
pageSizeFixed	btreeInt.h	/^  u8 pageSizeFixed;     \/* True if the page size can no longer be changed *\/$/;"	m	struct:BtShared
page_add_to_stmt_list	pager.c	/^static void page_add_to_stmt_list(PgHdr *pPg){$/;"	f	file:
page_get	test2.c	/^static int page_get($/;"	f	file:
page_lookup	test2.c	/^static int page_lookup($/;"	f	file:
page_number	test2.c	/^static int page_number($/;"	f	file:
page_read	test2.c	/^static int page_read($/;"	f	file:
page_ref	pager.c	/^  static void page_ref(PgHdr *pPg){$/;"	f	file:
page_ref	pager.c	2735;"	d	file:
page_unref	test2.c	/^static int page_unref($/;"	f	file:
page_write	test2.c	/^static int page_write($/;"	f	file:
pager3_refinfo_enable	pager.c	/^  int pager3_refinfo_enable = 0;$/;"	v
pager3_refinfo_enable	pager.h	/^  int pager3_refinfo_enable;$/;"	v
pagerAcquire	pager.c	/^static int pagerAcquire($/;"	f	file:
pagerAllocatePage	pager.c	/^static int pagerAllocatePage(Pager *pPager, PgHdr **ppPg){$/;"	f	file:
pagerEnter	pager.c	/^  static void pagerEnter(Pager *p){$/;"	f	file:
pagerEnter	pager.c	531;"	d	file:
pagerLeave	pager.c	/^  static void pagerLeave(Pager *p){$/;"	f	file:
pagerLeave	pager.c	532;"	d	file:
pagerSharedLock	pager.c	/^static int pagerSharedLock(Pager *pPager){$/;"	f	file:
pagerStmtBegin	pager.c	/^static int pagerStmtBegin(Pager *pPager){$/;"	f	file:
pagerUnlockAndRollback	pager.c	/^static void pagerUnlockAndRollback(Pager *p){$/;"	f	file:
pager_cksum	pager.c	/^static u32 pager_cksum(Pager *pPager, const u8 *aData){$/;"	f	file:
pager_close	test2.c	/^static int pager_close($/;"	f	file:
pager_commit	test2.c	/^static int pager_commit($/;"	f	file:
pager_datahash	pager.c	/^static u32 pager_datahash(int nByte, unsigned char *pData){$/;"	f	file:
pager_datahash	pager.c	883;"	d	file:
pager_delmaster	pager.c	/^static int pager_delmaster(Pager *pPager, const char *zMaster){$/;"	f	file:
pager_end_transaction	pager.c	/^static int pager_end_transaction(Pager *pPager){$/;"	f	file:
pager_error	pager.c	/^static int pager_error(Pager *pPager, int rc){$/;"	f	file:
pager_get_all_dirty_pages	pager.c	/^static PgHdr *pager_get_all_dirty_pages(Pager *pPager){$/;"	f	file:
pager_get_content	pager.c	/^static int pager_get_content(PgHdr *pPg){$/;"	f	file:
pager_incr_changecounter	pager.c	/^static int pager_incr_changecounter(Pager *pPager, int isDirect){$/;"	f	file:
pager_lookup	pager.c	/^static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){$/;"	f	file:
pager_open	test2.c	/^static int pager_open($/;"	f	file:
pager_open_journal	pager.c	/^static int pager_open_journal(Pager *pPager){$/;"	f	file:
pager_pagecount	test2.c	/^static int pager_pagecount($/;"	f	file:
pager_pagehash	pager.c	/^static u32 pager_pagehash(PgHdr *pPage){$/;"	f	file:
pager_pagehash	pager.c	884;"	d	file:
pager_playback	pager.c	/^static int pager_playback(Pager *pPager, int isHot){$/;"	f	file:
pager_playback_one_page	pager.c	/^static int pager_playback_one_page($/;"	f	file:
pager_recycle	pager.c	/^static int pager_recycle(Pager *pPager, PgHdr **ppPg){$/;"	f	file:
pager_refinfo	pager.c	/^  static void pager_refinfo(PgHdr *p){$/;"	f	file:
pager_reset	pager.c	/^static void pager_reset(Pager *pPager){$/;"	f	file:
pager_resize_hash_table	pager.c	/^static void pager_resize_hash_table(Pager *pPager, int N){$/;"	f	file:
pager_rollback	test2.c	/^static int pager_rollback($/;"	f	file:
pager_stats	test2.c	/^static int pager_stats($/;"	f	file:
pager_stmt_begin	test2.c	/^static int pager_stmt_begin($/;"	f	file:
pager_stmt_commit	test2.c	/^static int pager_stmt_commit($/;"	f	file:
pager_stmt_playback	pager.c	/^static int pager_stmt_playback(Pager *pPager){$/;"	f	file:
pager_stmt_rollback	test2.c	/^static int pager_stmt_rollback($/;"	f	file:
pager_truncate	pager.c	/^static int pager_truncate(Pager *pPager, int nPage){$/;"	f	file:
pager_truncate	test2.c	/^static int pager_truncate($/;"	f	file:
pager_truncate_cache	pager.c	/^static void pager_truncate_cache(Pager *pPager){$/;"	f	file:
pager_unlock	pager.c	/^static void pager_unlock(Pager *pPager){$/;"	f	file:
pager_wait_on_lock	pager.c	/^static int pager_wait_on_lock(Pager *pPager, int locktype){$/;"	f	file:
pager_write	pager.c	/^static int pager_write(PgHdr *pPg){$/;"	f	file:
pager_write_pagelist	pager.c	/^static int pager_write_pagelist(PgHdr *pList){$/;"	f	file:
parent	test_thread.c	/^  Tcl_ThreadId parent;     \/* Thread id of parent thread *\/$/;"	m	struct:SqlThread	file:
parseCell	btree.c	608;"	d	file:
parseDateOrTime	date.c	/^static int parseDateOrTime($/;"	f	file:
parseError	sqliteInt.h	/^  u8 parseError;       \/* True after a parsing error.  Ticket #1794 *\/$/;"	m	struct:Parse
parseHhMmSs	date.c	/^static int parseHhMmSs(const char *zDate, DateTime *p){$/;"	f	file:
parseModifier	date.c	/^static int parseModifier(const char *zMod, DateTime *p){$/;"	f	file:
parseTimezone	date.c	/^static int parseTimezone(const char *zDate, DateTime *p){$/;"	f	file:
parseYyyyMmDd	date.c	/^static int parseYyyyMmDd(const char *zDate, DateTime *p){$/;"	f	file:
parse_client_id	test7.c	/^static int parse_client_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
parse_thread_id	test4.c	/^static int parse_thread_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
pathToDel	os_os2.c	/^  char* pathToDel;          \/* Name of file to delete on close *\/$/;"	m	struct:os2File	file:
patternCompare	func.c	/^static int patternCompare($/;"	f	file:
payloadSize	vdbeInt.h	/^  int payloadSize;      \/* Total number of bytes in the record *\/$/;"	m	struct:Cursor
pc	vdbeInt.h	/^  int pc;                 \/* The program counter *\/$/;"	m	struct:Vdbe
pgno	btreeInt.h	/^  Pgno pgno;           \/* Page number for this page *\/$/;"	m	struct:MemPage
pgno	pager.c	/^  Pgno pgno;                     \/* The page number for this page *\/$/;"	m	struct:PgHdr	file:
pgnoRoot	btreeInt.h	/^  Pgno pgnoRoot;            \/* The root page of this tree *\/$/;"	m	struct:BtCursor
plus_opt	parse.y	/^plus_opt ::= .$/;"	l
plus_opt	parse.y	/^plus_opt ::= PLUS.$/;"	l
pointerToText	test_malloc.c	/^static void pointerToText(void *p, char *z){$/;"	f	file:
posixLockingStyle	os_unix.c	/^        posixLockingStyle = 0,       \/* standard posix-advisory locks *\/$/;"	e	enum:__anon4	file:
postToParent	test_thread.c	/^static void postToParent(SqlThread *p, Tcl_Obj *pScript){$/;"	f	file:
ppThis	test_onefile.c	/^  fs_real_file **ppThis;$/;"	m	struct:fs_real_file	file:
prefix	printf.c	/^  etByte prefix;           \/* Offset into aPrefix[] of the prefix string *\/$/;"	m	struct:et_info	file:
prefixIsEqual	sqliteInt.h	/^  u8 prefixIsEqual;   \/* Treat a prefix as equal *\/$/;"	m	struct:KeyInfo
prepSelectStmt	select.c	/^static int prepSelectStmt(Parse *pParse, Select *p){$/;"	f	file:
prepStack	test1.c	/^static void prepStack(void){$/;"	f	file:
prepare	sqlite3ext.h	/^  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
prepare16	sqlite3ext.h	/^  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepare16_v2	sqlite3ext.h	/^  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepare_v2	sqlite3ext.h	/^  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
prereqAll	where.c	/^  Bitmask prereqAll;      \/* Bitmask of tables referenced by p *\/$/;"	m	struct:WhereTerm	file:
prereqRight	where.c	/^  Bitmask prereqRight;    \/* Bitmask of tables used by pRight *\/$/;"	m	struct:WhereTerm	file:
prev	hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
prev	mem3.c	/^      u32 prev;       \/* Index in mem.aPool[] of previous free chunk *\/$/;"	m	struct:Mem3Block::__anon8::__anon10	file:
prev	vdbeInt.h	/^  HashElem *prev;        \/* Previously accessed hash elemen *\/$/;"	m	struct:Set
prevSize	mem3.c	/^      u32 prevSize;   \/* Size of previous chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon8::__anon9	file:
previous_mode_data	shell.c	/^struct previous_mode_data {$/;"	s	file:
priorNewRowid	sqliteInt.h	/^  i64 priorNewRowid;            \/* Last randomly generated ROWID *\/$/;"	m	struct:sqlite3
processCompoundOrderBy	select.c	/^static int processCompoundOrderBy($/;"	f	file:
processDevSymArgs	test6.c	/^static int processDevSymArgs($/;"	f	file:
processOrderGroupBy	select.c	/^static int processOrderGroupBy($/;"	f	file:
process_input	shell.c	/^static int process_input(struct callback_data *p, FILE *in){$/;"	f	file:
process_sqliterc	shell.c	/^static void process_sqliterc($/;"	f	file:
profile	sqlite3ext.h	/^  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);$/;"	m	struct:sqlite3_api_routines
progress_handler	sqlite3ext.h	/^  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
pseudoTable	vdbeInt.h	/^  Bool pseudoTable;     \/* This is a NEW or OLD pseudo-tables of a trigger *\/$/;"	m	struct:Cursor
pthread_cond_wait	test_async.c	570;"	d	file:
pthread_mutex_lock	test_async.c	567;"	d	file:
pthread_mutex_trylock	test_async.c	569;"	d	file:
pthread_mutex_unlock	test_async.c	568;"	d	file:
ptrChngFunction	test1.c	/^static void ptrChngFunction($/;"	f	file:
ptrmapGet	btree.c	/^static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){$/;"	f	file:
ptrmapPageno	btree.c	/^static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){$/;"	f	file:
ptrmapPut	btree.c	/^static int ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent){$/;"	f	file:
ptrmapPutOvfl	btree.c	/^static int ptrmapPutOvfl(MemPage *pPage, int iCell){$/;"	f	file:
ptrmapPutOvflPtr	btree.c	/^static int ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
pushOntoSorter	select.c	/^static void pushOntoSorter($/;"	f	file:
put2byte	btreeInt.h	632;"	d
put32bits	pager.c	748;"	d	file:
put4byte	btreeInt.h	634;"	d
putVarint	btreeInt.h	502;"	d
pzErrMsg	sqliteInt.h	/^  char **pzErrMsg;    \/* Error message stored here *\/$/;"	m	struct:__anon3
pzNeededCollation	test1.c	/^static char *pzNeededCollation = zNeededCollation;$/;"	v	file:
queryTableLock	btree.c	/^static int queryTableLock(Btree *p, Pgno iTab, u8 eLock){$/;"	f	file:
queryTableLock	btree.c	83;"	d	file:
queueMutex	test_async.c	/^  pthread_mutex_t queueMutex;  \/* Mutex for access to write operation queue *\/$/;"	m	struct:TestAsyncStaticData	file:
queueMutex	test_server.c	/^  pthread_mutex_t queueMutex;   \/* Hold this mutex to access the msg queue *\/$/;"	m	struct:ServerState	file:
queueMutexHolder	test_async.c	/^  pthread_t queueMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
queueSignal	test_async.c	/^  pthread_cond_t queueSignal;  \/* For waking up sleeping writer thread *\/$/;"	m	struct:TestAsyncStaticData	file:
quoteFunc	func.c	/^static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
r	vdbeInt.h	/^  double r;           \/* Real value *\/$/;"	m	struct:Mem
rJD	date.c	/^  double rJD;      \/* The julian day number *\/$/;"	m	struct:DateTime	file:
rSum	func.c	/^  double rSum;      \/* Floating point sum *\/$/;"	m	struct:SumCtx	file:
randStr	func.c	/^static void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
randomBlob	func.c	/^static void randomBlob($/;"	f	file:
randomByte	random.c	/^static int randomByte(void){$/;"	f	file:
randomFunc	func.c	/^static void randomFunc($/;"	f	file:
rc	sqliteInt.h	/^  int rc;              \/* Return code from execution *\/$/;"	m	struct:Parse
rc	sqliteInt.h	/^  int rc;             \/* Result code stored here *\/$/;"	m	struct:__anon3
rc	table.c	/^  int rc;$/;"	m	struct:TabResult	file:
rc	tclsqlite.c	/^  int rc;                    \/* Return code of most recent sqlite3_exec() *\/$/;"	m	struct:SqliteDb	file:
rc	test4.c	/^  int rc;               \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	test7.c	/^  int rc;                  \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	vdbeInt.h	/^  int rc;                 \/* Value to return *\/$/;"	m	struct:Vdbe
read32bits	pager.c	/^static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){$/;"	f	file:
readDbPage	pager.c	/^static int readDbPage(Pager *pPager, PgHdr *pPg, Pgno pgno){$/;"	f	file:
readJournalHdr	pager.c	/^static int readJournalHdr($/;"	f	file:
readMasterJournal	pager.c	/^static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, int nMaster){$/;"	f	file:
readOnly	btreeInt.h	/^  u8 readOnly;          \/* True if the underlying file is readonly *\/$/;"	m	struct:BtShared
readOnly	pager.c	/^  u8 readOnly;                \/* True for a read-only database *\/$/;"	m	struct:Pager	file:
readOnly	sqliteInt.h	/^  u8 readOnly;     \/* True if this table should not be written by the user *\/$/;"	m	struct:Table
read_history	shell.c	42;"	d	file:
readline	shell.c	40;"	d	file:
readsTable	insert.c	/^static int readsTable(Vdbe *v, int iStartAddr, int iDb, Table *pTab){$/;"	f	file:
realloc	sqlite3ext.h	/^  void *(*realloc)(void*,int);$/;"	m	struct:sqlite3_api_routines
referencesOtherTables	where.c	/^static int referencesOtherTables($/;"	f	file:
regRoot	sqliteInt.h	/^  int regRoot;         \/* Register holding root page number for new objects *\/$/;"	m	struct:Parse
regRowid	sqliteInt.h	/^  int regRowid;        \/* Register holding rowid of CREATE TABLE entry *\/$/;"	m	struct:Parse
registerTrace	vdbe.c	/^static void registerTrace(FILE *out, int iReg, Mem *p){$/;"	f	file:
register_echo_module	test8.c	/^static int register_echo_module($/;"	f	file:
register_schema_module	test_schema.c	/^static int register_schema_module($/;"	f	file:
register_tclvar_module	test_tclvar.c	/^static int register_tclvar_module($/;"	f	file:
rehash	hash.c	/^static void rehash(Hash *pH, int new_size){$/;"	f	file:
reindexDatabases	build.c	/^static void reindexDatabases(Parse *pParse, char const *zColl){$/;"	f	file:
reindexTable	build.c	/^static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){$/;"	f	file:
releaseLockInfo	os_unix.c	/^static void releaseLockInfo(struct lockInfo *pLock){$/;"	f	file:
releaseMemArray	vdbeaux.c	/^static void releaseMemArray(Mem *p, int N){$/;"	f	file:
releaseOpenCnt	os_unix.c	/^static void releaseOpenCnt(struct openCnt *pOpen){$/;"	f	file:
releasePage	btree.c	/^static void releasePage(MemPage *pPage){$/;"	f	file:
release_memory	sqlite3ext.h	/^  int (*release_memory)(int);$/;"	m	struct:sqlite3_api_routines
reloadTableSchema	alter.c	/^static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){$/;"	f	file:
relocatePage	btree.c	/^static int relocatePage($/;"	f	file:
removeElementGivenHash	hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeFromSharingList	btree.c	/^static int removeFromSharingList(BtShared *pBt){$/;"	f	file:
renameTableFunc	alter.c	/^static void renameTableFunc($/;"	f	file:
renameTriggerFunc	alter.c	/^static void renameTriggerFunc($/;"	f	file:
reparentChildPages	btree.c	/^static int reparentChildPages(MemPage *pPage){$/;"	f	file:
reparentPage	btree.c	/^static int reparentPage(BtShared *pBt, Pgno pgno, MemPage *pNewParent, int idx){$/;"	f	file:
replaceFunc	func.c	/^static void replaceFunc($/;"	f	file:
reset	sqlite3ext.h	/^  int  (*reset)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
resetAccumulator	select.c	/^static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
resetAutoExtObjCmd	test_autoext.c	/^static int resetAutoExtObjCmd($/;"	f	file:
reset_prng_state	test1.c	/^static int reset_prng_state($/;"	f	file:
resizeOpArray	vdbeaux.c	/^static void resizeOpArray(Vdbe *p, int N){$/;"	f	file:
resolveAttachExpr	attach.c	/^static int resolveAttachExpr(NameContext *pName, Expr *pExpr)$/;"	f	file:
resolveP2Values	vdbeaux.c	/^static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){$/;"	f	file:
resolve_backslashes	shell.c	/^static void resolve_backslashes(char *z){$/;"	f	file:
restoreOrClearCursorPosition	btree.c	391;"	d	file:
restore_prng_state	test1.c	/^static int restore_prng_state($/;"	f	file:
result	os_unix.c	/^  int result;            \/* Result of the locking operation *\/$/;"	m	struct:threadTestData	file:
result_blob	sqlite3ext.h	/^  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_double	sqlite3ext.h	/^  void  (*result_double)(sqlite3_context*,double);$/;"	m	struct:sqlite3_api_routines
result_error	sqlite3ext.h	/^  void  (*result_error)(sqlite3_context*,const char*,int);$/;"	m	struct:sqlite3_api_routines
result_error16	sqlite3ext.h	/^  void  (*result_error16)(sqlite3_context*,const void*,int);$/;"	m	struct:sqlite3_api_routines
result_error_nomem	sqlite3ext.h	/^  void (*result_error_nomem)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_error_toobig	sqlite3ext.h	/^  void (*result_error_toobig)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_int	sqlite3ext.h	/^  void  (*result_int)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
result_int64	sqlite3ext.h	/^  void  (*result_int64)(sqlite3_context*,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
result_null	sqlite3ext.h	/^  void  (*result_null)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_text	sqlite3ext.h	/^  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16	sqlite3ext.h	/^  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16be	sqlite3ext.h	/^  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16le	sqlite3ext.h	/^  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_value	sqlite3ext.h	/^  void  (*result_value)(sqlite3_context*,sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
retRangeStart	os_unix.c	/^  unsigned long long retRangeStart; \/* nbr of 1st byte locked if successful *\/$/;"	m	struct:ByteRangeLockPB2	file:
returnDepth	vdbeInt.h	/^  int returnDepth;        \/* Next unused element in returnStack[] *\/$/;"	m	struct:Vdbe
returnSingleInt	pragma.c	/^static void returnSingleInt(Parse *pParse, const char *zLabel, int value){$/;"	f	file:
returnStack	vdbeInt.h	/^  int returnStack[25];    \/* Return address stack for OP_Gosub & OP_Return *\/$/;"	m	struct:Vdbe
rollback_hook	sqlite3ext.h	/^  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
roundFunc	func.c	/^static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
rowid	test_schema.c	/^  int rowid;$/;"	m	struct:schema_cursor	file:
rowidIsValid	vdbeInt.h	/^  Bool rowidIsValid;    \/* True if lastRowid is valid *\/$/;"	m	struct:Cursor
run_schema_dump_query	shell.c	/^static int run_schema_dump_query($/;"	f	file:
run_table_dump_query	shell.c	/^static int run_table_dump_query(FILE *out, sqlite3 *db, const char *zSelect){$/;"	f	file:
s	date.c	/^  double s;        \/* Seconds *\/$/;"	m	struct:DateTime	file:
s	random.c	/^  unsigned char s[256];          \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
s	vdbeInt.h	/^  Mem s;                \/* The return value is stored here *\/$/;"	m	struct:sqlite3_context
sArg	sqliteInt.h	/^  Token sArg;                \/* Complete text of a module argument *\/$/;"	m	struct:Parse
sBegin	shell.c	/^static struct rusage sBegin;$/;"	v	typeref:struct:rusage	file:
sColMap	sqliteInt.h	/^  struct sColMap {  \/* Mapping of columns in pFrom to columns in zTo *\/$/;"	s	struct:FKey
sDb	test3.c	/^static sqlite3 sDb;$/;"	v	file:
sErrToken	sqliteInt.h	/^  Token sErrToken;     \/* The token at which the error occurred *\/$/;"	m	struct:Parse
sFifo	vdbeInt.h	/^  Fifo sFifo;             \/* A list of ROWIDs *\/$/;"	m	struct:Vdbe
sFifo	vdbeInt.h	/^  Fifo sFifo;       \/* Records that will participate in a DELETE or UPDATE *\/$/;"	m	struct:Context
sLastToken	sqliteInt.h	/^  Token sLastToken;    \/* The last token parsed *\/$/;"	m	struct:Parse
sNameToken	sqliteInt.h	/^  Token sNameToken;    \/* Token with unqualified schema object name *\/$/;"	m	struct:Parse
safeToUseEvalObjv	tclsqlite.c	/^static int safeToUseEvalObjv(Tcl_Interp *interp, Tcl_Obj *pCmd){$/;"	f	file:
safety_level	sqliteInt.h	/^  u8 safety_level;     \/* How aggressive at synching data to disk *\/$/;"	m	struct:Db
saveAllCursors	btree.c	/^static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){$/;"	f	file:
saveCursorPosition	btree.c	/^static int saveCursorPosition(BtCursor *pCur){$/;"	f	file:
save_prng_state	test1.c	/^static int save_prng_state($/;"	f	file:
saved_cnt	pager.c	/^static int saved_cnt;$/;"	v	file:
schemaBestIndex	test_schema.c	/^static int schemaBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
schemaClose	test_schema.c	/^static int schemaClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaColumn	test_schema.c	/^static int schemaColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
schemaCreate	test_schema.c	/^static int schemaCreate($/;"	f	file:
schemaDestroy	test_schema.c	/^static int schemaDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
schemaEof	test_schema.c	/^static int schemaEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaFilter	test_schema.c	/^static int schemaFilter($/;"	f	file:
schemaIsValid	prepare.c	/^static int schemaIsValid(sqlite3 *db){$/;"	f	file:
schemaModule	test_schema.c	/^static sqlite3_module schemaModule = {$/;"	v	file:
schemaNext	test_schema.c	/^static int schemaNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaOpen	test_schema.c	/^static int schemaOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
schemaRowid	test_schema.c	/^static int schemaRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
schema_cookie	sqliteInt.h	/^  int schema_cookie;   \/* Database schema version number for this file *\/$/;"	m	struct:Schema
schema_cursor	test_schema.c	/^struct schema_cursor {$/;"	s	file:
schema_cursor	test_schema.c	/^typedef struct schema_cursor schema_cursor;$/;"	t	typeref:struct:schema_cursor	file:
schema_vtab	test_schema.c	/^struct schema_vtab {$/;"	s	file:
schema_vtab	test_schema.c	/^typedef struct schema_vtab schema_vtab;$/;"	t	typeref:struct:schema_vtab	file:
sectorSize	pager.c	/^  int sectorSize;             \/* Assumed sector size during rollback *\/$/;"	m	struct:Pager	file:
seekAndRead	os_unix.c	/^static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){$/;"	f	file:
seekAndWrite	os_unix.c	/^static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){$/;"	f	file:
seekJournalHdr	pager.c	/^static void seekJournalHdr(Pager *pPager){$/;"	f	file:
seenInterrupt	shell.c	/^static volatile int seenInterrupt = 0;$/;"	v	file:
selectInnerLoop	select.c	/^static void selectInnerLoop($/;"	f	file:
selectOpName	select.c	/^static const char *selectOpName(int id){$/;"	f	file:
sendToServer	test_server.c	/^static void sendToServer(SqlMessage *pMsg){$/;"	f	file:
separator	shell.c	/^  char separator[20];    \/* Separator character for MODE_List *\/$/;"	m	struct:callback_data	file:
seqCount	vdbeInt.h	/^  i64 seqCount;         \/* Sequence counter *\/$/;"	m	struct:Cursor
serverHalt	test_server.c	/^  volatile int serverHalt;      \/* Server halts itself when true *\/$/;"	m	struct:ServerState	file:
serverMutex	test_server.c	/^  pthread_mutex_t serverMutex;  \/* Held by the server while it is running *\/$/;"	m	struct:ServerState	file:
serverWakeup	test_server.c	/^  pthread_cond_t serverWakeup;  \/* Signal this condvar to wake up the server *\/$/;"	m	struct:ServerState	file:
setChildPtrmaps	btree.c	/^static int setChildPtrmaps(MemPage *pPage){$/;"	f	file:
setJoinExpr	select.c	/^static void setJoinExpr(Expr *p, int iTable){$/;"	f	file:
setLikeOptFlag	func.c	/^static void setLikeOptFlag(sqlite3 *db, const char *zName, int flagVal){$/;"	f	file:
setMaster	pager.c	/^  u8 setMaster;               \/* True if a m-j name has been written to jrnl *\/$/;"	m	struct:Pager	file:
setQuotedToken	select.c	/^static void setQuotedToken(Parse *pParse, Token *p, const char *z){$/;"	f	file:
setSectorSize	pager.c	/^static void setSectorSize(Pager *pPager){$/;"	f	file:
setToken	select.c	/^static void setToken(Token *p, const char *z){$/;"	f	file:
set_authorizer	sqlite3ext.h	/^  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,const char*,const char*),void*);$/;"	m	struct:sqlite3_api_routines
set_auxdata	sqlite3ext.h	/^  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));$/;"	m	struct:sqlite3_api_routines
set_options	test_config.c	/^static void set_options(Tcl_Interp *interp){$/;"	f	file:
set_table_name	shell.c	/^static void set_table_name(struct callback_data *p, const char *zName){$/;"	f	file:
sharable	btreeInt.h	/^  u8 sharable;       \/* True if we can share pBt with another db *\/$/;"	m	struct:Btree
shared	os_win.c	/^  winceLock *shared;      \/* Global shared lock memory for the file  *\/$/;"	m	struct:winFile	file:
sharedLockByte	os_unix.c	/^  unsigned long long sharedLockByte;$/;"	m	struct:afpLockingContext	file:
sharedLockByte	os_win.c	/^  short sharedLockByte;   \/* Randomly chosen byte used as a shared lock *\/$/;"	m	struct:winFile	file:
shellstaticFunc	shell.c	/^static void shellstaticFunc($/;"	f	file:
showHeader	shell.c	/^  int showHeader;        \/* True to show column names in List or Column mode *\/$/;"	m	struct:callback_data	file:
showHeader	shell.c	/^  int showHeader;$/;"	m	struct:previous_mode_data	file:
signed	parse.y	/^signed ::= minus_num.$/;"	l
signed	parse.y	/^signed ::= plus_num.$/;"	l
size4x	mem3.c	/^      u32 size4x;     \/* 4x the size of current chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon8::__anon9	file:
sizeCnt	mem2.c	/^  int sizeCnt[NCSIZE];$/;"	m	struct:__anon5	file:
skip	btreeInt.h	/^  int skip;        \/* (skip<0) -> Prev() is a no-op. (skip>0) -> Next() is *\/$/;"	m	struct:BtCursor
sleep	sqlite3ext.h	/^  int (*sleep)(int);$/;"	m	struct:sqlite3_api_routines
snprintf	sqlite3ext.h	/^  char * (*snprintf)(int,char*,const char*,...);$/;"	m	struct:sqlite3_api_routines
softHeapLimitEnforcer	malloc.c	/^static void softHeapLimitEnforcer($/;"	f	file:
soft_heap_limit	sqlite3ext.h	/^  void (*soft_heap_limit)(int);$/;"	m	struct:sqlite3_api_routines
sortOrder	sqliteInt.h	/^    u8 sortOrder;          \/* 1 for DESC or 0 for ASC *\/$/;"	m	struct:ExprList::ExprList_item
sort_pagelist	pager.c	/^static PgHdr *sort_pagelist(PgHdr *pIn){$/;"	f	file:
sortableByRowid	where.c	/^static int sortableByRowid($/;"	f	file:
sortingIdx	sqliteInt.h	/^  int sortingIdx;         \/* Cursor number of the sorting index *\/$/;"	m	struct:AggInfo
soundexFunc	func.c	/^static void soundexFunc($/;"	f	file:
span	sqliteInt.h	/^  Token span;            \/* Complete text of the expression *\/$/;"	m	struct:Expr
sqlite3	sqliteInt.h	/^struct sqlite3 {$/;"	s
sqlite3AFPLockingUnixIoMethod	os_unix.c	/^static const sqlite3_io_methods sqlite3AFPLockingUnixIoMethod = {$/;"	v	file:
sqlite3AddCheckConstraint	build.c	/^void sqlite3AddCheckConstraint($/;"	f
sqlite3AddCollateType	build.c	/^void sqlite3AddCollateType(Parse *pParse, Token *pToken){$/;"	f
sqlite3AddColumn	build.c	/^void sqlite3AddColumn(Parse *pParse, Token *pName){$/;"	f
sqlite3AddColumnType	build.c	/^void sqlite3AddColumnType(Parse *pParse, Token *pType){$/;"	f
sqlite3AddDefaultValue	build.c	/^void sqlite3AddDefaultValue(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3AddNotNull	build.c	/^void sqlite3AddNotNull(Parse *pParse, int onError){$/;"	f
sqlite3AddPrimaryKey	build.c	/^void sqlite3AddPrimaryKey($/;"	f
sqlite3AffinityType	build.c	/^char sqlite3AffinityType(const Token *pType){$/;"	f
sqlite3AlterBeginAddColumn	alter.c	/^void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3AlterFinishAddColumn	alter.c	/^void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){$/;"	f
sqlite3AlterFunctions	alter.c	/^void sqlite3AlterFunctions(sqlite3 *db){$/;"	f
sqlite3AlterRenameTable	alter.c	/^void sqlite3AlterRenameTable($/;"	f
sqlite3AnalysisLoad	analyze.c	/^int sqlite3AnalysisLoad(sqlite3 *db, int iDb){$/;"	f
sqlite3Analyze	analyze.c	/^void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ApiExit	malloc.c	/^int sqlite3ApiExit(sqlite3* db, int rc){$/;"	f
sqlite3ArrayAllocate	build.c	/^void *sqlite3ArrayAllocate($/;"	f
sqlite3AtoF	util.c	/^int sqlite3AtoF(const char *z, double *pResult){$/;"	f
sqlite3Atoi64	util.c	/^int sqlite3Atoi64(const char *zNum, i64 *pNum){$/;"	f
sqlite3Attach	attach.c	/^void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){$/;"	f
sqlite3AttachFunctions	attach.c	/^void sqlite3AttachFunctions(sqlite3 *db){$/;"	f
sqlite3AuthCheck	auth.c	/^int sqlite3AuthCheck($/;"	f
sqlite3AuthCheck	sqliteInt.h	1867;"	d
sqlite3AuthContextPop	auth.c	/^void sqlite3AuthContextPop(AuthContext *pContext){$/;"	f
sqlite3AuthContextPop	sqliteInt.h	1869;"	d
sqlite3AuthContextPush	auth.c	/^void sqlite3AuthContextPush($/;"	f
sqlite3AuthContextPush	sqliteInt.h	1868;"	d
sqlite3AuthRead	auth.c	/^void sqlite3AuthRead($/;"	f
sqlite3AuthRead	sqliteInt.h	1866;"	d
sqlite3AutoLoadExtensions	loadext.c	/^int sqlite3AutoLoadExtensions(sqlite3 *db){$/;"	f
sqlite3AutoLoadExtensions	sqliteInt.h	1973;"	d
sqlite3BeginParse	build.c	/^void sqlite3BeginParse(Parse *pParse, int explainFlag){$/;"	f
sqlite3BeginTransaction	build.c	/^void sqlite3BeginTransaction(Parse *pParse, int type){$/;"	f
sqlite3BeginTrigger	trigger.c	/^void sqlite3BeginTrigger($/;"	f
sqlite3BeginWriteOperation	build.c	/^void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){$/;"	f
sqlite3BinaryCompareCollSeq	expr.c	/^CollSeq *sqlite3BinaryCompareCollSeq($/;"	f
sqlite3BtreeBeginStmt	btree.c	/^int sqlite3BtreeBeginStmt(Btree *p){$/;"	f
sqlite3BtreeBeginTrans	btree.c	/^int sqlite3BtreeBeginTrans(Btree *p, int wrflag){$/;"	f
sqlite3BtreeCacheOverflow	btree.c	/^void sqlite3BtreeCacheOverflow(BtCursor *pCur){$/;"	f
sqlite3BtreeClearTable	btree.c	/^int sqlite3BtreeClearTable(Btree *p, int iTable){$/;"	f
sqlite3BtreeClose	btree.c	/^int sqlite3BtreeClose(Btree *p){$/;"	f
sqlite3BtreeCloseCursor	btree.c	/^int sqlite3BtreeCloseCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeCommit	btree.c	/^int sqlite3BtreeCommit(Btree *p){$/;"	f
sqlite3BtreeCommitPhaseOne	btree.c	/^int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){$/;"	f
sqlite3BtreeCommitPhaseTwo	btree.c	/^int sqlite3BtreeCommitPhaseTwo(Btree *p){$/;"	f
sqlite3BtreeCommitStmt	btree.c	/^int sqlite3BtreeCommitStmt(Btree *p){$/;"	f
sqlite3BtreeCopyFile	btree.c	/^int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){$/;"	f
sqlite3BtreeCreateTable	btree.c	/^int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){$/;"	f
sqlite3BtreeCursor	btree.c	/^int sqlite3BtreeCursor($/;"	f
sqlite3BtreeCursorDb	btree.c	/^sqlite3 *sqlite3BtreeCursorDb(const BtCursor *pCur){$/;"	f
sqlite3BtreeCursorInfo	test_btree.c	/^int sqlite3BtreeCursorInfo(BtCursor *pCur, int *aResult, int upCnt){$/;"	f
sqlite3BtreeCursorList	test_btree.c	/^void sqlite3BtreeCursorList(Btree *p){$/;"	f
sqlite3BtreeData	btree.c	/^int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeDataFetch	btree.c	/^const void *sqlite3BtreeDataFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeDataSize	btree.c	/^int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){$/;"	f
sqlite3BtreeDelete	btree.c	/^int sqlite3BtreeDelete(BtCursor *pCur){$/;"	f
sqlite3BtreeDropTable	btree.c	/^int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){$/;"	f
sqlite3BtreeEnter	btmutex.c	/^void sqlite3BtreeEnter(Btree *p){$/;"	f
sqlite3BtreeEnter	btree.h	189;"	d
sqlite3BtreeEnterAll	btmutex.c	/^void sqlite3BtreeEnterAll(sqlite3 *db){$/;"	f
sqlite3BtreeEnterAll	btree.h	194;"	d
sqlite3BtreeEnterCursor	btmutex.c	/^void sqlite3BtreeEnterCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeEnterCursor	btree.h	192;"	d
sqlite3BtreeEof	btree.c	/^int sqlite3BtreeEof(BtCursor *pCur){$/;"	f
sqlite3BtreeFactory	main.c	/^int sqlite3BtreeFactory($/;"	f
sqlite3BtreeFindCell	btree.c	/^u8 *sqlite3BtreeFindCell(MemPage *pPage, int iCell){$/;"	f
sqlite3BtreeFirst	btree.c	/^int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeFlags	btree.c	/^int sqlite3BtreeFlags(BtCursor *pCur){$/;"	f
sqlite3BtreeGetAutoVacuum	btree.c	/^int sqlite3BtreeGetAutoVacuum(Btree *p){$/;"	f
sqlite3BtreeGetDirname	btree.c	/^const char *sqlite3BtreeGetDirname(Btree *p){$/;"	f
sqlite3BtreeGetFilename	btree.c	/^const char *sqlite3BtreeGetFilename(Btree *p){$/;"	f
sqlite3BtreeGetJournalname	btree.c	/^const char *sqlite3BtreeGetJournalname(Btree *p){$/;"	f
sqlite3BtreeGetMeta	btree.c	/^int sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){$/;"	f
sqlite3BtreeGetPage	btree.c	/^int sqlite3BtreeGetPage($/;"	f
sqlite3BtreeGetPageSize	btree.c	/^int sqlite3BtreeGetPageSize(Btree *p){$/;"	f
sqlite3BtreeGetReserve	btree.c	/^int sqlite3BtreeGetReserve(Btree *p){$/;"	f
sqlite3BtreeGetTempCursor	btree.c	/^void sqlite3BtreeGetTempCursor(BtCursor *pCur, BtCursor *pTempCur){$/;"	f
sqlite3BtreeHoldsAllMutexes	btmutex.c	/^int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){$/;"	f
sqlite3BtreeHoldsAllMutexes	btree.h	196;"	d
sqlite3BtreeHoldsMutex	btmutex.c	/^int sqlite3BtreeHoldsMutex(Btree *p){$/;"	f
sqlite3BtreeHoldsMutex	btree.h	191;"	d
sqlite3BtreeIncrVacuum	btree.c	/^int sqlite3BtreeIncrVacuum(Btree *p){$/;"	f
sqlite3BtreeInitPage	btree.c	/^int sqlite3BtreeInitPage($/;"	f
sqlite3BtreeInsert	btree.c	/^int sqlite3BtreeInsert($/;"	f
sqlite3BtreeIntegrityCheck	btree.c	/^char *sqlite3BtreeIntegrityCheck($/;"	f
sqlite3BtreeInvokeBusyHandler	btree.c	/^static int sqlite3BtreeInvokeBusyHandler(void *pArg, int n){$/;"	f	file:
sqlite3BtreeIsInReadTrans	btree.c	/^int sqlite3BtreeIsInReadTrans(Btree *p){$/;"	f
sqlite3BtreeIsInStmt	btree.c	/^int sqlite3BtreeIsInStmt(Btree *p){$/;"	f
sqlite3BtreeIsInTrans	btree.c	/^int sqlite3BtreeIsInTrans(Btree *p){$/;"	f
sqlite3BtreeIsRootPage	btree.c	/^int sqlite3BtreeIsRootPage(MemPage *pPage){$/;"	f
sqlite3BtreeKey	btree.c	/^int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeKeyFetch	btree.c	/^const void *sqlite3BtreeKeyFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeKeySize	btree.c	/^int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){$/;"	f
sqlite3BtreeLast	btree.c	/^int sqlite3BtreeLast(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeLeave	btmutex.c	/^void sqlite3BtreeLeave(Btree *p){$/;"	f
sqlite3BtreeLeave	btree.h	190;"	d
sqlite3BtreeLeaveAll	btmutex.c	/^void sqlite3BtreeLeaveAll(sqlite3 *db){$/;"	f
sqlite3BtreeLeaveAll	btree.h	195;"	d
sqlite3BtreeLeaveCursor	btmutex.c	/^void sqlite3BtreeLeaveCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeLeaveCursor	btree.h	193;"	d
sqlite3BtreeLockTable	btree.c	/^int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){$/;"	f
sqlite3BtreeMaxPageCount	btree.c	/^int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){$/;"	f
sqlite3BtreeMoveToParent	btree.c	/^void sqlite3BtreeMoveToParent(BtCursor *pCur){$/;"	f
sqlite3BtreeMoveto	btree.c	/^int sqlite3BtreeMoveto($/;"	f
sqlite3BtreeMutexArrayEnter	btmutex.c	/^void sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray){$/;"	f
sqlite3BtreeMutexArrayEnter	btree.h	197;"	d
sqlite3BtreeMutexArrayInsert	btmutex.c	/^void sqlite3BtreeMutexArrayInsert(BtreeMutexArray *pArray, Btree *pBtree){$/;"	f
sqlite3BtreeMutexArrayInsert	btree.h	199;"	d
sqlite3BtreeMutexArrayLeave	btmutex.c	/^void sqlite3BtreeMutexArrayLeave(BtreeMutexArray *pArray){$/;"	f
sqlite3BtreeMutexArrayLeave	btree.h	198;"	d
sqlite3BtreeNext	btree.c	/^int sqlite3BtreeNext(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeOpen	btree.c	/^int sqlite3BtreeOpen($/;"	f
sqlite3BtreePageDump	test_btree.c	/^int sqlite3BtreePageDump(Btree *p, int pgno, int recursive){$/;"	f
sqlite3BtreePager	btree.c	/^Pager *sqlite3BtreePager(Btree *p){$/;"	f
sqlite3BtreeParseCell	btree.c	/^void sqlite3BtreeParseCell($/;"	f
sqlite3BtreeParseCellPtr	btree.c	/^void sqlite3BtreeParseCellPtr($/;"	f
sqlite3BtreePrevious	btree.c	/^int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreePutData	btree.c	/^int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){$/;"	f
sqlite3BtreeReleaseTempCursor	btree.c	/^void sqlite3BtreeReleaseTempCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeRestoreOrClearCursorPosition	btree.c	/^int sqlite3BtreeRestoreOrClearCursorPosition(BtCursor *pCur){$/;"	f
sqlite3BtreeRollback	btree.c	/^int sqlite3BtreeRollback(Btree *p){$/;"	f
sqlite3BtreeRollbackStmt	btree.c	/^int sqlite3BtreeRollbackStmt(Btree *p){$/;"	f
sqlite3BtreeSchema	btree.c	/^void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){$/;"	f
sqlite3BtreeSchemaLocked	btree.c	/^int sqlite3BtreeSchemaLocked(Btree *p){$/;"	f
sqlite3BtreeSetAutoVacuum	btree.c	/^int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){$/;"	f
sqlite3BtreeSetCacheSize	btree.c	/^int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){$/;"	f
sqlite3BtreeSetPageSize	btree.c	/^int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve){$/;"	f
sqlite3BtreeSetSafetyLevel	btree.c	/^int sqlite3BtreeSetSafetyLevel(Btree *p, int level, int fullSync){$/;"	f
sqlite3BtreeSharedCacheReport	test_btree.c	/^int sqlite3BtreeSharedCacheReport($/;"	f
sqlite3BtreeSyncDisabled	btree.c	/^int sqlite3BtreeSyncDisabled(Btree *p){$/;"	f
sqlite3BtreeTripAllCursors	btree.c	/^void sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode){$/;"	f
sqlite3BtreeUpdateMeta	btree.c	/^int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){$/;"	f
sqlite3ChangeCookie	build.c	/^void sqlite3ChangeCookie(Parse *pParse, int iDb){$/;"	f
sqlite3CheckCollSeq	callback.c	/^int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){$/;"	f
sqlite3CheckObjectName	build.c	/^int sqlite3CheckObjectName(Parse *pParse, const char *zName){$/;"	f
sqlite3CloseExtensions	loadext.c	/^void sqlite3CloseExtensions(sqlite3 *db){$/;"	f
sqlite3CloseExtensions	sqliteInt.h	1972;"	d
sqlite3CodeRowTrigger	sqliteInt.h	1854;"	d
sqlite3CodeRowTrigger	trigger.c	/^int sqlite3CodeRowTrigger($/;"	f
sqlite3CodeSubselect	expr.c	/^void sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3CodeVerifySchema	build.c	/^void sqlite3CodeVerifySchema(Parse *pParse, int iDb){$/;"	f
sqlite3ColumnDefault	update.c	/^void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i){$/;"	f
sqlite3CommitInternalChanges	build.c	/^void sqlite3CommitInternalChanges(sqlite3 *db){$/;"	f
sqlite3CommitTransaction	build.c	/^void sqlite3CommitTransaction(Parse *pParse){$/;"	f
sqlite3CompareAffinity	expr.c	/^char sqlite3CompareAffinity(Expr *pExpr, char aff2){$/;"	f
sqlite3CompleteInsertion	insert.c	/^void sqlite3CompleteInsertion($/;"	f
sqlite3Corrupt	main.c	/^int sqlite3Corrupt(void){$/;"	f
sqlite3CrashTestEnable	test6.c	/^static int sqlite3CrashTestEnable = 0;$/;"	v	file:
sqlite3CreateForeignKey	build.c	/^void sqlite3CreateForeignKey($/;"	f
sqlite3CreateFunc	main.c	/^int sqlite3CreateFunc($/;"	f
sqlite3CreateIdExpr	select.c	/^Expr *sqlite3CreateIdExpr(Parse *pParse, const char *zName){$/;"	f
sqlite3CreateIndex	build.c	/^void sqlite3CreateIndex($/;"	f
sqlite3CreateView	build.c	/^void sqlite3CreateView($/;"	f
sqlite3DbMallocRaw	malloc.c	/^void *sqlite3DbMallocRaw(sqlite3 *db, unsigned n){$/;"	f
sqlite3DbMallocZero	malloc.c	/^void *sqlite3DbMallocZero(sqlite3 *db, unsigned n){$/;"	f
sqlite3DbRealloc	malloc.c	/^void *sqlite3DbRealloc(sqlite3 *db, void *p, int n){$/;"	f
sqlite3DbReallocOrFree	malloc.c	/^void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, int n){$/;"	f
sqlite3DbStrDup	malloc.c	/^char *sqlite3DbStrDup(sqlite3 *db, const char *z){$/;"	f
sqlite3DbStrNDup	malloc.c	/^char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){$/;"	f
sqlite3DebugPrintf	printf.c	/^void sqlite3DebugPrintf(const char *zFormat, ...){$/;"	f
sqlite3DefaultRowEst	build.c	/^void sqlite3DefaultRowEst(Index *pIdx){$/;"	f
sqlite3DeferForeignKey	build.c	/^void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){$/;"	f
sqlite3DeleteFrom	delete.c	/^void sqlite3DeleteFrom($/;"	f
sqlite3DeleteTable	build.c	/^void sqlite3DeleteTable(Table *pTable){$/;"	f
sqlite3DeleteTrigger	sqliteInt.h	1851;"	d
sqlite3DeleteTrigger	trigger.c	/^void sqlite3DeleteTrigger(Trigger *pTrigger){$/;"	f
sqlite3DeleteTriggerStep	trigger.c	/^void sqlite3DeleteTriggerStep(TriggerStep *pTriggerStep){$/;"	f
sqlite3Dequote	util.c	/^void sqlite3Dequote(char *z){$/;"	f
sqlite3DequoteExpr	expr.c	/^void sqlite3DequoteExpr(sqlite3 *db, Expr *p){$/;"	f
sqlite3Detach	attach.c	/^void sqlite3Detach(Parse *pParse, Expr *pDbname){$/;"	f
sqlite3DetectLockingStyle	os_unix.c	/^static sqlite3LockingStyle sqlite3DetectLockingStyle($/;"	f	file:
sqlite3DotlockLockingUnixIoMethod	os_unix.c	/^static const sqlite3_io_methods sqlite3DotlockLockingUnixIoMethod = {$/;"	v	file:
sqlite3DropIndex	build.c	/^void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){$/;"	f
sqlite3DropTable	build.c	/^void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){$/;"	f
sqlite3DropTrigger	trigger.c	/^void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){$/;"	f
sqlite3DropTriggerPtr	sqliteInt.h	1852;"	d
sqlite3DropTriggerPtr	trigger.c	/^void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){$/;"	f
sqlite3EndTable	build.c	/^void sqlite3EndTable($/;"	f
sqlite3ErrStr	main.c	/^const char *sqlite3ErrStr(int rc){$/;"	f
sqlite3Error	util.c	/^void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...){$/;"	f
sqlite3ErrorClear	util.c	/^void sqlite3ErrorClear(Parse *pParse){$/;"	f
sqlite3ErrorMsg	util.c	/^void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3ExecFunc	test1.c	/^static void sqlite3ExecFunc($/;"	f	file:
sqlite3ExpirePreparedStatements	vdbeaux.c	/^void sqlite3ExpirePreparedStatements(sqlite3 *db){$/;"	f
sqlite3Expr	expr.c	/^Expr *sqlite3Expr($/;"	f
sqlite3ExprAffinity	expr.c	/^char sqlite3ExprAffinity(Expr *pExpr){$/;"	f
sqlite3ExprAnalyzeAggList	expr.c	/^void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){$/;"	f
sqlite3ExprAnalyzeAggregates	expr.c	/^void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){$/;"	f
sqlite3ExprAnd	expr.c	/^Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){$/;"	f
sqlite3ExprAssignVarNumber	expr.c	/^void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCode	expr.c	/^int sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeAndCache	expr.c	/^int sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeExprList	expr.c	/^int sqlite3ExprCodeExprList($/;"	f
sqlite3ExprCodeGetColumn	expr.c	/^void sqlite3ExprCodeGetColumn($/;"	f
sqlite3ExprCodeTarget	expr.c	/^static int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){$/;"	f	file:
sqlite3ExprCodeTemp	expr.c	/^int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){$/;"	f
sqlite3ExprCollSeq	expr.c	/^CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCompare	expr.c	/^int sqlite3ExprCompare(Expr *pA, Expr *pB){$/;"	f
sqlite3ExprDelete	expr.c	/^void sqlite3ExprDelete(Expr *p){$/;"	f
sqlite3ExprDup	expr.c	/^Expr *sqlite3ExprDup(sqlite3 *db, Expr *p){$/;"	f
sqlite3ExprFunction	expr.c	/^Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){$/;"	f
sqlite3ExprIfFalse	expr.c	/^void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIfTrue	expr.c	/^void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIsConstant	expr.c	/^int sqlite3ExprIsConstant(Expr *p){$/;"	f
sqlite3ExprIsConstantNotJoin	expr.c	/^int sqlite3ExprIsConstantNotJoin(Expr *p){$/;"	f
sqlite3ExprIsConstantOrFunction	expr.c	/^int sqlite3ExprIsConstantOrFunction(Expr *p){$/;"	f
sqlite3ExprIsInteger	expr.c	/^int sqlite3ExprIsInteger(Expr *p, int *pValue){$/;"	f
sqlite3ExprListAppend	expr.c	/^ExprList *sqlite3ExprListAppend($/;"	f
sqlite3ExprListCheckLength	expr.c	/^void sqlite3ExprListCheckLength($/;"	f
sqlite3ExprListDelete	expr.c	/^void sqlite3ExprListDelete(ExprList *pList){$/;"	f
sqlite3ExprListDup	expr.c	/^ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p){$/;"	f
sqlite3ExprResolveNames	expr.c	/^int sqlite3ExprResolveNames( $/;"	f
sqlite3ExprSetColl	expr.c	/^Expr *sqlite3ExprSetColl(Parse *pParse, Expr *pExpr, Token *pName){$/;"	f
sqlite3ExprSetHeight	expr.c	/^void sqlite3ExprSetHeight(Expr *p){$/;"	f
sqlite3ExprSetHeight	sqliteInt.h	2060;"	d
sqlite3ExprSpan	expr.c	/^void sqlite3ExprSpan(Expr *pExpr, Token *pLeft, Token *pRight){$/;"	f
sqlite3Fault	fault.c	/^static void sqlite3Fault(void){$/;"	f	file:
sqlite3FaultBenign	fault.c	/^void sqlite3FaultBenign(int id, int enable){$/;"	f
sqlite3FaultBenign	sqliteInt.h	2037;"	d
sqlite3FaultBenignFailures	fault.c	/^int sqlite3FaultBenignFailures(int id){$/;"	f
sqlite3FaultBenignFailures	sqliteInt.h	2035;"	d
sqlite3FaultConfig	fault.c	/^void sqlite3FaultConfig(int id, int nDelay, int nRepeat){$/;"	f
sqlite3FaultConfig	sqliteInt.h	2033;"	d
sqlite3FaultFailures	fault.c	/^int sqlite3FaultFailures(int id){$/;"	f
sqlite3FaultFailures	sqliteInt.h	2034;"	d
sqlite3FaultPending	fault.c	/^int sqlite3FaultPending(int id){$/;"	f
sqlite3FaultPending	sqliteInt.h	2036;"	d
sqlite3FaultStep	fault.c	/^int sqlite3FaultStep(int id){$/;"	f
sqlite3FaultStep	sqliteInt.h	2038;"	d
sqlite3FindCollSeq	callback.c	/^CollSeq *sqlite3FindCollSeq($/;"	f
sqlite3FindDb	build.c	/^int sqlite3FindDb(sqlite3 *db, Token *pName){$/;"	f
sqlite3FindFunction	callback.c	/^FuncDef *sqlite3FindFunction($/;"	f
sqlite3FindInIndex	expr.c	/^int sqlite3FindInIndex(Parse *pParse, Expr *pX, int mustBeUnique){$/;"	f
sqlite3FindIndex	build.c	/^Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){$/;"	f
sqlite3FindTable	build.c	/^Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){$/;"	f
sqlite3FinishCoding	build.c	/^void sqlite3FinishCoding(Parse *pParse){$/;"	f
sqlite3FinishTrigger	trigger.c	/^void sqlite3FinishTrigger($/;"	f
sqlite3FitsIn64Bits	util.c	/^int sqlite3FitsIn64Bits(const char *zNum, int negFlag){$/;"	f
sqlite3FixExpr	attach.c	/^int sqlite3FixExpr($/;"	f
sqlite3FixExprList	attach.c	/^int sqlite3FixExprList($/;"	f
sqlite3FixInit	attach.c	/^int sqlite3FixInit($/;"	f
sqlite3FixSelect	attach.c	/^int sqlite3FixSelect($/;"	f
sqlite3FixSrcList	attach.c	/^int sqlite3FixSrcList($/;"	f
sqlite3FixTriggerStep	attach.c	/^int sqlite3FixTriggerStep($/;"	f
sqlite3FlockLockingUnixIoMethod	os_unix.c	/^static const sqlite3_io_methods sqlite3FlockLockingUnixIoMethod = {$/;"	v	file:
sqlite3GenerateConstraintChecks	insert.c	/^void sqlite3GenerateConstraintChecks($/;"	f
sqlite3GenerateIndexKey	delete.c	/^int sqlite3GenerateIndexKey($/;"	f
sqlite3GenerateRowDelete	delete.c	/^void sqlite3GenerateRowDelete($/;"	f
sqlite3GenerateRowIndexDelete	delete.c	/^void sqlite3GenerateRowIndexDelete($/;"	f
sqlite3Get4byte	util.c	/^u32 sqlite3Get4byte(const u8 *p){$/;"	f
sqlite3GetCollSeq	callback.c	/^CollSeq *sqlite3GetCollSeq($/;"	f
sqlite3GetFuncCollSeq	func.c	/^static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){$/;"	f	file:
sqlite3GetInt32	util.c	/^int sqlite3GetInt32(const char *zNum, int *pValue){$/;"	f
sqlite3GetInt64	test1.c	/^static int sqlite3GetInt64(const char *zNum, i64 *pValue){$/;"	f	file:
sqlite3GetTempRange	expr.c	/^int sqlite3GetTempRange(Parse *pParse, int nReg){$/;"	f
sqlite3GetTempReg	expr.c	/^int sqlite3GetTempReg(Parse *pParse){$/;"	f
sqlite3GetToken	tokenize.c	/^int sqlite3GetToken(const unsigned char *z, int *tokenType){$/;"	f
sqlite3GetVarint	util.c	/^int sqlite3GetVarint(const unsigned char *p, u64 *v){$/;"	f
sqlite3GetVarint32	util.c	/^int sqlite3GetVarint32(const unsigned char *p, u32 *v){$/;"	f
sqlite3GetVdbe	select.c	/^Vdbe *sqlite3GetVdbe(Parse *pParse){$/;"	f
sqlite3HashClear	hash.c	/^void sqlite3HashClear(Hash *pH){$/;"	f
sqlite3HashFind	hash.c	/^void *sqlite3HashFind(const Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3HashFindElem	hash.c	/^HashElem *sqlite3HashFindElem(const Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3HashInit	hash.c	/^void sqlite3HashInit(Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3HashInsert	hash.c	/^void *sqlite3HashInsert(Hash *pH, const void *pKey, int nKey, void *data){$/;"	f
sqlite3HexToBlob	util.c	/^void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){$/;"	f
sqlite3IdListAppend	build.c	/^IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){$/;"	f
sqlite3IdListDelete	build.c	/^void sqlite3IdListDelete(IdList *pList){$/;"	f
sqlite3IdListDup	expr.c	/^IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){$/;"	f
sqlite3IdListIndex	build.c	/^int sqlite3IdListIndex(IdList *pList, const char *zName){$/;"	f
sqlite3IndexAffinityOk	expr.c	/^int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){$/;"	f
sqlite3IndexAffinityStr	insert.c	/^void sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){$/;"	f
sqlite3IndexKeyinfo	build.c	/^KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){$/;"	f
sqlite3Init	prepare.c	/^int sqlite3Init(sqlite3 *db, char **pzErrMsg){$/;"	f
sqlite3InitCallback	prepare.c	/^int sqlite3InitCallback(void *pInit, int argc, char **argv, char **azColName){$/;"	f
sqlite3InitInfo	sqliteInt.h	/^  struct sqlite3InitInfo {      \/* Information used during initialization *\/$/;"	s	struct:sqlite3
sqlite3InitOne	prepare.c	/^static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){$/;"	f	file:
sqlite3Insert	insert.c	/^void sqlite3Insert($/;"	f
sqlite3InvalidFunction	vdbeapi.c	/^void sqlite3InvalidFunction($/;"	f
sqlite3InvokeBusyHandler	main.c	/^int sqlite3InvokeBusyHandler(BusyHandler *p){$/;"	f
sqlite3IsAsciiIdChar	tokenize.c	/^const char sqlite3IsAsciiIdChar[] = {$/;"	v
sqlite3IsEbcdicIdChar	tokenize.c	/^const char sqlite3IsEbcdicIdChar[] = {$/;"	v
sqlite3IsLikeFunction	func.c	/^int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){$/;"	f
sqlite3IsNumber	util.c	/^int sqlite3IsNumber(const char *z, int *realnum, u8 enc){$/;"	f
sqlite3IsNumericAffinity	sqliteInt.h	716;"	d
sqlite3IsReadOnly	delete.c	/^int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){$/;"	f
sqlite3IsRowid	expr.c	/^int sqlite3IsRowid(const char *z){$/;"	f
sqlite3JoinType	select.c	/^int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){$/;"	f
sqlite3JournalCreate	journal.c	/^int sqlite3JournalCreate(sqlite3_file *p){$/;"	f
sqlite3JournalOpen	journal.c	/^int sqlite3JournalOpen($/;"	f
sqlite3JournalSize	journal.c	/^int sqlite3JournalSize(sqlite3_vfs *pVfs){$/;"	f
sqlite3JournalSize	sqliteInt.h	2053;"	d
sqlite3LoadExtension	loadext.c	/^static int sqlite3LoadExtension($/;"	f	file:
sqlite3LocateCollSeq	build.c	/^CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName, int nName){$/;"	f
sqlite3LocateTable	build.c	/^Table *sqlite3LocateTable($/;"	f
sqlite3LockAndPrepare	prepare.c	/^static int sqlite3LockAndPrepare($/;"	f	file:
sqlite3LockingStyle	os_unix.c	/^} sqlite3LockingStyle;$/;"	t	typeref:enum:__anon4	file:
sqlite3LruPageList	pager.c	/^static PagerLruList sqlite3LruPageList = {0, 0, 0};$/;"	v	file:
sqlite3MAX_COLUMN	test_config.c	/^int sqlite3MAX_COLUMN = SQLITE_MAX_COLUMN;$/;"	v
sqlite3MAX_COMPOUND_SELECT	test_config.c	/^int sqlite3MAX_COMPOUND_SELECT = SQLITE_MAX_COMPOUND_SELECT;$/;"	v
sqlite3MAX_EXPR_DEPTH	test_config.c	/^int sqlite3MAX_EXPR_DEPTH = SQLITE_MAX_EXPR_DEPTH;$/;"	v
sqlite3MAX_FUNCTION_ARG	test_config.c	/^int sqlite3MAX_FUNCTION_ARG = SQLITE_MAX_FUNCTION_ARG;$/;"	v
sqlite3MAX_LENGTH	test_config.c	/^int sqlite3MAX_LENGTH = SQLITE_MAX_LENGTH;$/;"	v
sqlite3MAX_LIKE_PATTERN_LENGTH	test_config.c	/^int sqlite3MAX_LIKE_PATTERN_LENGTH = SQLITE_MAX_LIKE_PATTERN_LENGTH;$/;"	v
sqlite3MAX_PAGE_COUNT	test_config.c	/^int sqlite3MAX_PAGE_COUNT = SQLITE_MAX_PAGE_COUNT;$/;"	v
sqlite3MAX_PAGE_SIZE	test_config.c	/^int sqlite3MAX_PAGE_SIZE = SQLITE_MAX_PAGE_SIZE;$/;"	v
sqlite3MAX_SQL_LENGTH	test_config.c	/^int sqlite3MAX_SQL_LENGTH = SQLITE_MAX_SQL_LENGTH;$/;"	v
sqlite3MAX_VARIABLE_NUMBER	test_config.c	/^int sqlite3MAX_VARIABLE_NUMBER = SQLITE_MAX_VARIABLE_NUMBER;$/;"	v
sqlite3MAX_VDBE_OP	test_config.c	/^int sqlite3MAX_VDBE_OP = SQLITE_MAX_VDBE_OP;$/;"	v
sqlite3MPrintf	printf.c	/^char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){$/;"	f
sqlite3MallocZero	malloc.c	/^void *sqlite3MallocZero(unsigned n){$/;"	f
sqlite3MemCompare	vdbemem.c	/^int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){$/;"	f
sqlite3MemsysAlarm	mem1.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysAlarm	mem2.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysAlarm	mem4.c	/^static void sqlite3MemsysAlarm(int nByte){$/;"	f	file:
sqlite3MemsysGetHeader	mem2.c	/^static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){$/;"	f	file:
sqlite3MinimumFileFormat	build.c	/^void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){$/;"	f
sqlite3NameFromToken	build.c	/^char *sqlite3NameFromToken(sqlite3 *db, Token *pName){$/;"	f
sqlite3NestedParse	build.c	/^void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3NolockLockingUnixIoMethod	os_unix.c	/^static const sqlite3_io_methods sqlite3NolockLockingUnixIoMethod = {$/;"	v	file:
sqlite3One	sqliteInt.h	/^const int sqlite3One;$/;"	v
sqlite3OpenMasterTable	build.c	/^void sqlite3OpenMasterTable(Parse *p, int iDb){$/;"	f
sqlite3OpenTable	delete.c	/^void sqlite3OpenTable($/;"	f
sqlite3OpenTableAndIndices	insert.c	/^int sqlite3OpenTableAndIndices($/;"	f
sqlite3OpenTempDatabase	build.c	/^int sqlite3OpenTempDatabase(Parse *pParse){$/;"	f
sqlite3OsAccess	os.c	/^int sqlite3OsAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f
sqlite3OsCheckReservedLock	os.c	/^int sqlite3OsCheckReservedLock(sqlite3_file *id){$/;"	f
sqlite3OsClose	os.c	/^int sqlite3OsClose(sqlite3_file *pId){$/;"	f
sqlite3OsCloseFree	os.c	/^int sqlite3OsCloseFree(sqlite3_file *pFile){$/;"	f
sqlite3OsCurrentTime	os.c	/^int sqlite3OsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f
sqlite3OsDefaultVfs	os.h	272;"	d
sqlite3OsDefaultVfs	os_os2.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDefaultVfs	os_unix.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDefaultVfs	os_win.c	/^sqlite3_vfs *sqlite3OsDefaultVfs(void){$/;"	f
sqlite3OsDelete	os.c	/^int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f
sqlite3OsDeviceCharacteristics	os.c	/^int sqlite3OsDeviceCharacteristics(sqlite3_file *id){$/;"	f
sqlite3OsDlClose	os.c	/^void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
sqlite3OsDlError	os.c	/^void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsDlOpen	os.c	/^void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f
sqlite3OsDlSym	os.c	/^void *sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
sqlite3OsFileControl	os.c	/^int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f
sqlite3OsFileSize	os.c	/^int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){$/;"	f
sqlite3OsFullPathname	os.c	/^int sqlite3OsFullPathname($/;"	f
sqlite3OsGetTempname	os.c	/^int sqlite3OsGetTempname(sqlite3_vfs *pVfs, int nBufOut, char *zBufOut){$/;"	f
sqlite3OsLock	os.c	/^int sqlite3OsLock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsOpen	os.c	/^int sqlite3OsOpen($/;"	f
sqlite3OsOpenMalloc	os.c	/^int sqlite3OsOpenMalloc($/;"	f
sqlite3OsRandomness	os.c	/^int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsRead	os.c	/^int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){$/;"	f
sqlite3OsSectorSize	os.c	/^int sqlite3OsSectorSize(sqlite3_file *id){$/;"	f
sqlite3OsSleep	os.c	/^int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f
sqlite3OsSync	os.c	/^int sqlite3OsSync(sqlite3_file *id, int flags){$/;"	f
sqlite3OsTruncate	os.c	/^int sqlite3OsTruncate(sqlite3_file *id, i64 size){$/;"	f
sqlite3OsUnlock	os.c	/^int sqlite3OsUnlock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsWrite	os.c	/^int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){$/;"	f
sqlite3PExpr	expr.c	/^Expr *sqlite3PExpr($/;"	f
sqlite3PagerAcquire	pager.c	/^int sqlite3PagerAcquire($/;"	f
sqlite3PagerBegin	pager.c	/^int sqlite3PagerBegin(DbPage *pPg, int exFlag){$/;"	f
sqlite3PagerClose	pager.c	/^int sqlite3PagerClose(Pager *pPager){$/;"	f
sqlite3PagerCommitPhaseOne	pager.c	/^int sqlite3PagerCommitPhaseOne(Pager *pPager, const char *zMaster, Pgno nTrunc){$/;"	f
sqlite3PagerCommitPhaseTwo	pager.c	/^int sqlite3PagerCommitPhaseTwo(Pager *pPager){$/;"	f
sqlite3PagerDirname	pager.c	/^const char *sqlite3PagerDirname(Pager *pPager){$/;"	f
sqlite3PagerDontRollback	pager.c	/^void sqlite3PagerDontRollback(DbPage *pPg){$/;"	f
sqlite3PagerDontWrite	pager.c	/^void sqlite3PagerDontWrite(DbPage *pDbPage){$/;"	f
sqlite3PagerFile	pager.c	/^sqlite3_file *sqlite3PagerFile(Pager *pPager){$/;"	f
sqlite3PagerFilename	pager.c	/^const char *sqlite3PagerFilename(Pager *pPager){$/;"	f
sqlite3PagerGet	pager.h	67;"	d
sqlite3PagerGetData	pager.c	/^void *sqlite3PagerGetData(DbPage *pPg){$/;"	f
sqlite3PagerGetExtra	pager.c	/^void *sqlite3PagerGetExtra(DbPage *pPg){$/;"	f
sqlite3PagerIsreadonly	pager.c	/^int sqlite3PagerIsreadonly(Pager *pPager){$/;"	f
sqlite3PagerIswriteable	pager.c	/^int sqlite3PagerIswriteable(DbPage *pPg){$/;"	f
sqlite3PagerJournalname	pager.c	/^const char *sqlite3PagerJournalname(Pager *pPager){$/;"	f
sqlite3PagerList	pager.c	/^static Pager *sqlite3PagerList = 0;$/;"	v	file:
sqlite3PagerLockingMode	pager.c	/^int sqlite3PagerLockingMode(Pager *pPager, int eMode){$/;"	f
sqlite3PagerLookup	pager.c	/^DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){$/;"	f
sqlite3PagerMaxPageCount	pager.c	/^int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerMovepage	pager.c	/^int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno){$/;"	f
sqlite3PagerNosync	pager.c	/^int sqlite3PagerNosync(Pager *pPager){$/;"	f
sqlite3PagerOpen	pager.c	/^int sqlite3PagerOpen($/;"	f
sqlite3PagerOpentemp	pager.c	/^static int sqlite3PagerOpentemp($/;"	f	file:
sqlite3PagerOverwrite	pager.c	/^int sqlite3PagerOverwrite(Pager *pPager, Pgno pgno, void *pData){$/;"	f
sqlite3PagerPagecount	pager.c	/^int sqlite3PagerPagecount(Pager *pPager){$/;"	f
sqlite3PagerPagenumber	pager.c	/^Pgno sqlite3PagerPagenumber(DbPage *p){$/;"	f
sqlite3PagerReadFileheader	pager.c	/^int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){$/;"	f
sqlite3PagerRef	pager.c	/^int sqlite3PagerRef(DbPage *pPg){$/;"	f
sqlite3PagerRefcount	pager.c	/^int sqlite3PagerRefcount(Pager *pPager){$/;"	f
sqlite3PagerRefdump	pager.c	/^void sqlite3PagerRefdump(Pager *pPager){$/;"	f
sqlite3PagerReleaseMemory	pager.c	/^int sqlite3PagerReleaseMemory(int nReq){$/;"	f
sqlite3PagerRollback	pager.c	/^int sqlite3PagerRollback(Pager *pPager){$/;"	f
sqlite3PagerSetBusyhandler	pager.c	/^void sqlite3PagerSetBusyhandler(Pager *pPager, BusyHandler *pBusyHandler){$/;"	f
sqlite3PagerSetCachesize	pager.c	/^void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerSetCodec	pager.c	/^void sqlite3PagerSetCodec($/;"	f
sqlite3PagerSetDestructor	pager.c	/^void sqlite3PagerSetDestructor(Pager *pPager, void (*xDesc)(DbPage*,int)){$/;"	f
sqlite3PagerSetPagesize	pager.c	/^int sqlite3PagerSetPagesize(Pager *pPager, u16 *pPageSize){$/;"	f
sqlite3PagerSetReiniter	pager.c	/^void sqlite3PagerSetReiniter(Pager *pPager, void (*xReinit)(DbPage*,int)){$/;"	f
sqlite3PagerSetSafetyLevel	pager.c	/^void sqlite3PagerSetSafetyLevel(Pager *pPager, int level, int full_fsync){$/;"	f
sqlite3PagerStats	pager.c	/^int *sqlite3PagerStats(Pager *pPager){$/;"	f
sqlite3PagerStmtBegin	pager.c	/^int sqlite3PagerStmtBegin(Pager *pPager){$/;"	f
sqlite3PagerStmtCommit	pager.c	/^int sqlite3PagerStmtCommit(Pager *pPager){$/;"	f
sqlite3PagerStmtRollback	pager.c	/^int sqlite3PagerStmtRollback(Pager *pPager){$/;"	f
sqlite3PagerTempSpace	pager.c	/^void *sqlite3PagerTempSpace(Pager *pPager){$/;"	f
sqlite3PagerTruncate	pager.c	/^int sqlite3PagerTruncate(Pager *pPager, Pgno nPage){$/;"	f
sqlite3PagerUnref	pager.c	/^int sqlite3PagerUnref(DbPage *pPg){$/;"	f
sqlite3PagerVfs	pager.c	/^const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){$/;"	f
sqlite3PagerWrite	pager.c	/^int sqlite3PagerWrite(DbPage *pDbPage){$/;"	f
sqlite3Pragma	pragma.c	/^void sqlite3Pragma($/;"	f
sqlite3Prepare	prepare.c	/^int sqlite3Prepare($/;"	f
sqlite3Prepare16	prepare.c	/^static int sqlite3Prepare16($/;"	f	file:
sqlite3PrintExpr	select.c	/^void sqlite3PrintExpr(Expr *p){$/;"	f
sqlite3PrintExprList	select.c	/^void sqlite3PrintExprList(ExprList *pList){$/;"	f
sqlite3PrintSelect	select.c	/^void sqlite3PrintSelect(Select *p, int indent){$/;"	f
sqlite3Prng	random.c	/^} sqlite3Prng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3PrngType	random.c	/^static struct sqlite3PrngType {$/;"	s	file:
sqlite3Put4byte	util.c	/^void sqlite3Put4byte(unsigned char *p, u32 v){$/;"	f
sqlite3PutVarint	util.c	/^int sqlite3PutVarint(unsigned char *p, u64 v){$/;"	f
sqlite3Randomness	random.c	/^void sqlite3Randomness(int N, void *pBuf){$/;"	f
sqlite3ReadSchema	prepare.c	/^int sqlite3ReadSchema(Parse *pParse){$/;"	f
sqlite3RefillIndex	build.c	/^static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){$/;"	f	file:
sqlite3RegisterBuiltinFunctions	func.c	/^void sqlite3RegisterBuiltinFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterDateTimeFunctions	date.c	/^void sqlite3RegisterDateTimeFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterExpr	expr.c	/^Expr *sqlite3RegisterExpr(Parse *pParse, Token *pToken){$/;"	f
sqlite3RegisterLikeFunctions	func.c	/^void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){$/;"	f
sqlite3Reindex	build.c	/^void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ReleaseTempRange	expr.c	/^void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){$/;"	f
sqlite3ReleaseTempReg	expr.c	/^void sqlite3ReleaseTempReg(Parse *pParse, int iReg){$/;"	f
sqlite3Reprepare	prepare.c	/^int sqlite3Reprepare(Vdbe *p){$/;"	f
sqlite3ResetInternalSchema	build.c	/^void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){$/;"	f
sqlite3ResetPrngState	random.c	/^void sqlite3ResetPrngState(void){$/;"	f
sqlite3RestorePrngState	random.c	/^void sqlite3RestorePrngState(void){$/;"	f
sqlite3ResultSetOfSelect	select.c	/^Table *sqlite3ResultSetOfSelect(Parse *pParse, char *zTabName, Select *pSelect){$/;"	f
sqlite3RollbackAll	main.c	/^void sqlite3RollbackAll(sqlite3 *db){$/;"	f
sqlite3RollbackTransaction	build.c	/^void sqlite3RollbackTransaction(Parse *pParse){$/;"	f
sqlite3RootPageMoved	build.c	/^void sqlite3RootPageMoved(Db *pDb, int iFrom, int iTo){$/;"	f
sqlite3RunParser	tokenize.c	/^int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){$/;"	f
sqlite3RunVacuum	vacuum.c	/^int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){$/;"	f
sqlite3SafetyCheckOk	util.c	/^int sqlite3SafetyCheckOk(sqlite3 *db){$/;"	f
sqlite3SafetyCheckSickOrOk	util.c	/^int sqlite3SafetyCheckSickOrOk(sqlite3 *db){$/;"	f
sqlite3SafetyOff	sqliteInt.h	1825;"	d
sqlite3SafetyOff	util.c	/^int sqlite3SafetyOff(sqlite3 *db){$/;"	f
sqlite3SafetyOn	sqliteInt.h	1824;"	d
sqlite3SafetyOn	util.c	/^int sqlite3SafetyOn(sqlite3 *db){$/;"	f
sqlite3SavePrngState	random.c	/^void sqlite3SavePrngState(void){$/;"	f
sqlite3SavedPrng	random.c	/^static struct sqlite3PrngType sqlite3SavedPrng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3SchemaFree	callback.c	/^void sqlite3SchemaFree(void *p){$/;"	f
sqlite3SchemaGet	callback.c	/^Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){$/;"	f
sqlite3SchemaToIndex	prepare.c	/^int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){$/;"	f
sqlite3Select	select.c	/^int sqlite3Select($/;"	f
sqlite3SelectDelete	select.c	/^void sqlite3SelectDelete(Select *p){$/;"	f
sqlite3SelectDestInit	select.c	/^void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){$/;"	f
sqlite3SelectDup	expr.c	/^Select *sqlite3SelectDup(sqlite3 *db, Select *p){$/;"	f
sqlite3SelectExprHeight	expr.c	/^int sqlite3SelectExprHeight(Select *p){$/;"	f
sqlite3SelectMask	select.c	/^void sqlite3SelectMask(Parse *pParse, Select *p, u32 mask){$/;"	f
sqlite3SelectNew	select.c	/^Select *sqlite3SelectNew($/;"	f
sqlite3SelectResolve	select.c	/^int sqlite3SelectResolve($/;"	f
sqlite3SetString	malloc.c	/^void sqlite3SetString(char **pz, ...){$/;"	f
sqlite3SharedCacheEnabled	btree.c	/^int sqlite3SharedCacheEnabled = 0;$/;"	v
sqlite3SharedCacheEnabled	btree.c	/^static int sqlite3SharedCacheEnabled = 0;$/;"	v	file:
sqlite3SharedCacheList	btree.c	/^BtShared *sqlite3SharedCacheList = 0;$/;"	v
sqlite3SharedCacheList	btree.c	/^static BtShared *sqlite3SharedCacheList = 0;$/;"	v	file:
sqlite3SrcListAppend	build.c	/^SrcList *sqlite3SrcListAppend($/;"	f
sqlite3SrcListAppendFromTerm	build.c	/^SrcList *sqlite3SrcListAppendFromTerm($/;"	f
sqlite3SrcListAssignCursors	build.c	/^void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){$/;"	f
sqlite3SrcListDelete	build.c	/^void sqlite3SrcListDelete(SrcList *pList){$/;"	f
sqlite3SrcListDup	expr.c	/^SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p){$/;"	f
sqlite3SrcListLookup	delete.c	/^Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3SrcListShiftJoinType	build.c	/^void sqlite3SrcListShiftJoinType(SrcList *p){$/;"	f
sqlite3StackDepth	test1.c	/^u64 sqlite3StackDepth(void){$/;"	f
sqlite3StartTable	build.c	/^void sqlite3StartTable($/;"	f
sqlite3Step	vdbeapi.c	/^static int sqlite3Step(Vdbe *p){$/;"	f	file:
sqlite3StrAccumAppend	printf.c	/^void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){$/;"	f
sqlite3StrAccumFinish	printf.c	/^char *sqlite3StrAccumFinish(StrAccum *p){$/;"	f
sqlite3StrAccumInit	printf.c	/^static void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n){$/;"	f	file:
sqlite3StrAccumReset	printf.c	/^void sqlite3StrAccumReset(StrAccum *p){$/;"	f
sqlite3StrDup	malloc.c	/^char *sqlite3StrDup(const char *z){$/;"	f
sqlite3StrICmp	util.c	/^int sqlite3StrICmp(const char *zLeft, const char *zRight){$/;"	f
sqlite3StrNDup	malloc.c	/^char *sqlite3StrNDup(const char *z, int n){$/;"	f
sqlite3StrNICmp	util.c	/^int sqlite3StrNICmp(const char *zLeft, const char *zRight, int N){$/;"	f
sqlite3TableAffinityStr	insert.c	/^void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){$/;"	f
sqlite3TableLock	build.c	/^void sqlite3TableLock($/;"	f
sqlite3TableLock	sqliteInt.h	1979;"	d
sqlite3TestBinToHex	test_hexio.c	/^void sqlite3TestBinToHex(unsigned char *zBuf, int N){$/;"	f
sqlite3TestErrCode	test1.c	/^int sqlite3TestErrCode(Tcl_Interp *interp, sqlite3 *db, int rc){$/;"	f
sqlite3TestErrorName	test1.c	/^const char *sqlite3TestErrorName(int rc){$/;"	f
sqlite3TestHexToBin	test_hexio.c	/^int sqlite3TestHexToBin(const unsigned char *zIn, int N, unsigned char *aOut){$/;"	f
sqlite3TestLockingStyle	os_unix.c	/^static sqlite3LockingStyle sqlite3TestLockingStyle($/;"	f	file:
sqlite3TestMakePointerStr	test1.c	/^int sqlite3TestMakePointerStr(Tcl_Interp *interp, char *zPtr, void *p){$/;"	f
sqlite3TextToPtr	test1.c	/^void *sqlite3TextToPtr(const char *z){$/;"	f
sqlite3TokenCopy	expr.c	/^void sqlite3TokenCopy(sqlite3 *db, Token *pTo, Token *pFrom){$/;"	f
sqlite3TriggerDeleteStep	trigger.c	/^TriggerStep *sqlite3TriggerDeleteStep($/;"	f
sqlite3TriggerInsertStep	trigger.c	/^TriggerStep *sqlite3TriggerInsertStep($/;"	f
sqlite3TriggerSelectStep	trigger.c	/^TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){$/;"	f
sqlite3TriggerUpdateStep	trigger.c	/^TriggerStep *sqlite3TriggerUpdateStep($/;"	f
sqlite3TriggersExist	sqliteInt.h	1850;"	d
sqlite3TriggersExist	trigger.c	/^int sqlite3TriggersExist($/;"	f
sqlite3TwoPartName	build.c	/^int sqlite3TwoPartName($/;"	f
sqlite3UnixIoMethod	os_unix.c	/^static const sqlite3_io_methods sqlite3UnixIoMethod = {$/;"	v	file:
sqlite3UnlinkAndDeleteIndex	build.c	/^void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){$/;"	f
sqlite3UnlinkAndDeleteTable	build.c	/^void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){$/;"	f
sqlite3UnlinkAndDeleteTrigger	sqliteInt.h	1853;"	d
sqlite3UnlinkAndDeleteTrigger	trigger.c	/^void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){$/;"	f
sqlite3Update	update.c	/^void sqlite3Update($/;"	f
sqlite3UpperToLower	util.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3Utf16ByteLen	utf.c	/^int sqlite3Utf16ByteLen(const void *zIn, int nChar){$/;"	f
sqlite3Utf16to8	utf.c	/^char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte){$/;"	f
sqlite3Utf8CharLen	utf.c	/^int sqlite3Utf8CharLen(const char *zIn, int nByte){$/;"	f
sqlite3Utf8Read	func.c	415;"	d	file:
sqlite3Utf8Read	utf.c	/^int sqlite3Utf8Read($/;"	f
sqlite3Utf8To8	utf.c	/^int sqlite3Utf8To8(unsigned char *zIn){$/;"	f
sqlite3UtfSelfTest	utf.c	/^void sqlite3UtfSelfTest(){$/;"	f
sqlite3UtfTrans1	utf.c	/^static const unsigned char sqlite3UtfTrans1[] = {$/;"	v	file:
sqlite3VMPrintf	printf.c	/^char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){$/;"	f
sqlite3Vacuum	vacuum.c	/^void sqlite3Vacuum(Parse *pParse){$/;"	f
sqlite3ValueApplyAffinity	vdbe.c	/^void sqlite3ValueApplyAffinity($/;"	f
sqlite3ValueBytes	vdbemem.c	/^int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){$/;"	f
sqlite3ValueFree	vdbemem.c	/^void sqlite3ValueFree(sqlite3_value *v){$/;"	f
sqlite3ValueFromExpr	vdbemem.c	/^int sqlite3ValueFromExpr($/;"	f
sqlite3ValueNew	vdbemem.c	/^sqlite3_value *sqlite3ValueNew(sqlite3 *db){$/;"	f
sqlite3ValueSetStr	vdbemem.c	/^void sqlite3ValueSetStr($/;"	f
sqlite3ValueText	vdbemem.c	/^const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){$/;"	f
sqlite3VarintLen	util.c	/^int sqlite3VarintLen(u64 v){$/;"	f
sqlite3VdbeAddOp0	vdbeaux.c	/^int sqlite3VdbeAddOp0(Vdbe *p, int op){$/;"	f
sqlite3VdbeAddOp1	vdbeaux.c	/^int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){$/;"	f
sqlite3VdbeAddOp2	vdbeaux.c	/^int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){$/;"	f
sqlite3VdbeAddOp3	vdbeaux.c	/^int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){$/;"	f
sqlite3VdbeAddOp4	vdbeaux.c	/^int sqlite3VdbeAddOp4($/;"	f
sqlite3VdbeAddOpList	vdbeaux.c	/^int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){$/;"	f
sqlite3VdbeChangeEncoding	vdbemem.c	/^int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){$/;"	f
sqlite3VdbeChangeP1	vdbeaux.c	/^void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP2	vdbeaux.c	/^void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP3	vdbeaux.c	/^void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP4	vdbeaux.c	/^void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){$/;"	f
sqlite3VdbeChangeP5	vdbeaux.c	/^void sqlite3VdbeChangeP5(Vdbe *p, u8 val){$/;"	f
sqlite3VdbeChangeToNoop	vdbeaux.c	/^void sqlite3VdbeChangeToNoop(Vdbe *p, int addr, int N){$/;"	f
sqlite3VdbeComment	vdbeaux.c	/^void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeCountChanges	vdbeaux.c	/^void sqlite3VdbeCountChanges(Vdbe *v){$/;"	f
sqlite3VdbeCreate	vdbeaux.c	/^Vdbe *sqlite3VdbeCreate(sqlite3 *db){$/;"	f
sqlite3VdbeCurrentAddr	vdbeaux.c	/^int sqlite3VdbeCurrentAddr(Vdbe *p){$/;"	f
sqlite3VdbeCursorMoveto	vdbeaux.c	/^int sqlite3VdbeCursorMoveto(Cursor *p){$/;"	f
sqlite3VdbeDb	vdbeaux.c	/^sqlite3 *sqlite3VdbeDb(Vdbe *v){$/;"	f
sqlite3VdbeDelete	vdbeaux.c	/^void sqlite3VdbeDelete(Vdbe *p){$/;"	f
sqlite3VdbeDeleteAuxData	vdbeaux.c	/^void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){$/;"	f
sqlite3VdbeExec	vdbe.c	/^int sqlite3VdbeExec($/;"	f
sqlite3VdbeFifoClear	vdbefifo.c	/^void sqlite3VdbeFifoClear(Fifo *pFifo){$/;"	f
sqlite3VdbeFifoInit	vdbefifo.c	/^void sqlite3VdbeFifoInit(Fifo *pFifo){$/;"	f
sqlite3VdbeFifoPop	vdbefifo.c	/^int sqlite3VdbeFifoPop(Fifo *pFifo, i64 *pVal){$/;"	f
sqlite3VdbeFifoPush	vdbefifo.c	/^int sqlite3VdbeFifoPush(Fifo *pFifo, i64 val){$/;"	f
sqlite3VdbeFinalize	vdbeaux.c	/^int sqlite3VdbeFinalize(Vdbe *p){$/;"	f
sqlite3VdbeFreeCursor	vdbeaux.c	/^void sqlite3VdbeFreeCursor(Vdbe *p, Cursor *pCx){$/;"	f
sqlite3VdbeGetOp	vdbeaux.c	/^VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){$/;"	f
sqlite3VdbeHalt	vdbeaux.c	/^int sqlite3VdbeHalt(Vdbe *p){$/;"	f
sqlite3VdbeIOTraceSql	sqliteInt.h	2084;"	d
sqlite3VdbeIOTraceSql	vdbeaux.c	/^void sqlite3VdbeIOTraceSql(Vdbe *p){$/;"	f
sqlite3VdbeIdxKeyCompare	vdbeaux.c	/^int sqlite3VdbeIdxKeyCompare($/;"	f
sqlite3VdbeIdxRowid	vdbeaux.c	/^int sqlite3VdbeIdxRowid(BtCursor *pCur, i64 *rowid){$/;"	f
sqlite3VdbeIdxRowidLen	vdbeaux.c	/^int sqlite3VdbeIdxRowidLen(const u8 *aKey){$/;"	f
sqlite3VdbeIntValue	vdbemem.c	/^i64 sqlite3VdbeIntValue(Mem *pMem){$/;"	f
sqlite3VdbeIntegerAffinity	vdbemem.c	/^void sqlite3VdbeIntegerAffinity(Mem *pMem){$/;"	f
sqlite3VdbeJumpHere	vdbeaux.c	/^void sqlite3VdbeJumpHere(Vdbe *p, int addr){$/;"	f
sqlite3VdbeList	vdbeaux.c	/^int sqlite3VdbeList($/;"	f
sqlite3VdbeMakeLabel	vdbeaux.c	/^int sqlite3VdbeMakeLabel(Vdbe *p){$/;"	f
sqlite3VdbeMakeReady	vdbeaux.c	/^void sqlite3VdbeMakeReady($/;"	f
sqlite3VdbeMemCopy	vdbemem.c	/^int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){$/;"	f
sqlite3VdbeMemDynamicify	vdbemem.c	/^int sqlite3VdbeMemDynamicify(Mem *pMem){$/;"	f
sqlite3VdbeMemExpandBlob	vdbeInt.h	419;"	d
sqlite3VdbeMemExpandBlob	vdbemem.c	/^int sqlite3VdbeMemExpandBlob(Mem *pMem){$/;"	f
sqlite3VdbeMemFinalize	vdbemem.c	/^int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){$/;"	f
sqlite3VdbeMemFromBtree	vdbemem.c	/^int sqlite3VdbeMemFromBtree($/;"	f
sqlite3VdbeMemHandleBom	utf.c	/^int sqlite3VdbeMemHandleBom(Mem *pMem){$/;"	f
sqlite3VdbeMemIntegerify	vdbemem.c	/^int sqlite3VdbeMemIntegerify(Mem *pMem){$/;"	f
sqlite3VdbeMemMakeWriteable	vdbemem.c	/^int sqlite3VdbeMemMakeWriteable(Mem *pMem){$/;"	f
sqlite3VdbeMemMove	vdbemem.c	/^void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){$/;"	f
sqlite3VdbeMemNulTerminate	vdbemem.c	/^int sqlite3VdbeMemNulTerminate(Mem *pMem){$/;"	f
sqlite3VdbeMemNumerify	vdbemem.c	/^int sqlite3VdbeMemNumerify(Mem *pMem){$/;"	f
sqlite3VdbeMemPrettyPrint	vdbe.c	/^void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf){$/;"	f
sqlite3VdbeMemRealify	vdbemem.c	/^int sqlite3VdbeMemRealify(Mem *pMem){$/;"	f
sqlite3VdbeMemRelease	vdbemem.c	/^void sqlite3VdbeMemRelease(Mem *p){$/;"	f
sqlite3VdbeMemSetDouble	vdbemem.c	/^void sqlite3VdbeMemSetDouble(Mem *pMem, double val){$/;"	f
sqlite3VdbeMemSetInt64	vdbemem.c	/^void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){$/;"	f
sqlite3VdbeMemSetNull	vdbemem.c	/^void sqlite3VdbeMemSetNull(Mem *pMem){$/;"	f
sqlite3VdbeMemSetStr	vdbemem.c	/^int sqlite3VdbeMemSetStr($/;"	f
sqlite3VdbeMemSetZeroBlob	vdbemem.c	/^void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){$/;"	f
sqlite3VdbeMemShallowCopy	vdbemem.c	/^void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){$/;"	f
sqlite3VdbeMemStringify	vdbemem.c	/^int sqlite3VdbeMemStringify(Mem *pMem, int enc){$/;"	f
sqlite3VdbeMemTooBig	vdbemem.c	/^int sqlite3VdbeMemTooBig(Mem *p){$/;"	f
sqlite3VdbeMemTranslate	utf.c	/^int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){$/;"	f
sqlite3VdbeOpcodeHasProperty	vdbe.c	/^int sqlite3VdbeOpcodeHasProperty(int opcode, int mask){$/;"	f
sqlite3VdbePrintOp	vdbeaux.c	/^void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){$/;"	f
sqlite3VdbePrintSql	vdbeaux.c	/^void sqlite3VdbePrintSql(Vdbe *p){$/;"	f
sqlite3VdbeRealValue	vdbemem.c	/^double sqlite3VdbeRealValue(Mem *pMem){$/;"	f
sqlite3VdbeRecordCompare	vdbeaux.c	/^int sqlite3VdbeRecordCompare($/;"	f
sqlite3VdbeReset	vdbeaux.c	/^int sqlite3VdbeReset(Vdbe *p){$/;"	f
sqlite3VdbeResetStepResult	vdbeaux.c	/^void sqlite3VdbeResetStepResult(Vdbe *p){$/;"	f
sqlite3VdbeResolveLabel	vdbeaux.c	/^void sqlite3VdbeResolveLabel(Vdbe *p, int x){$/;"	f
sqlite3VdbeSerialGet	vdbeaux.c	/^int sqlite3VdbeSerialGet($/;"	f
sqlite3VdbeSerialPut	vdbeaux.c	/^int sqlite3VdbeSerialPut(u8 *buf, int nBuf, Mem *pMem, int file_format){$/;"	f
sqlite3VdbeSerialType	vdbeaux.c	/^u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){$/;"	f
sqlite3VdbeSerialTypeLen	vdbeaux.c	/^int sqlite3VdbeSerialTypeLen(u32 serial_type){$/;"	f
sqlite3VdbeSetChanges	vdbeaux.c	/^void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){$/;"	f
sqlite3VdbeSetColName	vdbeaux.c	/^int sqlite3VdbeSetColName(Vdbe *p, int idx, int var, const char *zName, int N){$/;"	f
sqlite3VdbeSetNumCols	vdbeaux.c	/^void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){$/;"	f
sqlite3VdbeSetSql	vdbeaux.c	/^void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n){$/;"	f
sqlite3VdbeSwap	vdbeaux.c	/^void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){$/;"	f
sqlite3VdbeTrace	vdbeaux.c	/^void sqlite3VdbeTrace(Vdbe *p, FILE *trace){$/;"	f
sqlite3VdbeUsesBtree	vdbeaux.c	/^void sqlite3VdbeUsesBtree(Vdbe *p, int i){$/;"	f
sqlite3ViewGetColumnNames	build.c	/^int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){$/;"	f
sqlite3ViewGetColumnNames	sqliteInt.h	1740;"	d
sqlite3VtabArgExtend	vtab.c	/^void sqlite3VtabArgExtend(Parse *pParse, Token *p){$/;"	f
sqlite3VtabArgInit	vtab.c	/^void sqlite3VtabArgInit(Parse *pParse){$/;"	f
sqlite3VtabBegin	vtab.c	/^int sqlite3VtabBegin(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f
sqlite3VtabBeginParse	vtab.c	/^void sqlite3VtabBeginParse($/;"	f
sqlite3VtabCallConnect	vtab.c	/^int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){$/;"	f
sqlite3VtabCallCreate	vtab.c	/^int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){$/;"	f
sqlite3VtabCallDestroy	vtab.c	/^int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab)$/;"	f
sqlite3VtabClear	sqliteInt.h	1987;"	d
sqlite3VtabClear	vtab.c	/^void sqlite3VtabClear(Table *p){$/;"	f
sqlite3VtabCommit	sqliteInt.h	1990;"	d
sqlite3VtabCommit	vtab.c	/^int sqlite3VtabCommit(sqlite3 *db){$/;"	f
sqlite3VtabFinishParse	vtab.c	/^void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){$/;"	f
sqlite3VtabLock	vtab.c	/^void sqlite3VtabLock(sqlite3_vtab *pVtab){$/;"	f
sqlite3VtabOverloadFunction	vtab.c	/^FuncDef *sqlite3VtabOverloadFunction($/;"	f
sqlite3VtabRollback	sqliteInt.h	1989;"	d
sqlite3VtabRollback	vtab.c	/^int sqlite3VtabRollback(sqlite3 *db){$/;"	f
sqlite3VtabSync	sqliteInt.h	1988;"	d
sqlite3VtabSync	vtab.c	/^int sqlite3VtabSync(sqlite3 *db, int rc2){$/;"	f
sqlite3VtabUnlock	vtab.c	/^void sqlite3VtabUnlock(sqlite3 *db, sqlite3_vtab *pVtab){$/;"	f
sqlite3WhereBegin	where.c	/^WhereInfo *sqlite3WhereBegin($/;"	f
sqlite3WhereEnd	where.c	/^void sqlite3WhereEnd(WhereInfo *pWInfo){$/;"	f
sqlite3_aggregate_context	sqlite3ext.h	199;"	d
sqlite3_aggregate_context	vdbeapi.c	/^void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){$/;"	f
sqlite3_aggregate_count	sqlite3ext.h	200;"	d
sqlite3_aggregate_count	vdbeapi.c	/^int sqlite3_aggregate_count(sqlite3_context *p){$/;"	f
sqlite3_api_routines	sqlite3ext.h	/^struct sqlite3_api_routines {$/;"	s
sqlite3_api_routines	sqlite3ext.h	/^typedef struct sqlite3_api_routines sqlite3_api_routines;$/;"	t	typeref:struct:sqlite3_api_routines
sqlite3_apis	loadext.c	/^const sqlite3_api_routines sqlite3_apis = {$/;"	v
sqlite3_auto_extension	loadext.c	/^int sqlite3_auto_extension(void *xInit){$/;"	f
sqlite3_bind_blob	sqlite3ext.h	201;"	d
sqlite3_bind_blob	vdbeapi.c	/^int sqlite3_bind_blob($/;"	f
sqlite3_bind_double	sqlite3ext.h	202;"	d
sqlite3_bind_double	vdbeapi.c	/^int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){$/;"	f
sqlite3_bind_int	sqlite3ext.h	203;"	d
sqlite3_bind_int	vdbeapi.c	/^int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){$/;"	f
sqlite3_bind_int64	sqlite3ext.h	204;"	d
sqlite3_bind_int64	vdbeapi.c	/^int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){$/;"	f
sqlite3_bind_null	sqlite3ext.h	205;"	d
sqlite3_bind_null	vdbeapi.c	/^int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_parameter_count	sqlite3ext.h	206;"	d
sqlite3_bind_parameter_count	vdbeapi.c	/^int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_bind_parameter_index	sqlite3ext.h	207;"	d
sqlite3_bind_parameter_index	vdbeapi.c	/^int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){$/;"	f
sqlite3_bind_parameter_name	sqlite3ext.h	208;"	d
sqlite3_bind_parameter_name	vdbeapi.c	/^const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_text	sqlite3ext.h	209;"	d
sqlite3_bind_text	vdbeapi.c	/^int sqlite3_bind_text( $/;"	f
sqlite3_bind_text16	loadext.c	45;"	d	file:
sqlite3_bind_text16	sqlite3ext.h	210;"	d
sqlite3_bind_text16	vdbeapi.c	/^int sqlite3_bind_text16($/;"	f
sqlite3_bind_value	sqlite3ext.h	211;"	d
sqlite3_bind_value	vdbeapi.c	/^int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){$/;"	f
sqlite3_bind_zeroblob	loadext.c	99;"	d	file:
sqlite3_bind_zeroblob	sqlite3ext.h	321;"	d
sqlite3_bind_zeroblob	vdbeapi.c	/^int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){$/;"	f
sqlite3_blob_bytes	loadext.c	100;"	d	file:
sqlite3_blob_bytes	sqlite3ext.h	322;"	d
sqlite3_blob_bytes	vdbeblob.c	/^int sqlite3_blob_bytes(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_close	loadext.c	101;"	d	file:
sqlite3_blob_close	sqlite3ext.h	323;"	d
sqlite3_blob_close	vdbeblob.c	/^int sqlite3_blob_close(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_open	loadext.c	102;"	d	file:
sqlite3_blob_open	sqlite3ext.h	324;"	d
sqlite3_blob_open	vdbeblob.c	/^int sqlite3_blob_open($/;"	f
sqlite3_blob_read	loadext.c	103;"	d	file:
sqlite3_blob_read	sqlite3ext.h	325;"	d
sqlite3_blob_read	vdbeblob.c	/^int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){$/;"	f
sqlite3_blob_write	loadext.c	104;"	d	file:
sqlite3_blob_write	sqlite3ext.h	326;"	d
sqlite3_blob_write	vdbeblob.c	/^int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){$/;"	f
sqlite3_btree_trace	btree.c	/^int sqlite3_btree_trace=0;  \/* True to enable tracing *\/$/;"	v
sqlite3_busy_handler	main.c	/^int sqlite3_busy_handler($/;"	f
sqlite3_busy_handler	sqlite3ext.h	212;"	d
sqlite3_busy_timeout	main.c	/^int sqlite3_busy_timeout(sqlite3 *db, int ms){$/;"	f
sqlite3_busy_timeout	sqlite3ext.h	213;"	d
sqlite3_changes	main.c	/^int sqlite3_changes(sqlite3 *db){$/;"	f
sqlite3_changes	sqlite3ext.h	214;"	d
sqlite3_clear_bindings	sqlite3ext.h	320;"	d
sqlite3_clear_bindings	vdbeapi.c	/^int sqlite3_clear_bindings(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_close	test_server.c	/^int sqlite3_client_close(sqlite3 *pDb){$/;"	f
sqlite3_client_finalize	test_server.c	/^int sqlite3_client_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_open	test_server.c	/^int sqlite3_client_open(const char *zDatabaseName, sqlite3 **ppDb){$/;"	f
sqlite3_client_prepare	test_server.c	/^int sqlite3_client_prepare($/;"	f
sqlite3_client_reset	test_server.c	/^int sqlite3_client_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_step	test_server.c	/^int sqlite3_client_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_close	main.c	/^int sqlite3_close(sqlite3 *db){$/;"	f
sqlite3_close	sqlite3ext.h	215;"	d
sqlite3_collation_needed	main.c	/^int sqlite3_collation_needed($/;"	f
sqlite3_collation_needed	sqlite3ext.h	216;"	d
sqlite3_collation_needed16	loadext.c	46;"	d	file:
sqlite3_collation_needed16	main.c	/^int sqlite3_collation_needed16($/;"	f
sqlite3_collation_needed16	sqlite3ext.h	217;"	d
sqlite3_column_blob	sqlite3ext.h	218;"	d
sqlite3_column_blob	vdbeapi.c	/^const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes	sqlite3ext.h	219;"	d
sqlite3_column_bytes	vdbeapi.c	/^int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes16	sqlite3ext.h	220;"	d
sqlite3_column_bytes16	vdbeapi.c	/^int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_count	sqlite3ext.h	221;"	d
sqlite3_column_count	vdbeapi.c	/^int sqlite3_column_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_column_database_name	loadext.c	31;"	d	file:
sqlite3_column_database_name	sqlite3ext.h	222;"	d
sqlite3_column_database_name	vdbeapi.c	/^const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_database_name16	loadext.c	32;"	d	file:
sqlite3_column_database_name16	loadext.c	64;"	d	file:
sqlite3_column_database_name16	sqlite3ext.h	223;"	d
sqlite3_column_database_name16	vdbeapi.c	/^const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype	sqlite3ext.h	224;"	d
sqlite3_column_decltype	vdbeapi.c	/^const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype16	loadext.c	47;"	d	file:
sqlite3_column_decltype16	sqlite3ext.h	225;"	d
sqlite3_column_decltype16	vdbeapi.c	/^const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_double	sqlite3ext.h	226;"	d
sqlite3_column_double	vdbeapi.c	/^double sqlite3_column_double(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int	sqlite3ext.h	227;"	d
sqlite3_column_int	vdbeapi.c	/^int sqlite3_column_int(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int64	sqlite3ext.h	228;"	d
sqlite3_column_int64	vdbeapi.c	/^sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_name	sqlite3ext.h	229;"	d
sqlite3_column_name	vdbeapi.c	/^const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_name16	loadext.c	48;"	d	file:
sqlite3_column_name16	sqlite3ext.h	230;"	d
sqlite3_column_name16	vdbeapi.c	/^const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name	loadext.c	35;"	d	file:
sqlite3_column_origin_name	sqlite3ext.h	231;"	d
sqlite3_column_origin_name	vdbeapi.c	/^const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name16	loadext.c	36;"	d	file:
sqlite3_column_origin_name16	loadext.c	66;"	d	file:
sqlite3_column_origin_name16	sqlite3ext.h	232;"	d
sqlite3_column_origin_name16	vdbeapi.c	/^const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name	loadext.c	33;"	d	file:
sqlite3_column_table_name	sqlite3ext.h	233;"	d
sqlite3_column_table_name	vdbeapi.c	/^const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name16	loadext.c	34;"	d	file:
sqlite3_column_table_name16	loadext.c	65;"	d	file:
sqlite3_column_table_name16	sqlite3ext.h	234;"	d
sqlite3_column_table_name16	vdbeapi.c	/^const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_text	sqlite3ext.h	235;"	d
sqlite3_column_text	vdbeapi.c	/^const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_text16	loadext.c	49;"	d	file:
sqlite3_column_text16	sqlite3ext.h	236;"	d
sqlite3_column_text16	vdbeapi.c	/^const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_type	sqlite3ext.h	237;"	d
sqlite3_column_type	vdbeapi.c	/^int sqlite3_column_type(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_value	sqlite3ext.h	238;"	d
sqlite3_column_value	vdbeapi.c	/^sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_commit_hook	main.c	/^void *sqlite3_commit_hook($/;"	f
sqlite3_commit_hook	sqlite3ext.h	239;"	d
sqlite3_complete	complete.c	/^int sqlite3_complete(const char *zSql){$/;"	f
sqlite3_complete	loadext.c	70;"	d	file:
sqlite3_complete	sqlite3ext.h	240;"	d
sqlite3_complete16	complete.c	/^int sqlite3_complete16(const void *zSql){$/;"	f
sqlite3_complete16	loadext.c	50;"	d	file:
sqlite3_complete16	loadext.c	71;"	d	file:
sqlite3_complete16	sqlite3ext.h	241;"	d
sqlite3_context	vdbeInt.h	/^struct sqlite3_context {$/;"	s
sqlite3_create_collation	main.c	/^int sqlite3_create_collation($/;"	f
sqlite3_create_collation	sqlite3ext.h	242;"	d
sqlite3_create_collation16	loadext.c	51;"	d	file:
sqlite3_create_collation16	main.c	/^int sqlite3_create_collation16($/;"	f
sqlite3_create_collation16	sqlite3ext.h	243;"	d
sqlite3_create_collation_v2	main.c	/^int sqlite3_create_collation_v2($/;"	f
sqlite3_create_collation_v2	sqlite3ext.h	327;"	d
sqlite3_create_function	main.c	/^int sqlite3_create_function($/;"	f
sqlite3_create_function	sqlite3ext.h	244;"	d
sqlite3_create_function16	loadext.c	52;"	d	file:
sqlite3_create_function16	main.c	/^int sqlite3_create_function16($/;"	f
sqlite3_create_function16	sqlite3ext.h	245;"	d
sqlite3_create_module	loadext.c	79;"	d	file:
sqlite3_create_module	sqlite3ext.h	246;"	d
sqlite3_create_module	vtab.c	/^int sqlite3_create_module($/;"	f
sqlite3_create_module_v2	loadext.c	80;"	d	file:
sqlite3_create_module_v2	sqlite3ext.h	247;"	d
sqlite3_create_module_v2	vtab.c	/^int sqlite3_create_module_v2($/;"	f
sqlite3_current_time	os_os2.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_current_time	os_unix.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_current_time	os_win.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_data_count	sqlite3ext.h	248;"	d
sqlite3_data_count	vdbeapi.c	/^int sqlite3_data_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_db_handle	sqlite3ext.h	249;"	d
sqlite3_db_handle	vdbeapi.c	/^sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){$/;"	f
sqlite3_declare_vtab	loadext.c	81;"	d	file:
sqlite3_declare_vtab	sqlite3ext.h	250;"	d
sqlite3_declare_vtab	vtab.c	/^int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){$/;"	f
sqlite3_diskfull	os_common.h	/^int sqlite3_diskfull = 0;$/;"	v
sqlite3_diskfull_pending	os_common.h	/^int sqlite3_diskfull_pending = 0;$/;"	v
sqlite3_enable_in_opt	expr.c	/^  int sqlite3_enable_in_opt = 1;$/;"	v
sqlite3_enable_in_opt	expr.c	1528;"	d	file:
sqlite3_enable_load_extension	loadext.c	/^int sqlite3_enable_load_extension(sqlite3 *db, int onoff){$/;"	f
sqlite3_enable_shared_cache	btree.c	/^int sqlite3_enable_shared_cache(int enable){$/;"	f
sqlite3_enable_shared_cache	loadext.c	85;"	d	file:
sqlite3_enable_shared_cache	sqlite3ext.h	251;"	d
sqlite3_errcode	main.c	/^int sqlite3_errcode(sqlite3 *db){$/;"	f
sqlite3_errcode	sqlite3ext.h	252;"	d
sqlite3_errmsg	main.c	/^const char *sqlite3_errmsg(sqlite3 *db){$/;"	f
sqlite3_errmsg	sqlite3ext.h	253;"	d
sqlite3_errmsg16	loadext.c	53;"	d	file:
sqlite3_errmsg16	main.c	/^const void *sqlite3_errmsg16(sqlite3 *db){$/;"	f
sqlite3_errmsg16	sqlite3ext.h	254;"	d
sqlite3_exec	legacy.c	/^int sqlite3_exec($/;"	f
sqlite3_exec	sqlite3ext.h	255;"	d
sqlite3_expired	sqlite3ext.h	256;"	d
sqlite3_expired	vdbeapi.c	/^int sqlite3_expired(sqlite3_stmt *pStmt){$/;"	f
sqlite3_extended_result_codes	main.c	/^int sqlite3_extended_result_codes(sqlite3 *db, int onoff){$/;"	f
sqlite3_extension_init	test_schema.c	/^int sqlite3_extension_init($/;"	f
sqlite3_file_control	main.c	/^int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){$/;"	f
sqlite3_file_control	sqlite3ext.h	328;"	d
sqlite3_finalize	sqlite3ext.h	257;"	d
sqlite3_finalize	vdbeapi.c	/^int sqlite3_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_free	mem1.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	mem2.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	mem3.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	mem4.c	/^void sqlite3_free(void *pPrior){$/;"	f
sqlite3_free	sqlite3ext.h	258;"	d
sqlite3_free_table	loadext.c	94;"	d	file:
sqlite3_free_table	sqlite3ext.h	259;"	d
sqlite3_free_table	table.c	/^void sqlite3_free_table($/;"	f
sqlite3_fullsync_count	os_os2.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_fullsync_count	os_unix.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_fullsync_count	os_win.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_get_autocommit	main.c	/^int sqlite3_get_autocommit(sqlite3 *db){$/;"	f
sqlite3_get_autocommit	sqlite3ext.h	260;"	d
sqlite3_get_auxdata	sqlite3ext.h	261;"	d
sqlite3_get_auxdata	vdbeapi.c	/^void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){$/;"	f
sqlite3_get_table	loadext.c	95;"	d	file:
sqlite3_get_table	sqlite3ext.h	262;"	d
sqlite3_get_table	table.c	/^int sqlite3_get_table($/;"	f
sqlite3_get_table_cb	table.c	/^static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){$/;"	f	file:
sqlite3_global_recover	main.c	/^int sqlite3_global_recover(void){$/;"	f
sqlite3_global_recover	sqlite3ext.h	263;"	d
sqlite3_interrupt	main.c	/^void sqlite3_interrupt(sqlite3 *db){$/;"	f
sqlite3_interrupt	sqlite3ext.h	264;"	d
sqlite3_interrupt_count	vdbe.c	/^int sqlite3_interrupt_count = 0;$/;"	v
sqlite3_io_error_hit	os_common.h	/^int sqlite3_io_error_hit = 0;$/;"	v
sqlite3_io_error_pending	os_common.h	/^int sqlite3_io_error_pending = 0;$/;"	v
sqlite3_io_error_persist	os_common.h	/^int sqlite3_io_error_persist = 0;$/;"	v
sqlite3_io_trace	main.c	/^void (*sqlite3_io_trace)(const char*, ...) = 0;$/;"	v
sqlite3_io_trace	sqliteInt.h	/^SQLITE_EXTERN void (*sqlite3_io_trace)(const char*,...);$/;"	v
sqlite3_isnan	sqliteInt.h	161;"	d
sqlite3_last_insert_rowid	main.c	/^sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){$/;"	f
sqlite3_last_insert_rowid	sqlite3ext.h	265;"	d
sqlite3_libversion	main.c	/^const char *sqlite3_libversion(void){ return sqlite3_version; }$/;"	f
sqlite3_libversion	sqlite3ext.h	266;"	d
sqlite3_libversion_number	main.c	/^int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }$/;"	f
sqlite3_libversion_number	sqlite3ext.h	267;"	d
sqlite3_like_count	func.c	/^int sqlite3_like_count = 0;$/;"	v
sqlite3_load_extension	loadext.c	/^int sqlite3_load_extension($/;"	f
sqlite3_malloc	mem1.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	mem2.c	/^void *sqlite3_malloc(int nByte){$/;"	f
sqlite3_malloc	mem3.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	mem4.c	/^void *sqlite3_malloc(int nBytes){$/;"	f
sqlite3_malloc	sqlite3ext.h	268;"	d
sqlite3_max_blobsize	vdbe.c	/^int sqlite3_max_blobsize = 0;$/;"	v
sqlite3_memdebug_backtrace	mem2.c	/^void sqlite3_memdebug_backtrace(int depth){$/;"	f
sqlite3_memdebug_dump	mem2.c	/^void sqlite3_memdebug_dump(const char *zFilename){$/;"	f
sqlite3_memdebug_dump	mem3.c	/^void sqlite3_memdebug_dump(const char *zFilename){$/;"	f
sqlite3_memdebug_settitle	mem2.c	/^void sqlite3_memdebug_settitle(const char *zTitle){$/;"	f
sqlite3_memory_alarm	mem1.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	mem2.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	mem3.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_alarm	mem4.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_highwater	mem1.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	mem2.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	mem3.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	mem4.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	sqlite3ext.h	329;"	d
sqlite3_memory_used	mem1.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	mem2.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	mem3.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	mem4.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	sqlite3ext.h	330;"	d
sqlite3_mprintf	printf.c	/^char *sqlite3_mprintf(const char *zFormat, ...){$/;"	f
sqlite3_mprintf	sqlite3ext.h	269;"	d
sqlite3_mprintf_double	test1.c	/^static int sqlite3_mprintf_double($/;"	f	file:
sqlite3_mprintf_hexdouble	test1.c	/^static int sqlite3_mprintf_hexdouble($/;"	f	file:
sqlite3_mprintf_int	test1.c	/^static int sqlite3_mprintf_int($/;"	f	file:
sqlite3_mprintf_int64	test1.c	/^static int sqlite3_mprintf_int64($/;"	f	file:
sqlite3_mprintf_scaled	test1.c	/^static int sqlite3_mprintf_scaled($/;"	f	file:
sqlite3_mprintf_str	test1.c	/^static int sqlite3_mprintf_str($/;"	f	file:
sqlite3_mprintf_stronly	test1.c	/^static int sqlite3_mprintf_stronly($/;"	f	file:
sqlite3_mutex	mutex.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	mutex_os2.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	mutex_unix.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	mutex_w32.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex_alloc	mutex.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int id){$/;"	f
sqlite3_mutex_alloc	mutex.h	73;"	d
sqlite3_mutex_alloc	mutex_os2.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	mutex_unix.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	mutex_w32.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int iType){$/;"	f
sqlite3_mutex_alloc	sqlite3ext.h	331;"	d
sqlite3_mutex_enter	mutex.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	mutex.h	75;"	d
sqlite3_mutex_enter	mutex_os2.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	mutex_unix.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	mutex_w32.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	sqlite3ext.h	332;"	d
sqlite3_mutex_free	mutex.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	mutex.h	74;"	d
sqlite3_mutex_free	mutex_os2.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	mutex_unix.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	mutex_w32.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	sqlite3ext.h	333;"	d
sqlite3_mutex_held	mutex.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	mutex.h	78;"	d
sqlite3_mutex_held	mutex_os2.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	mutex_unix.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	mutex_w32.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	mutex.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	mutex.h	77;"	d
sqlite3_mutex_leave	mutex_os2.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	mutex_unix.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	mutex_w32.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	sqlite3ext.h	334;"	d
sqlite3_mutex_notheld	mutex.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	mutex.h	79;"	d
sqlite3_mutex_notheld	mutex_os2.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	mutex_unix.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	mutex_w32.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	mutex.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	mutex.h	76;"	d
sqlite3_mutex_try	mutex_os2.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	mutex_unix.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	mutex_w32.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	sqlite3ext.h	335;"	d
sqlite3_open	main.c	/^int sqlite3_open($/;"	f
sqlite3_open	sqlite3ext.h	270;"	d
sqlite3_open16	loadext.c	54;"	d	file:
sqlite3_open16	main.c	/^int sqlite3_open16($/;"	f
sqlite3_open16	sqlite3ext.h	271;"	d
sqlite3_open_file_count	os_common.h	/^int sqlite3_open_file_count = 0;$/;"	v
sqlite3_open_v2	main.c	/^int sqlite3_open_v2($/;"	f
sqlite3_open_v2	sqlite3ext.h	336;"	d
sqlite3_opentemp_count	pager.c	/^int sqlite3_opentemp_count = 0;$/;"	v
sqlite3_os_trace	os_common.h	/^int sqlite3_os_trace = 0;$/;"	v
sqlite3_os_type	os_win.c	/^int sqlite3_os_type = 0;$/;"	v
sqlite3_os_type	os_win.c	/^static int sqlite3_os_type = 0;$/;"	v	file:
sqlite3_overload_function	main.c	/^int sqlite3_overload_function($/;"	f
sqlite3_overload_function	sqlite3ext.h	317;"	d
sqlite3_pager_n_sort_bucket	pager.c	/^  int sqlite3_pager_n_sort_bucket = 0;$/;"	v
sqlite3_pager_pgfree_count	pager.c	/^int sqlite3_pager_pgfree_count = 0;    \/* Number of cache pages freed *\/$/;"	v
sqlite3_pager_readdb_count	pager.c	/^int sqlite3_pager_readdb_count = 0;    \/* Number of full pages read from DB *\/$/;"	v
sqlite3_pager_writedb_count	pager.c	/^int sqlite3_pager_writedb_count = 0;   \/* Number of full pages written to DB *\/$/;"	v
sqlite3_pager_writej_count	pager.c	/^int sqlite3_pager_writej_count = 0;    \/* Number of pages written to journal *\/$/;"	v
sqlite3_pending_byte	os_common.h	/^unsigned int sqlite3_pending_byte = 0x40000000;$/;"	v
sqlite3_prepare	prepare.c	/^int sqlite3_prepare($/;"	f
sqlite3_prepare	sqlite3ext.h	272;"	d
sqlite3_prepare16	loadext.c	55;"	d	file:
sqlite3_prepare16	prepare.c	/^int sqlite3_prepare16($/;"	f
sqlite3_prepare16	sqlite3ext.h	273;"	d
sqlite3_prepare16_v2	loadext.c	56;"	d	file:
sqlite3_prepare16_v2	prepare.c	/^int sqlite3_prepare16_v2($/;"	f
sqlite3_prepare16_v2	sqlite3ext.h	275;"	d
sqlite3_prepare16_v2	sqlite3ext.h	319;"	d
sqlite3_prepare_v2	prepare.c	/^int sqlite3_prepare_v2($/;"	f
sqlite3_prepare_v2	sqlite3ext.h	274;"	d
sqlite3_prepare_v2	sqlite3ext.h	318;"	d
sqlite3_profile	loadext.c	89;"	d	file:
sqlite3_profile	main.c	/^void *sqlite3_profile($/;"	f
sqlite3_profile	sqlite3ext.h	276;"	d
sqlite3_progress_handler	loadext.c	75;"	d	file:
sqlite3_progress_handler	main.c	/^void sqlite3_progress_handler($/;"	f
sqlite3_progress_handler	sqlite3ext.h	277;"	d
sqlite3_query_plan	where.c	/^char sqlite3_query_plan[BMS*2*40];  \/* Text of the join *\/$/;"	v
sqlite3_realloc	mem1.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	mem2.c	/^void *sqlite3_realloc(void *pPrior, int nByte){$/;"	f
sqlite3_realloc	mem3.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	mem4.c	/^void *sqlite3_realloc(void *pPrior, int nBytes){$/;"	f
sqlite3_realloc	sqlite3ext.h	278;"	d
sqlite3_release_memory	malloc.c	/^int sqlite3_release_memory(int n){$/;"	f
sqlite3_release_memory	sqlite3ext.h	337;"	d
sqlite3_reset	sqlite3ext.h	279;"	d
sqlite3_reset	vdbeapi.c	/^int sqlite3_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_reset_auto_extension	loadext.c	/^void sqlite3_reset_auto_extension(void){$/;"	f
sqlite3_result_blob	sqlite3ext.h	280;"	d
sqlite3_result_blob	vdbeapi.c	/^void sqlite3_result_blob($/;"	f
sqlite3_result_double	sqlite3ext.h	281;"	d
sqlite3_result_double	vdbeapi.c	/^void sqlite3_result_double(sqlite3_context *pCtx, double rVal){$/;"	f
sqlite3_result_error	sqlite3ext.h	282;"	d
sqlite3_result_error	vdbeapi.c	/^void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){$/;"	f
sqlite3_result_error16	loadext.c	57;"	d	file:
sqlite3_result_error16	sqlite3ext.h	283;"	d
sqlite3_result_error16	vdbeapi.c	/^void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){$/;"	f
sqlite3_result_error_nomem	sqlite3ext.h	338;"	d
sqlite3_result_error_nomem	vdbeapi.c	/^void sqlite3_result_error_nomem(sqlite3_context *pCtx){$/;"	f
sqlite3_result_error_toobig	sqlite3ext.h	339;"	d
sqlite3_result_error_toobig	vdbeapi.c	/^void sqlite3_result_error_toobig(sqlite3_context *pCtx){$/;"	f
sqlite3_result_int	sqlite3ext.h	284;"	d
sqlite3_result_int	vdbeapi.c	/^void sqlite3_result_int(sqlite3_context *pCtx, int iVal){$/;"	f
sqlite3_result_int64	sqlite3ext.h	285;"	d
sqlite3_result_int64	vdbeapi.c	/^void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){$/;"	f
sqlite3_result_null	sqlite3ext.h	286;"	d
sqlite3_result_null	vdbeapi.c	/^void sqlite3_result_null(sqlite3_context *pCtx){$/;"	f
sqlite3_result_text	sqlite3ext.h	287;"	d
sqlite3_result_text	vdbeapi.c	/^void sqlite3_result_text($/;"	f
sqlite3_result_text16	loadext.c	58;"	d	file:
sqlite3_result_text16	sqlite3ext.h	288;"	d
sqlite3_result_text16	vdbeapi.c	/^void sqlite3_result_text16($/;"	f
sqlite3_result_text16be	loadext.c	59;"	d	file:
sqlite3_result_text16be	sqlite3ext.h	289;"	d
sqlite3_result_text16be	vdbeapi.c	/^void sqlite3_result_text16be($/;"	f
sqlite3_result_text16le	loadext.c	60;"	d	file:
sqlite3_result_text16le	sqlite3ext.h	290;"	d
sqlite3_result_text16le	vdbeapi.c	/^void sqlite3_result_text16le($/;"	f
sqlite3_result_value	sqlite3ext.h	291;"	d
sqlite3_result_value	vdbeapi.c	/^void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){$/;"	f
sqlite3_result_zeroblob	vdbeapi.c	/^void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){$/;"	f
sqlite3_rollback_hook	main.c	/^void *sqlite3_rollback_hook($/;"	f
sqlite3_rollback_hook	sqlite3ext.h	292;"	d
sqlite3_search_count	vdbe.c	/^int sqlite3_search_count = 0;$/;"	v
sqlite3_server	test_server.c	/^void *sqlite3_server(void *NotUsed){$/;"	f
sqlite3_server_start	test_server.c	/^void sqlite3_server_start(void){$/;"	f
sqlite3_server_stop	test_server.c	/^void sqlite3_server_stop(void){$/;"	f
sqlite3_set_authorizer	auth.c	/^int sqlite3_set_authorizer($/;"	f
sqlite3_set_authorizer	loadext.c	41;"	d	file:
sqlite3_set_authorizer	sqlite3ext.h	293;"	d
sqlite3_set_auxdata	sqlite3ext.h	294;"	d
sqlite3_set_auxdata	vdbeapi.c	/^void sqlite3_set_auxdata($/;"	f
sqlite3_sleep	main.c	/^int sqlite3_sleep(int ms){$/;"	f
sqlite3_sleep	sqlite3ext.h	340;"	d
sqlite3_snprintf	printf.c	/^char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){$/;"	f
sqlite3_snprintf	sqlite3ext.h	295;"	d
sqlite3_snprintf_str	test1.c	/^static int sqlite3_snprintf_str($/;"	f	file:
sqlite3_soft_heap_limit	malloc.c	/^void sqlite3_soft_heap_limit(int n){$/;"	f
sqlite3_soft_heap_limit	sqlite3ext.h	341;"	d
sqlite3_sort_count	vdbe.c	/^int sqlite3_sort_count = 0;$/;"	v
sqlite3_sql	vdbeaux.c	/^const char *sqlite3_sql(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stack_baseline	test1.c	/^static u8 *sqlite3_stack_baseline = 0;$/;"	v	file:
sqlite3_step	sqlite3ext.h	296;"	d
sqlite3_step	vdbeapi.c	/^int sqlite3_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_sync_count	os_os2.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_sync_count	os_unix.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_sync_count	os_win.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_table_column_metadata	loadext.c	37;"	d	file:
sqlite3_table_column_metadata	main.c	/^int sqlite3_table_column_metadata($/;"	f
sqlite3_table_column_metadata	sqlite3ext.h	297;"	d
sqlite3_temp_directory	main.c	/^char *sqlite3_temp_directory = 0;$/;"	v
sqlite3_test_control	main.c	/^int sqlite3_test_control(int op, ...){$/;"	f
sqlite3_thread_cleanup	main.c	/^void sqlite3_thread_cleanup(void){$/;"	f
sqlite3_thread_cleanup	sqlite3ext.h	298;"	d
sqlite3_threadsafe	main.c	/^int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }$/;"	f
sqlite3_total_changes	main.c	/^int sqlite3_total_changes(sqlite3 *db){$/;"	f
sqlite3_total_changes	sqlite3ext.h	299;"	d
sqlite3_trace	loadext.c	90;"	d	file:
sqlite3_trace	main.c	/^void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){$/;"	f
sqlite3_trace	sqlite3ext.h	300;"	d
sqlite3_transfer_bindings	sqlite3ext.h	301;"	d
sqlite3_transfer_bindings	vdbeapi.c	/^int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){$/;"	f
sqlite3_update_hook	main.c	/^void *sqlite3_update_hook($/;"	f
sqlite3_update_hook	sqlite3ext.h	302;"	d
sqlite3_user_data	sqlite3ext.h	303;"	d
sqlite3_user_data	vdbeapi.c	/^void *sqlite3_user_data(sqlite3_context *p){$/;"	f
sqlite3_value_blob	sqlite3ext.h	304;"	d
sqlite3_value_blob	vdbeapi.c	/^const void *sqlite3_value_blob(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes	sqlite3ext.h	305;"	d
sqlite3_value_bytes	vdbeapi.c	/^int sqlite3_value_bytes(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes16	sqlite3ext.h	306;"	d
sqlite3_value_bytes16	vdbeapi.c	/^int sqlite3_value_bytes16(sqlite3_value *pVal){$/;"	f
sqlite3_value_double	sqlite3ext.h	307;"	d
sqlite3_value_double	vdbeapi.c	/^double sqlite3_value_double(sqlite3_value *pVal){$/;"	f
sqlite3_value_int	sqlite3ext.h	308;"	d
sqlite3_value_int	vdbeapi.c	/^int sqlite3_value_int(sqlite3_value *pVal){$/;"	f
sqlite3_value_int64	sqlite3ext.h	309;"	d
sqlite3_value_int64	vdbeapi.c	/^sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){$/;"	f
sqlite3_value_numeric_type	sqlite3ext.h	310;"	d
sqlite3_value_numeric_type	vdbe.c	/^int sqlite3_value_numeric_type(sqlite3_value *pVal){$/;"	f
sqlite3_value_text	sqlite3ext.h	311;"	d
sqlite3_value_text	vdbeapi.c	/^const unsigned char *sqlite3_value_text(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16	loadext.c	61;"	d	file:
sqlite3_value_text16	sqlite3ext.h	312;"	d
sqlite3_value_text16	vdbeapi.c	/^const void *sqlite3_value_text16(sqlite3_value* pVal){$/;"	f
sqlite3_value_text16be	loadext.c	62;"	d	file:
sqlite3_value_text16be	sqlite3ext.h	313;"	d
sqlite3_value_text16be	vdbeapi.c	/^const void *sqlite3_value_text16be(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16le	loadext.c	63;"	d	file:
sqlite3_value_text16le	sqlite3ext.h	314;"	d
sqlite3_value_text16le	vdbeapi.c	/^const void *sqlite3_value_text16le(sqlite3_value *pVal){$/;"	f
sqlite3_value_type	sqlite3ext.h	315;"	d
sqlite3_value_type	vdbeapi.c	/^int sqlite3_value_type(sqlite3_value* pVal){$/;"	f
sqlite3_vdbe_addop_trace	vdbeaux.c	/^int sqlite3_vdbe_addop_trace = 0;$/;"	v
sqlite3_version	main.c	/^const char sqlite3_version[] = SQLITE_VERSION;$/;"	v
sqlite3_vfs_find	os.c	/^sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){$/;"	f
sqlite3_vfs_find	sqlite3ext.h	342;"	d
sqlite3_vfs_register	os.c	/^int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){$/;"	f
sqlite3_vfs_register	sqlite3ext.h	343;"	d
sqlite3_vfs_unregister	os.c	/^int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){$/;"	f
sqlite3_vfs_unregister	sqlite3ext.h	344;"	d
sqlite3_vmprintf	printf.c	/^char *sqlite3_vmprintf(const char *zFormat, va_list ap){$/;"	f
sqlite3_vmprintf	sqlite3ext.h	316;"	d
sqlite3_where_trace	where.c	/^int sqlite3_where_trace = 0;$/;"	v
sqlite3_xferopt_count	insert.c	/^int sqlite3_xferopt_count;$/;"	v
sqlite3async_trace	test_async.c	/^static int sqlite3async_trace = 0;$/;"	v	file:
sqlite3one	utf.c	/^const int sqlite3one = 1;$/;"	v
sqliteAuthBadReturnCode	auth.c	/^static void sqliteAuthBadReturnCode(Parse *pParse, int rc){$/;"	f	file:
sqliteDefaultBusyCallback	main.c	/^static int sqliteDefaultBusyCallback($/;"	f	file:
sqliteDeleteIndex	build.c	/^static void sqliteDeleteIndex(Index *p){$/;"	f	file:
sqliteHashCount	hash.h	108;"	d
sqliteHashData	hash.h	101;"	d
sqliteHashFirst	hash.h	99;"	d
sqliteHashKey	hash.h	102;"	d
sqliteHashKeysize	hash.h	103;"	d
sqliteHashNext	hash.h	100;"	d
sqlitePersistTriggerStep	trigger.c	/^static void sqlitePersistTriggerStep(sqlite3 *db, TriggerStep *p){$/;"	f	file:
sqliteProcessJoin	select.c	/^static int sqliteProcessJoin(Parse *pParse, Select *p){$/;"	f	file:
sqliteResetColumnNames	build.c	/^static void sqliteResetColumnNames(Table *pTable){$/;"	f	file:
sqliteViewResetAll	build.c	/^static void sqliteViewResetAll(sqlite3 *db, int idx){$/;"	f	file:
sqliteViewResetAll	build.c	1806;"	d	file:
sqlite_abort	test1.c	/^static int sqlite_abort($/;"	f	file:
sqlite_set_magic	test1.c	/^static int sqlite_set_magic($/;"	f	file:
sqlite_static_bind_nbyte	test1.c	/^static int sqlite_static_bind_nbyte = 0;$/;"	v	file:
sqlite_static_bind_value	test1.c	/^static char *sqlite_static_bind_value = 0;$/;"	v	file:
sqlite_test_close	test1.c	/^static int sqlite_test_close($/;"	f	file:
sqlthread_id	test_thread.c	/^static int sqlthread_id($/;"	f	file:
sqlthread_open	test_thread.c	/^static int sqlthread_open($/;"	f	file:
sqlthread_parent	test_thread.c	/^static int sqlthread_parent($/;"	f	file:
sqlthread_proc	test_thread.c	/^static Tcl_ObjCmdProc sqlthread_proc;$/;"	v	file:
sqlthread_proc	test_thread.c	/^static int sqlthread_proc($/;"	f	file:
sqlthread_spawn	test_thread.c	/^static int sqlthread_spawn($/;"	f	file:
sqrFunc	test_autoext.c	/^static void sqrFunc($/;"	f	file:
sqr_init	test_autoext.c	/^static int sqr_init($/;"	f	file:
startEndFlag	os_unix.c	/^  unsigned char startEndFlag;       \/* 1=rel to end of fork, 0=rel to start *\/$/;"	m	struct:ByteRangeLockPB2	file:
startTime	vdbeInt.h	/^  i64 startTime;          \/* Time when query started - used for profiling *\/$/;"	m	struct:Vdbe
state	pager.c	/^  u8 state;                   \/* PAGER_UNLOCK, _SHARED, _RESERVED, etc. *\/$/;"	m	struct:Pager	file:
stdin_is_interactive	shell.c	/^static int stdin_is_interactive = 1;$/;"	v	file:
step	sqlite3ext.h	/^  int  (*step)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
step_list	sqliteInt.h	/^  TriggerStep *step_list; \/* Link list of trigger program steps             *\/$/;"	m	struct:Trigger
stfd	pager.c	/^  sqlite3_file *stfd;         \/* File descriptor for the statement subjournal*\/$/;"	m	struct:Pager	file:
stifle_history	shell.c	44;"	d	file:
stmtAutoopen	pager.c	/^  u8 stmtAutoopen;            \/* Open stmt journal when main journal is opened*\/$/;"	m	struct:Pager	file:
stmtCksum	pager.c	/^  i64 stmtCksum;              \/* cksumInit when statement was started *\/$/;"	m	struct:Pager	file:
stmtHdrOff	pager.c	/^  i64 stmtHdrOff;             \/* First journal header written this statement *\/$/;"	m	struct:Pager	file:
stmtInUse	pager.c	/^  u8 stmtInUse;               \/* True we are in a statement subtransaction *\/$/;"	m	struct:Pager	file:
stmtJSize	pager.c	/^  i64 stmtJSize;              \/* Size of journal at stmt_begin() *\/$/;"	m	struct:Pager	file:
stmtLast	tclsqlite.c	/^  SqlPreparedStmt *stmtLast; \/* Last statement in the list *\/$/;"	m	struct:SqliteDb	file:
stmtList	tclsqlite.c	/^  SqlPreparedStmt *stmtList; \/* List of prepared statements*\/$/;"	m	struct:SqliteDb	file:
stmtNRec	pager.c	/^  int stmtNRec;               \/* Number of records in stmt subjournal *\/$/;"	m	struct:Pager	file:
stmtOpen	pager.c	/^  u8 stmtOpen;                \/* True if the statement subjournal is open *\/$/;"	m	struct:Pager	file:
stmtSize	pager.c	/^  int stmtSize;               \/* Size of database (in pages) at stmt_begin() *\/$/;"	m	struct:Pager	file:
stop_thread	test4.c	/^static void stop_thread(Thread *p){$/;"	f	file:
stop_thread	test7.c	/^static void stop_thread(Thread *p){$/;"	f	file:
storeTypeInfo	vdbe.c	171;"	d	file:
strCompare	hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strHash	hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strftimeFunc	date.c	/^static void strftimeFunc($/;"	f	file:
string_concat	test8.c	/^static void string_concat(char **pzStr, char *zAppend, int doFree, int *pRc){$/;"	f	file:
substExpr	select.c	/^static void substExpr($/;"	f	file:
substExprList	select.c	/^static void substExprList($/;"	f	file:
substSelect	select.c	/^static void substSelect($/;"	f	file:
substrFunc	func.c	/^static void substrFunc($/;"	f	file:
sumFinalize	func.c	/^static void sumFinalize(sqlite3_context *context){$/;"	f	file:
sumStep	func.c	/^static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
swapMixedEndianFloat	vdbeaux.c	1925;"	d	file:
swapMixedEndianFloat	vdbeaux.c	1927;"	d	file:
syncJournal	pager.c	/^static int syncJournal(Pager *pPager){$/;"	f	file:
sync_flags	pager.c	/^  u8 sync_flags;              \/* One of SYNC_NORMAL or SYNC_FULL *\/$/;"	m	struct:Pager	file:
synthCollSeq	callback.c	/^static int synthCollSeq(sqlite3 *db, CollSeq *pColl){$/;"	f	file:
szMaster	mem3.c	/^  u32 szMaster;$/;"	m	struct:__anon11	file:
szPage	mem4.c	/^  int szPage;$/;"	m	struct:__anon7	file:
t1CountCtx	test1.c	/^struct t1CountCtx {$/;"	s	file:
t1CountCtx	test1.c	/^typedef struct t1CountCtx t1CountCtx;$/;"	t	typeref:struct:t1CountCtx	file:
t1CountFinalize	test1.c	/^static void t1CountFinalize(sqlite3_context *context){$/;"	f	file:
t1CountStep	test1.c	/^static void t1CountStep($/;"	f	file:
t1ErrorName	test1.c	152;"	d	file:
t1_ifnullFunc	test1.c	/^static void t1_ifnullFunc($/;"	f	file:
t4Get4byte	test3.c	/^static u32 t4Get4byte(unsigned char *p){$/;"	f	file:
table	sqliteInt.h	/^  char *table;            \/* The table or view to which the trigger applies *\/$/;"	m	struct:Trigger
tableOfTrigger	trigger.c	/^static Table *tableOfTrigger(Trigger *pTrigger){$/;"	f	file:
table_column_metadata	sqlite3ext.h	/^  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*);$/;"	m	struct:sqlite3_api_routines
target	sqliteInt.h	/^  Token target;        \/* Valid for DELETE, UPDATE, INSERT steps *\/$/;"	m	struct:TriggerStep
targetSrcList	trigger.c	/^static SrcList *targetSrcList($/;"	f	file:
tblHash	sqliteInt.h	/^  Hash tblHash;        \/* All tables indexed by name *\/$/;"	m	struct:Schema
tclCollateNeeded	tclsqlite.c	/^static void tclCollateNeeded($/;"	f	file:
tclScriptEvent	test_thread.c	/^static int tclScriptEvent(Tcl_Event *evPtr, int flags){$/;"	f	file:
tclScriptThread	test_thread.c	/^static Tcl_ThreadCreateType tclScriptThread(ClientData pSqlThread){$/;"	f	file:
tclSqlCollate	tclsqlite.c	/^static int tclSqlCollate($/;"	f	file:
tclSqlFunc	tclsqlite.c	/^static void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){$/;"	f	file:
tcl_client_argc	test7.c	/^static int tcl_client_argc($/;"	f	file:
tcl_client_argv	test7.c	/^static int tcl_client_argv($/;"	f	file:
tcl_client_colname	test7.c	/^static int tcl_client_colname($/;"	f	file:
tcl_client_compile	test7.c	/^static int tcl_client_compile($/;"	f	file:
tcl_client_create	test7.c	/^static int tcl_client_create($/;"	f	file:
tcl_client_error	test7.c	/^static int tcl_client_error($/;"	f	file:
tcl_client_finalize	test7.c	/^static int tcl_client_finalize($/;"	f	file:
tcl_client_halt	test7.c	/^static int tcl_client_halt($/;"	f	file:
tcl_client_reset	test7.c	/^static int tcl_client_reset($/;"	f	file:
tcl_client_result	test7.c	/^static int tcl_client_result($/;"	f	file:
tcl_client_step	test7.c	/^static int tcl_client_step($/;"	f	file:
tcl_client_swap	test7.c	/^static int tcl_client_swap($/;"	f	file:
tcl_client_wait	test7.c	/^static int tcl_client_wait($/;"	f	file:
tcl_thread_argc	test4.c	/^static int tcl_thread_argc($/;"	f	file:
tcl_thread_argv	test4.c	/^static int tcl_thread_argv($/;"	f	file:
tcl_thread_colname	test4.c	/^static int tcl_thread_colname($/;"	f	file:
tcl_thread_compile	test4.c	/^static int tcl_thread_compile($/;"	f	file:
tcl_thread_create	test4.c	/^static int tcl_thread_create($/;"	f	file:
tcl_thread_db_get	test4.c	/^static int tcl_thread_db_get($/;"	f	file:
tcl_thread_error	test4.c	/^static int tcl_thread_error($/;"	f	file:
tcl_thread_finalize	test4.c	/^static int tcl_thread_finalize($/;"	f	file:
tcl_thread_halt	test4.c	/^static int tcl_thread_halt($/;"	f	file:
tcl_thread_result	test4.c	/^static int tcl_thread_result($/;"	f	file:
tcl_thread_step	test4.c	/^static int tcl_thread_step($/;"	f	file:
tcl_thread_stmt_get	test4.c	/^static int tcl_thread_stmt_get($/;"	f	file:
tcl_thread_swap	test4.c	/^static int tcl_thread_swap($/;"	f	file:
tcl_thread_wait	test4.c	/^static int tcl_thread_wait($/;"	f	file:
tcl_variable_type	test1.c	/^static int tcl_variable_type($/;"	f	file:
tclvarBestIndex	test_tclvar.c	/^static int tclvarBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
tclvarClose	test_tclvar.c	/^static int tclvarClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarColumn	test_tclvar.c	/^static int tclvarColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
tclvarConnect	test_tclvar.c	/^static int tclvarConnect($/;"	f	file:
tclvarDisconnect	test_tclvar.c	/^static int tclvarDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
tclvarEof	test_tclvar.c	/^static int tclvarEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarFilter	test_tclvar.c	/^static int tclvarFilter($/;"	f	file:
tclvarModule	test_tclvar.c	/^static sqlite3_module tclvarModule = {$/;"	v	file:
tclvarNext	test_tclvar.c	/^static int tclvarNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarOpen	test_tclvar.c	/^static int tclvarOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
tclvarRowid	test_tclvar.c	/^static int tclvarRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
tclvar_cursor	test_tclvar.c	/^struct tclvar_cursor {$/;"	s	file:
tclvar_cursor	test_tclvar.c	/^typedef struct tclvar_cursor tclvar_cursor;$/;"	t	typeref:struct:tclvar_cursor	file:
tclvar_vtab	test_tclvar.c	/^struct tclvar_vtab {$/;"	s	file:
tclvar_vtab	test_tclvar.c	/^typedef struct tclvar_vtab tclvar_vtab;$/;"	t	typeref:struct:tclvar_vtab	file:
tcons	parse.y	/^tcons ::= CHECK LP expr(E) RP onconf. {sqlite3AddCheckConstraint(pParse,E);}$/;"	l
tcons	parse.y	/^tcons ::= CONSTRAINT nm.$/;"	l
tcons	parse.y	/^tcons ::= FOREIGN KEY LP idxlist(FA) RP$/;"	l
tcons	parse.y	/^tcons ::= PRIMARY KEY LP idxlist(X) autoinc(I) RP onconf(R).$/;"	l
tcons	parse.y	/^tcons ::= UNIQUE LP idxlist(X) RP onconf(R).$/;"	l
tempFile	pager.c	/^  u8 tempFile;                \/* zFilename is a temporary file *\/$/;"	m	struct:Pager	file:
temp_store	sqliteInt.h	/^  u8 temp_store;                \/* 1: file 2: memory 0: default *\/$/;"	m	struct:sqlite3
testAsyncDelay	test_async.c	/^static int testAsyncDelay($/;"	f	file:
testAsyncEnable	test_async.c	/^static int testAsyncEnable($/;"	f	file:
testAsyncHalt	test_async.c	/^static int testAsyncHalt($/;"	f	file:
testAsyncStart	test_async.c	/^static int testAsyncStart($/;"	f	file:
testAsyncWait	test_async.c	/^static int testAsyncWait($/;"	f	file:
testCreateCollationCmp	test1.c	/^static int testCreateCollationCmp($/;"	f	file:
testCreateCollationDel	test1.c	/^static void testCreateCollationDel(void *pCtx){$/;"	f	file:
testFunc	test1.c	/^static void testFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
testHexToInt	test1.c	/^static int testHexToInt(int h){$/;"	f	file:
testThreadLockingBehavior	os_unix.c	/^static void testThreadLockingBehavior(int fd_orig){$/;"	f	file:
test_auxdata	func.c	/^static void test_auxdata($/;"	f	file:
test_bind	test1.c	/^static int test_bind($/;"	f	file:
test_bind_blob	test1.c	/^static int test_bind_blob($/;"	f	file:
test_bind_double	test1.c	/^static int test_bind_double($/;"	f	file:
test_bind_int	test1.c	/^static int test_bind_int($/;"	f	file:
test_bind_int64	test1.c	/^static int test_bind_int64($/;"	f	file:
test_bind_null	test1.c	/^static int test_bind_null($/;"	f	file:
test_bind_parameter_count	test1.c	/^static int test_bind_parameter_count($/;"	f	file:
test_bind_parameter_index	test1.c	/^static int test_bind_parameter_index($/;"	f	file:
test_bind_parameter_name	test1.c	/^static int test_bind_parameter_name($/;"	f	file:
test_bind_text	test1.c	/^static int test_bind_text($/;"	f	file:
test_bind_text16	test1.c	/^static int test_bind_text16($/;"	f	file:
test_bind_zeroblob	test1.c	/^static int test_bind_zeroblob($/;"	f	file:
test_blob_read	test1.c	/^static int test_blob_read($/;"	f	file:
test_blob_write	test1.c	/^static int test_blob_write($/;"	f	file:
test_breakpoint	test1.c	/^static int test_breakpoint($/;"	f	file:
test_busy_timeout	test1.c	/^static int test_busy_timeout($/;"	f	file:
test_changes	test1.c	/^static int test_changes($/;"	f	file:
test_clear_bindings	test1.c	/^static int test_clear_bindings($/;"	f	file:
test_collate	test1.c	/^static int test_collate($/;"	f	file:
test_collate_func	test1.c	/^static int test_collate_func($/;"	f	file:
test_collate_needed	test1.c	/^static int test_collate_needed($/;"	f	file:
test_collate_needed_cb	test1.c	/^static void test_collate_needed_cb($/;"	f	file:
test_column_blob	test1.c	/^static int test_column_blob($/;"	f	file:
test_column_count	test1.c	/^static int test_column_count($/;"	f	file:
test_column_double	test1.c	/^static int test_column_double($/;"	f	file:
test_column_int64	test1.c	/^static int test_column_int64($/;"	f	file:
test_column_type	test1.c	/^static int test_column_type($/;"	f	file:
test_complete16	test1.c	/^static int test_complete16($/;"	f	file:
test_create_aggregate	test1.c	/^static int test_create_aggregate($/;"	f	file:
test_create_collation_v2	test1.c	/^static int test_create_collation_v2($/;"	f	file:
test_create_function	test1.c	/^static int test_create_function($/;"	f	file:
test_data_count	test1.c	/^static int test_data_count($/;"	f	file:
test_destructor	func.c	/^static void test_destructor($/;"	f	file:
test_destructor_count	func.c	/^static void test_destructor_count($/;"	f	file:
test_destructor_count_var	func.c	/^static int test_destructor_count_var = 0;$/;"	v	file:
test_enable_load	test1.c	/^static int test_enable_load($/;"	f	file:
test_enable_shared	test1.c	/^static int test_enable_shared($/;"	f	file:
test_errcode	test1.c	/^static int test_errcode($/;"	f	file:
test_errmsg	test1.c	/^static int test_errmsg($/;"	f	file:
test_errmsg16	test1.c	/^static int test_errmsg16($/;"	f	file:
test_error	func.c	/^static void test_error($/;"	f	file:
test_errstr	test1.c	/^static int test_errstr($/;"	f	file:
test_exec	test1.c	/^static int test_exec($/;"	f	file:
test_exec_nr	test1.c	/^static int test_exec_nr($/;"	f	file:
test_exec_printf	test1.c	/^static int test_exec_printf($/;"	f	file:
test_expired	test1.c	/^static int test_expired($/;"	f	file:
test_extended_result_codes	test1.c	/^static int test_extended_result_codes($/;"	f	file:
test_finalize	test1.c	/^static int test_finalize($/;"	f	file:
test_free	test_malloc.c	/^static int test_free($/;"	f	file:
test_function	test1.c	/^static int test_function($/;"	f	file:
test_function_utf16be	test1.c	/^static void test_function_utf16be($/;"	f	file:
test_function_utf16le	test1.c	/^static void test_function_utf16le($/;"	f	file:
test_function_utf8	test1.c	/^static void test_function_utf8($/;"	f	file:
test_get_table_printf	test1.c	/^static int test_get_table_printf($/;"	f	file:
test_global_recover	test1.c	/^static int test_global_recover($/;"	f	file:
test_interrupt	test1.c	/^static int test_interrupt($/;"	f	file:
test_io_trace	test1.c	/^static int test_io_trace($/;"	f	file:
test_key	test1.c	/^static int test_key($/;"	f	file:
test_last_rowid	test1.c	/^static int test_last_rowid($/;"	f	file:
test_libversion_number	test1.c	/^static int test_libversion_number($/;"	f	file:
test_load_extension	test1.c	/^static int test_load_extension($/;"	f	file:
test_malloc	test_malloc.c	/^static int test_malloc($/;"	f	file:
test_memdebug_backtrace	test_malloc.c	/^static int test_memdebug_backtrace($/;"	f	file:
test_memdebug_dump	test_malloc.c	/^static int test_memdebug_dump($/;"	f	file:
test_memdebug_fail	test_malloc.c	/^static int test_memdebug_fail($/;"	f	file:
test_memdebug_pending	test_malloc.c	/^static int test_memdebug_pending($/;"	f	file:
test_memdebug_settitle	test_malloc.c	/^static int test_memdebug_settitle($/;"	f	file:
test_memget	test_malloc.c	/^static int test_memget($/;"	f	file:
test_memory_highwater	test_malloc.c	/^static int test_memory_highwater($/;"	f	file:
test_memory_used	test_malloc.c	/^static int test_memory_used($/;"	f	file:
test_memset	test_malloc.c	/^static int test_memset($/;"	f	file:
test_mprintf_n	test1.c	/^static int test_mprintf_n($/;"	f	file:
test_mprintf_z	test1.c	/^static int test_mprintf_z($/;"	f	file:
test_open	test1.c	/^static int test_open($/;"	f	file:
test_open16	test1.c	/^static int test_open16($/;"	f	file:
test_pager_refcounts	test1.c	/^static int test_pager_refcounts($/;"	f	file:
test_pagesize	test2.c	/^static int test_pagesize = 1024;$/;"	v	file:
test_prepare	test1.c	/^static int test_prepare($/;"	f	file:
test_prepare16	test1.c	/^static int test_prepare16($/;"	f	file:
test_prepare16_v2	test1.c	/^static int test_prepare16_v2($/;"	f	file:
test_prepare_v2	test1.c	/^static int test_prepare_v2($/;"	f	file:
test_printf	test1.c	/^static int test_printf($/;"	f	file:
test_realloc	test_malloc.c	/^static int test_realloc($/;"	f	file:
test_register_func	test1.c	/^static int test_register_func($/;"	f	file:
test_rekey	test1.c	/^static int test_rekey($/;"	f	file:
test_release_memory	test1.c	/^static int test_release_memory($/;"	f	file:
test_reset	test1.c	/^static int test_reset($/;"	f	file:
test_sleep	test1.c	/^static int test_sleep($/;"	f	file:
test_snprintf_int	test1.c	/^static int test_snprintf_int($/;"	f	file:
test_soft_heap_limit	test1.c	/^static int test_soft_heap_limit($/;"	f	file:
test_stack_used	test1.c	/^static int test_stack_used($/;"	f	file:
test_step	test1.c	/^static int test_step($/;"	f	file:
test_stmt_int	test1.c	/^static int test_stmt_int($/;"	f	file:
test_stmt_utf16	test1.c	/^static int test_stmt_utf16($/;"	f	file:
test_stmt_utf8	test1.c	/^static int test_stmt_utf8($/;"	f	file:
test_table_column_metadata	test1.c	/^static int test_table_column_metadata($/;"	f	file:
test_thread_cleanup	test1.c	/^static int test_thread_cleanup($/;"	f	file:
test_transfer_bind	test1.c	/^static int test_transfer_bind($/;"	f	file:
test_translate	test5.c	/^static int test_translate($/;"	f	file:
test_translate_selftest	test5.c	/^static int test_translate_selftest($/;"	f	file:
test_value_overhead	test5.c	/^static int test_value_overhead($/;"	f	file:
testbrokenext_init	test_loadext.c	/^int testbrokenext_init($/;"	f
testloadext_init	test_loadext.c	/^int testloadext_init($/;"	f
textToPointer	test_malloc.c	/^static int textToPointer(const char *z, void **pp){$/;"	f	file:
threadLockingTest	os_unix.c	/^static void *threadLockingTest(void *pArg){$/;"	f	file:
threadTestData	os_unix.c	/^struct threadTestData {$/;"	s	file:
thread_cleanup	sqlite3ext.h	/^  void  (*thread_cleanup)(void);$/;"	m	struct:sqlite3_api_routines
thread_main	test4.c	/^static void *thread_main(void *pArg){$/;"	f	file:
thread_wait	test4.c	/^static void thread_wait(Thread *p){$/;"	f	file:
threadid	os_unix.c	142;"	d	file:
threadid	os_unix.c	144;"	d	file:
threadsOverrideEachOthersLocks	os_unix.c	/^int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;$/;"	v
threadsOverrideEachOthersLocks	os_unix.c	/^static int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;$/;"	v	file:
threadset	test4.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
threadset	test7.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
tid	os_unix.c	/^  pthread_t tid;            \/* The thread that "owns" this unixFile *\/$/;"	m	struct:unixFile	file:
tid	os_unix.c	/^  pthread_t tid;   \/* Thread ID or zero if threads can override each other *\/$/;"	m	struct:lockKey	file:
timeDiff	shell.c	/^static int timeDiff(struct timeval *pStart, struct timeval *pEnd){$/;"	f	file:
timeFunc	date.c	/^static void timeFunc($/;"	f	file:
tkCREATE	complete.c	47;"	d	file:
tkEND	complete.c	50;"	d	file:
tkEXPLAIN	complete.c	46;"	d	file:
tkOTHER	complete.c	45;"	d	file:
tkSEMI	complete.c	43;"	d	file:
tkTEMP	complete.c	48;"	d	file:
tkTRIGGER	complete.c	49;"	d	file:
tkWS	complete.c	44;"	d	file:
tkt2213Function	test1.c	/^static void tkt2213Function($/;"	f	file:
tmpCheckReservedLock	test_onefile.c	/^static int tmpCheckReservedLock(sqlite3_file *pFile){$/;"	f	file:
tmpClose	test_onefile.c	/^static int tmpClose(sqlite3_file *pFile){$/;"	f	file:
tmpDeviceCharacteristics	test_onefile.c	/^static int tmpDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
tmpFileControl	test_onefile.c	/^static int tmpFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
tmpFileSize	test_onefile.c	/^static int tmpFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
tmpLock	test_onefile.c	/^static int tmpLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpRead	test_onefile.c	/^static int tmpRead($/;"	f	file:
tmpSectorSize	test_onefile.c	/^static int tmpSectorSize(sqlite3_file *pFile){$/;"	f	file:
tmpSync	test_onefile.c	/^static int tmpSync(sqlite3_file *pFile, int flags){$/;"	f	file:
tmpTruncate	test_onefile.c	/^static int tmpTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
tmpUnlock	test_onefile.c	/^static int tmpUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpWrite	test_onefile.c	/^static int tmpWrite($/;"	f	file:
tmp_file	test_onefile.c	/^struct tmp_file {$/;"	s	file:
tmp_file	test_onefile.c	/^typedef struct tmp_file tmp_file;$/;"	t	typeref:struct:tmp_file	file:
tmp_io_methods	test_onefile.c	/^static sqlite3_io_methods tmp_io_methods = {$/;"	v	file:
tnum	sqliteInt.h	/^  int tnum;        \/* Page containing root of this index in database file *\/$/;"	m	struct:Index
tnum	sqliteInt.h	/^  int tnum;        \/* Root BTree node for this table (see note above) *\/$/;"	m	struct:Table
token	sqliteInt.h	/^  Token token;           \/* An operand token *\/$/;"	m	struct:Expr
tooBig	sqliteInt.h	/^  u8   tooBig;         \/* Becomes true if string size exceeds limits *\/$/;"	m	struct:StrAccum
top	sqliteInt.h	/^  int top;              \/* First instruction of interior of the loop *\/$/;"	m	struct:WhereLevel
topAddr	sqliteInt.h	/^    int topAddr;           \/* Top of the IN loop *\/$/;"	m	struct:WhereLevel::InLoop
totalFinalize	func.c	/^static void totalFinalize(sqlite3_context *context){$/;"	f	file:
total_changes	func.c	/^static void total_changes($/;"	f	file:
total_changes	sqlite3ext.h	/^  int  (*total_changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
tr_tm	sqliteInt.h	/^  u8 tr_tm;               \/* One of TRIGGER_BEFORE, TRIGGER_AFTER *\/$/;"	m	struct:Trigger
trace	mutex_unix.c	/^  int trace;                 \/* True to trace changes *\/$/;"	m	struct:sqlite3_mutex	file:
trace	sqlite3ext.h	/^  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);$/;"	m	struct:sqlite3_api_routines
trace	vdbeInt.h	/^  FILE *trace;        \/* Write an execution trace here, if not NULL *\/$/;"	m	struct:Vdbe
trans_opt	parse.y	/^trans_opt ::= .$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION nm.$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION.$/;"	l
transferJoinMarkings	where.c	/^static void transferJoinMarkings(Expr *pDerived, Expr *pBase){$/;"	f	file:
transferOwnership	os_unix.c	/^static int transferOwnership(unixFile *pFile){$/;"	f	file:
transferOwnership	os_unix.c	769;"	d	file:
transfer_bindings	sqlite3ext.h	/^  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
trigHash	sqliteInt.h	/^  Hash trigHash;       \/* All triggers indexed by name *\/$/;"	m	struct:Schema
trigStack	sqliteInt.h	/^  TriggerStack *trigStack;  \/* Trigger actions being coded *\/$/;"	m	struct:Parse
trimFunc	func.c	/^static void trimFunc($/;"	f	file:
type	parse.y	/^type ::= .$/;"	l
type	parse.y	/^type ::= typetoken(X).                   {sqlite3AddColumnType(pParse,&X);}$/;"	l
type	printf.c	/^  etByte type;             \/* Conversion paradigm *\/$/;"	m	struct:et_info	file:
type	sqliteInt.h	/^  u8 type;              \/* One of the SQLITE_COLL_... values below *\/$/;"	m	struct:CollSeq
type	vdbeInt.h	/^  u8  type;           \/* One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc *\/$/;"	m	struct:Mem
typeofFunc	func.c	/^static void typeofFunc($/;"	f	file:
tz	date.c	/^  int tz;          \/* Timezone offset in minutes *\/$/;"	m	struct:DateTime	file:
u	mem3.c	/^  } u;$/;"	m	struct:Mem3Block	typeref:union:Mem3Block::__anon8	file:
u	vdbeInt.h	/^  } u;$/;"	m	struct:Mem	typeref:union:Mem::__anon6
u1	sqliteInt.h	/^  } u1;$/;"	m	struct:sqlite3	typeref:union:sqlite3::__anon2
u16	sqliteInt.h	/^typedef UINT16_TYPE u16;           \/* 2-byte unsigned integer *\/$/;"	t
u32	sqliteInt.h	/^typedef UINT32_TYPE u32;           \/* 4-byte unsigned integer *\/$/;"	t
u64	sqliteInt.h	/^typedef sqlite_uint64 u64;         \/* 8-byte unsigned integer *\/$/;"	t
u8	sqliteInt.h	/^typedef UINT8_TYPE u8;             \/* 1-byte unsigned integer *\/$/;"	t
uint32	test_md5.c	44;"	d	file:
unLockFlag	os_unix.c	/^  unsigned char unLockFlag;         \/* 1 = unlock, 0 = lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
unaligned_string_counter	test1.c	/^static int unaligned_string_counter = 0;$/;"	v	file:
unicodeToMbcs	os_win.c	/^static char *unicodeToMbcs(const WCHAR *zWideFilename){$/;"	f	file:
unicodeToUtf8	os_win.c	/^static char *unicodeToUtf8(const WCHAR *zWideFilename){$/;"	f	file:
uniqueCnt	vdbeInt.h	/^  unsigned uniqueCnt;     \/* Used by OP_MakeRecord when P2!=0 *\/$/;"	m	struct:Vdbe
unixAccess	os_unix.c	/^static int unixAccess(sqlite3_vfs *pVfs, const char *zPath, int flags){$/;"	f	file:
unixCheckReservedLock	os_unix.c	/^static int unixCheckReservedLock(sqlite3_file *id){$/;"	f	file:
unixClose	os_unix.c	/^static int unixClose(sqlite3_file *id){$/;"	f	file:
unixCurrentTime	os_unix.c	/^static int unixCurrentTime(sqlite3_vfs *pVfs, double *prNow){$/;"	f	file:
unixDelete	os_unix.c	/^static int unixDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
unixDeviceCharacteristics	os_unix.c	/^static int unixDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
unixDlClose	os_unix.c	/^static void unixDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
unixDlClose	os_unix.c	2633;"	d	file:
unixDlError	os_unix.c	/^static void unixDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
unixDlError	os_unix.c	2631;"	d	file:
unixDlOpen	os_unix.c	/^static void *unixDlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
unixDlOpen	os_unix.c	2630;"	d	file:
unixDlSym	os_unix.c	/^static void *unixDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f	file:
unixDlSym	os_unix.c	2632;"	d	file:
unixFile	os_unix.c	/^struct unixFile {$/;"	s	file:
unixFile	os_unix.c	/^typedef struct unixFile unixFile;$/;"	t	typeref:struct:unixFile	file:
unixFileControl	os_unix.c	/^static int unixFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
unixFileSize	os_unix.c	/^static int unixFileSize(sqlite3_file *id, i64 *pSize){$/;"	f	file:
unixFullPathname	os_unix.c	/^static int unixFullPathname($/;"	f	file:
unixGetTempname	os_unix.c	/^static int unixGetTempname(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
unixLock	os_unix.c	/^static int unixLock(sqlite3_file *id, int locktype){$/;"	f	file:
unixOpen	os_unix.c	/^static int unixOpen($/;"	f	file:
unixRandomness	os_unix.c	/^static int unixRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
unixRead	os_unix.c	/^static int unixRead($/;"	f	file:
unixSectorSize	os_unix.c	/^static int unixSectorSize(sqlite3_file *id){$/;"	f	file:
unixSleep	os_unix.c	/^static int unixSleep(sqlite3_vfs *pVfs, int microseconds){$/;"	f	file:
unixSync	os_unix.c	/^static int unixSync(sqlite3_file *id, int flags){$/;"	f	file:
unixTruncate	os_unix.c	/^static int unixTruncate(sqlite3_file *id, i64 nByte){$/;"	f	file:
unixUnlock	os_unix.c	/^static int unixUnlock(sqlite3_file *id, int locktype){$/;"	f	file:
unixWrite	os_unix.c	/^static int unixWrite($/;"	f	file:
unlikely	sqliteInt.h	27;"	d
unlikely	sqliteInt.h	30;"	d
unlinkAsyncFile	test_async.c	/^static int unlinkAsyncFile(AsyncFileData *pData){$/;"	f	file:
unlinkHashChain	pager.c	/^static void unlinkHashChain(Pager *pPager, PgHdr *pPg){$/;"	f	file:
unlinkPage	pager.c	/^static void unlinkPage(PgHdr *pPg){$/;"	f	file:
unlockAllTables	btree.c	/^static void unlockAllTables(Btree *p){$/;"	f	file:
unlockAllTables	btree.c	85;"	d	file:
unlockBtreeIfUnused	btree.c	/^static void unlockBtreeIfUnused(BtShared *pBt){$/;"	f	file:
unlockReadLock	os_os2.c	/^static int unlockReadLock( os2File *id ){$/;"	f	file:
unlockReadLock	os_win.c	/^static int unlockReadLock(winFile *pFile){$/;"	f	file:
unsupportedLockingStyle	os_unix.c	/^        unsupportedLockingStyle      \/* indicates unsupported file system *\/$/;"	e	enum:__anon4	file:
updateAccumulator	select.c	/^static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
updateConf	sqliteInt.h	/^  u8 updateConf;    \/* How to resolve conflicts that occur on UPDATE *\/$/;"	m	struct:FKey
updateMaxBlobsize	vdbe.c	/^static void updateMaxBlobsize(Mem *p){$/;"	f	file:
updateVirtualTable	update.c	/^static void updateVirtualTable($/;"	f	file:
update_hook	sqlite3ext.h	/^  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,sqlite_int64),void*);$/;"	m	struct:sqlite3_api_routines
upperFunc	func.c	/^static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
usableSize	btreeInt.h	/^  u16 usableSize;       \/* Number of usable bytes on each page *\/$/;"	m	struct:BtShared
usage	shell.c	/^static void usage(int showDetail){$/;"	f	file:
useEvalObjv	tclsqlite.c	/^  int useEvalObjv;      \/* True if it is safe to use Tcl_EvalObjv *\/$/;"	m	struct:SqlFunc	file:
useJournal	pager.c	/^  u8 useJournal;              \/* Use a rollback journal on this file *\/$/;"	m	struct:Pager	file:
useMalloc	sqliteInt.h	/^  u8   useMalloc;      \/* True if zText is enlargable using realloc *\/$/;"	m	struct:StrAccum
useRandomRowid	vdbeInt.h	/^  Bool useRandomRowid;  \/* Generate new record numbers semi-randomly *\/$/;"	m	struct:Cursor
useSortingIdx	sqliteInt.h	/^  u8 useSortingIdx;       \/* In direct mode, reference the sorting index rather$/;"	m	struct:AggInfo
user_data	sqlite3ext.h	/^  void * (*user_data)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
usesEphm	sqliteInt.h	/^  u8 usesEphm;           \/* True if uses an OpenEphemeral opcode *\/$/;"	m	struct:Select
utf8ToMbcs	os_win.c	/^static char *utf8ToMbcs(const char *zFilename){$/;"	f	file:
utf8ToUnicode	os_win.c	/^static WCHAR *utf8ToUnicode(const char *zFilename){$/;"	f	file:
utf8_to_utf8	test_hexio.c	/^static int utf8_to_utf8($/;"	f	file:
valid	shell.c	/^  int valid;        \/* Is there legit data in here? *\/$/;"	m	struct:previous_mode_data	file:
validHMS	date.c	/^  char validHMS;   \/* True if h,m,s are valid *\/$/;"	m	struct:DateTime	file:
validJD	date.c	/^  char validJD;    \/* True if rJD is valid *\/$/;"	m	struct:DateTime	file:
validTZ	date.c	/^  char validTZ;    \/* True if tz is valid *\/$/;"	m	struct:DateTime	file:
validYMD	date.c	/^  char validYMD;   \/* True if Y,M,D are valid *\/$/;"	m	struct:DateTime	file:
value_blob	sqlite3ext.h	/^  const void * (*value_blob)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes	sqlite3ext.h	/^  int  (*value_bytes)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes16	sqlite3ext.h	/^  int  (*value_bytes16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_double	sqlite3ext.h	/^  double  (*value_double)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int	sqlite3ext.h	/^  int  (*value_int)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int64	sqlite3ext.h	/^  sqlite_int64  (*value_int64)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_numeric_type	sqlite3ext.h	/^  int  (*value_numeric_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text	sqlite3ext.h	/^  const unsigned char * (*value_text)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16	sqlite3ext.h	/^  const void * (*value_text16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16be	sqlite3ext.h	/^  const void * (*value_text16be)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16le	sqlite3ext.h	/^  const void * (*value_text16le)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_type	sqlite3ext.h	/^  int  (*value_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
vdbeCommit	vdbeaux.c	/^static int vdbeCommit(sqlite3 *db){$/;"	f	file:
vdbeUnbind	vdbeapi.c	/^static int vdbeUnbind(Vdbe *p, int i){$/;"	f	file:
versionFunc	func.c	/^static void versionFunc($/;"	f	file:
vfsFlags	pager.c	/^  u32 vfsFlags;               \/* Flags for sqlite3_vfs.xOpen() *\/$/;"	m	struct:Pager	file:
vfsList	os.c	/^static sqlite3_vfs *vfsList = 0;$/;"	v	file:
vfsUnlink	os.c	/^static void vfsUnlink(sqlite3_vfs *pVfs){$/;"	f	file:
vfs_find	sqlite3ext.h	/^  sqlite3_vfs *(*vfs_find)(const char*);$/;"	m	struct:sqlite3_api_routines
vfs_register	sqlite3ext.h	/^  int (*vfs_register)(sqlite3_vfs*,int);$/;"	m	struct:sqlite3_api_routines
vfs_unlink_test	test1.c	/^static int vfs_unlink_test($/;"	f	file:
vfs_unregister	sqlite3ext.h	/^  int (*vfs_unregister)(sqlite3_vfs*);$/;"	m	struct:sqlite3_api_routines
vmprintf	sqlite3ext.h	/^  char *(*vmprintf)(const char*,va_list);$/;"	m	struct:sqlite3_api_routines
vtabCallConstructor	vtab.c	/^static int vtabCallConstructor($/;"	f	file:
vtabarg	parse.y	/^vtabarg ::= .                       {sqlite3VtabArgInit(pParse);}$/;"	l
vtabarg	parse.y	/^vtabarg ::= vtabarg vtabargtoken.$/;"	l
vtabarglist	parse.y	/^vtabarglist ::= vtabarg.$/;"	l
vtabarglist	parse.y	/^vtabarglist ::= vtabarglist COMMA vtabarg.$/;"	l
vtabargtoken	parse.y	/^vtabargtoken ::= ANY(X).            {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtabargtoken	parse.y	/^vtabargtoken ::= lp anylist RP(X).  {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vxprintf	printf.c	/^static void vxprintf($/;"	f	file:
walkExprList	expr.c	/^static int walkExprList(ExprList *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
walkExprTree	expr.c	/^static int walkExprTree(Expr *pExpr, int (*xFunc)(void*,Expr*), void *pArg){$/;"	f	file:
walkSelectExpr	expr.c	/^static int walkSelectExpr(Select *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
wantToLock	btreeInt.h	/^  int wantToLock;    \/* Number of nested calls to sqlite3BtreeEnter() *\/$/;"	m	struct:Btree
whereClauseClear	where.c	/^static void whereClauseClear(WhereClause *pWC){$/;"	f	file:
whereClauseInit	where.c	/^static void whereClauseInit($/;"	f	file:
whereClauseInsert	where.c	/^static int whereClauseInsert(WhereClause *pWC, Expr *p, int flags){$/;"	f	file:
whereInfoFree	where.c	/^static void whereInfoFree(WhereInfo *pWInfo){$/;"	f	file:
whereSplit	where.c	/^static void whereSplit(WhereClause *pWC, Expr *pExpr, int op){$/;"	f	file:
whereTempTriggers	alter.c	/^static char *whereTempTriggers(Parse *pParse, Table *pTab){$/;"	f	file:
winAccess	os_win.c	/^static int winAccess($/;"	f	file:
winCheckReservedLock	os_win.c	/^static int winCheckReservedLock(sqlite3_file *id){$/;"	f	file:
winClose	os_win.c	/^static int winClose(sqlite3_file *id){$/;"	f	file:
winCurrentTime	os_win.c	/^int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){$/;"	f
winDelete	os_win.c	/^static int winDelete($/;"	f	file:
winDeviceCharacteristics	os_win.c	/^static int winDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
winDlClose	os_win.c	/^void winDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
winDlClose	os_win.c	1445;"	d	file:
winDlError	os_win.c	/^static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
winDlError	os_win.c	1443;"	d	file:
winDlOpen	os_win.c	/^static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
winDlOpen	os_win.c	1442;"	d	file:
winDlSym	os_win.c	/^void *winDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){$/;"	f
winDlSym	os_win.c	1444;"	d	file:
winFile	os_win.c	/^struct winFile {$/;"	s	file:
winFile	os_win.c	/^typedef struct winFile winFile;$/;"	t	typeref:struct:winFile	file:
winFileControl	os_win.c	/^static int winFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
winFileSize	os_win.c	/^static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){$/;"	f	file:
winFullPathname	os_win.c	/^static int winFullPathname($/;"	f	file:
winGetTempname	os_win.c	/^static int winGetTempname(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winIoMethod	os_win.c	/^static const sqlite3_io_methods winIoMethod = {$/;"	v	file:
winLock	os_win.c	/^static int winLock(sqlite3_file *id, int locktype){$/;"	f	file:
winOpen	os_win.c	/^static int winOpen($/;"	f	file:
winRandomness	os_win.c	/^static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winRead	os_win.c	/^static int winRead($/;"	f	file:
winSectorSize	os_win.c	/^static int winSectorSize(sqlite3_file *id){$/;"	f	file:
winSleep	os_win.c	/^static int winSleep(sqlite3_vfs *pVfs, int microsec){$/;"	f	file:
winSync	os_win.c	/^static int winSync(sqlite3_file *id, int flags){$/;"	f	file:
winTruncate	os_win.c	/^static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){$/;"	f	file:
winUnlock	os_win.c	/^static int winUnlock(sqlite3_file *id, int locktype){$/;"	f	file:
winWrite	os_win.c	/^static int winWrite($/;"	f	file:
winceCreateLock	os_win.c	/^static BOOL winceCreateLock(const char *zFilename, winFile *pFile){$/;"	f	file:
winceDestroyLock	os_win.c	/^static void winceDestroyLock(winFile *pFile){$/;"	f	file:
winceLock	os_win.c	/^typedef struct winceLock {$/;"	s	file:
winceLock	os_win.c	/^} winceLock;$/;"	t	typeref:struct:winceLock	file:
winceLockFile	os_win.c	/^static BOOL winceLockFile($/;"	f	file:
winceLockFileEx	os_win.c	/^static BOOL winceLockFileEx($/;"	f	file:
winceMutexAcquire	os_win.c	/^static void winceMutexAcquire(HANDLE h){$/;"	f	file:
winceMutexRelease	os_win.c	331;"	d	file:
winceUnlockFile	os_win.c	/^static BOOL winceUnlockFile($/;"	f	file:
working_64bit_int	test1.c	/^static int working_64bit_int($/;"	f	file:
wrFlag	btreeInt.h	/^  u8 wrFlag;                \/* True if writable *\/$/;"	m	struct:BtCursor
writableSchema	shell.c	/^  int writableSchema;    \/* True if PRAGMA writable_schema=ON *\/$/;"	m	struct:callback_data	file:
write32bits	pager.c	/^static int write32bits(sqlite3_file *fd, i64 offset, u32 val){$/;"	f	file:
writeJournalHdr	pager.c	/^static int writeJournalHdr(Pager *pPager){$/;"	f	file:
writeListAppend	test6.c	/^static int writeListAppend($/;"	f	file:
writeListSync	test6.c	/^static int writeListSync(CrashFile *pFile, int isCrash){$/;"	f	file:
writeMask	sqliteInt.h	/^  u32 writeMask;       \/* Start a write transaction on these databases *\/$/;"	m	struct:Parse
writeMasterJournal	pager.c	/^static int writeMasterJournal(Pager *pPager, const char *zMaster){$/;"	f	file:
write_history	shell.c	43;"	d	file:
writerHaltNow	test_async.c	/^  volatile int writerHaltNow;       \/* Writer thread halts after next op *\/$/;"	m	struct:TestAsyncStaticData	file:
writerHaltWhenIdle	test_async.c	/^  volatile int writerHaltWhenIdle;  \/* Writer thread halts when queue empty *\/$/;"	m	struct:TestAsyncStaticData	file:
writerMutex	test_async.c	/^  pthread_mutex_t writerMutex; \/* Prevents multiple writer threads *\/$/;"	m	struct:TestAsyncStaticData	file:
writerMutexHolder	test_async.c	/^  pthread_t writerMutexHolder;$/;"	m	struct:TestAsyncDebugData	file:
xAuth	sqliteInt.h	/^  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);$/;"	m	struct:sqlite3
xBusy	test_thread.c	/^static int xBusy(void *pArg, int nBusy){$/;"	f	file:
xCmp	sqliteInt.h	/^  int (*xCmp)(void*,int, const void*, int, const void*);$/;"	m	struct:CollSeq
xCodec	pager.c	/^  void *(*xCodec)(void*,void*,Pgno,int); \/* Routine for en\/decoding data *\/$/;"	m	struct:Pager	file:
xCollNeeded	sqliteInt.h	/^  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);$/;"	m	struct:sqlite3
xCollNeeded16	sqliteInt.h	/^  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);$/;"	m	struct:sqlite3
xCommitCallback	sqliteInt.h	/^  int (*xCommitCallback)(void*);    \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xCompare	btreeInt.h	/^  int (*xCompare)(void*,int,const void*,int,const void*); \/* Key comp func *\/$/;"	m	struct:BtCursor
xDel	sqliteInt.h	/^  void (*xDel)(void*);  \/* Destructor for pUser *\/$/;"	m	struct:CollSeq
xDel	vdbeInt.h	/^  void (*xDel)(void *);  \/* If not null, call this function to delete Mem.z *\/$/;"	m	struct:Mem
xDelete	vdbeInt.h	/^    void (*xDelete)(void *);      \/* Destructor for the aux data *\/$/;"	m	struct:VdbeFunc::AuxData
xDestroy	sqliteInt.h	/^  void (*xDestroy)(void *);            \/* Module destructor function *\/$/;"	m	struct:Module
xDestructor	pager.c	/^  void (*xDestructor)(DbPage*,int); \/* Call this routine when freeing pages *\/$/;"	m	struct:Pager	file:
xFinalize	sqliteInt.h	/^  void (*xFinalize)(sqlite3_context*);                \/* Aggregate finializer *\/$/;"	m	struct:FuncDef
xFreeAux	sqliteInt.h	/^  void (*xFreeAux)(void*);  \/* Routine to free pAux *\/$/;"	m	struct:Db
xFreeSchema	btreeInt.h	/^  void (*xFreeSchema)(void*);  \/* Destructor for BtShared.pSchema *\/$/;"	m	struct:BtShared
xFunc	sqliteInt.h	/^  int (*xFunc)(void *,int);  \/* The busy callback *\/$/;"	m	struct:BusyHandler
xFunc	sqliteInt.h	/^  void (*xFunc)(sqlite3_context*,int,sqlite3_value**); \/* Regular function *\/$/;"	m	struct:FuncDef
xOp	test4.c	/^  void (*xOp)(Thread*);  \/* next operation to do *\/$/;"	m	struct:Thread	file:
xOp	test7.c	/^  void (*xOp)(Thread*);    \/* next operation to do *\/$/;"	m	struct:Thread	file:
xProfile	sqliteInt.h	/^  void (*xProfile)(void*,const char*,u64);  \/* Profiling function *\/$/;"	m	struct:sqlite3
xProgress	sqliteInt.h	/^  int (*xProgress)(void *);     \/* The progress callback *\/$/;"	m	struct:sqlite3
xReiniter	pager.c	/^  void (*xReiniter)(DbPage*,int);   \/* Call this routine when reloading pages *\/$/;"	m	struct:Pager	file:
xRollbackCallback	sqliteInt.h	/^  void (*xRollbackCallback)(void*); \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xStep	sqliteInt.h	/^  void (*xStep)(sqlite3_context*,int,sqlite3_value**); \/* Aggregate step *\/$/;"	m	struct:FuncDef
xTrace	sqliteInt.h	/^  void (*xTrace)(void*,const char*);        \/* Trace function *\/$/;"	m	struct:sqlite3
xUpdateCallback	sqliteInt.h	/^  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);$/;"	m	struct:sqlite3
xferCompatibleCollation	insert.c	/^static int xferCompatibleCollation(const char *z1, const char *z2){$/;"	f	file:
xferCompatibleIndex	insert.c	/^static int xferCompatibleIndex(Index *pDest, Index *pSrc){$/;"	f	file:
xferOptimization	insert.c	/^static int xferOptimization($/;"	f	file:
z	sqliteInt.h	/^  const unsigned char *z; \/* Text of the token.  Not NULL-terminated! *\/$/;"	m	struct:Token
z	test1.c	/^  char *z;     \/* The space *\/$/;"	m	struct:dstr	file:
z	vdbe.h	/^    char *z;               \/* Pointer to data for string (char array) types *\/$/;"	m	union:VdbeOp::__anon12
z	vdbeInt.h	/^  char *z;            \/* String or BLOB value *\/$/;"	m	struct:Mem
zAlias	sqliteInt.h	/^    char *zAlias;     \/* The "B" part of a "A AS B" phrase.  zName is the "A" *\/$/;"	m	struct:SrcList::SrcList_item
zAlloc	test_onefile.c	/^  char *zAlloc;$/;"	m	struct:tmp_file	file:
zArg	test4.c	/^  char *zArg;            \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zArg	test7.c	/^  char *zArg;              \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zAuth	tclsqlite.c	/^  char *zAuth;               \/* The authorization callback routine *\/$/;"	m	struct:SqliteDb	file:
zAuthContext	sqliteInt.h	/^  const char *zAuthContext;   \/* Put saved Parse.zAuthContext here *\/$/;"	m	struct:AuthContext
zAuthContext	sqliteInt.h	/^  const char *zAuthContext; \/* The 6th parameter to db->xAuth callbacks *\/$/;"	m	struct:Parse
zBase	sqliteInt.h	/^  char *zBase;     \/* A base allocation.  Not from malloc. *\/$/;"	m	struct:StrAccum
zBuf	journal.c	/^  char *zBuf;                     \/* Space to buffer journal writes *\/$/;"	m	struct:JournalFile	file:
zBuf	test6.c	/^  u8 *zBuf;                    \/* Pointer to copy of written data *\/$/;"	m	struct:WriteBuffer	file:
zBuf	test_async.c	/^  char *zBuf;         \/* Data to write to file (or NULL if op!=ASYNC_WRITE) *\/$/;"	m	struct:AsyncWrite	file:
zBusy	tclsqlite.c	/^  char *zBusy;               \/* The busy callback routine *\/$/;"	m	struct:SqliteDb	file:
zCol	sqliteInt.h	/^    char *zCol;        \/* Name of column in zTo.  If 0 use PRIMARY KEY *\/$/;"	m	struct:FKey::sColMap
zColAff	sqliteInt.h	/^  char *zColAff;     \/* String defining the affinity of each column *\/$/;"	m	struct:Table
zColAff	sqliteInt.h	/^  char *zColAff;   \/* String defining the affinity of each column *\/$/;"	m	struct:Index
zColl	sqliteInt.h	/^  char *zColl;     \/* Collating sequence.  If NULL, use the default *\/$/;"	m	struct:Column
zComment	vdbe.h	/^  char *zComment;     \/* Comment to improve readability *\/$/;"	m	struct:VdbeOp
zCommit	tclsqlite.c	/^  char *zCommit;             \/* The commit hook callback routine *\/$/;"	m	struct:SqliteDb	file:
zCrashFile	test6.c	/^  char zCrashFile[500];        \/* Crash during an xSync() on this file *\/ $/;"	m	struct:CrashGlobal	file:
zData	test6.c	/^  u8 *zData;                           \/* Buffer containing file contents *\/$/;"	m	struct:CrashFile	file:
zDatabase	analyze.c	/^  const char *zDatabase;$/;"	m	struct:analysisInfo	file:
zDatabase	sqliteInt.h	/^    char *zDatabase;  \/* Name of database holding this table *\/$/;"	m	struct:SrcList::SrcList_item
zDb	sqliteInt.h	/^  const char *zDb;    \/* Make sure all objects are contained in this database *\/$/;"	m	struct:DbFixer
zDbFilename	shell.c	/^  const char *zDbFilename;    \/* name of the database file *\/$/;"	m	struct:callback_data	file:
zDeleteOnClose	os_win.c	/^  WCHAR *zDeleteOnClose;  \/* Name of file to delete when closing *\/$/;"	m	struct:winFile	file:
zDestTable	shell.c	/^  char *zDestTable;      \/* Name of destination table when MODE_Insert *\/$/;"	m	struct:callback_data	file:
zDirectory	pager.c	/^  char *zDirectory;           \/* Directory hold database and journal files *\/$/;"	m	struct:Pager	file:
zErr	test4.c	/^  char *zErr;           \/* operation error *\/$/;"	m	struct:Thread	file:
zErr	test7.c	/^  char *zErr;              \/* operation error *\/$/;"	m	struct:Thread	file:
zErrMsg	btreeInt.h	/^  char *zErrMsg;    \/* An error message.  NULL if no errors seen. *\/$/;"	m	struct:IntegrityCk
zErrMsg	sqliteInt.h	/^  char *zErrMsg;                \/* Most recent error message (UTF-8 encoded) *\/$/;"	m	struct:sqlite3
zErrMsg	sqliteInt.h	/^  char *zErrMsg;       \/* An error message *\/$/;"	m	struct:Parse
zErrMsg	table.c	/^  char *zErrMsg;$/;"	m	struct:TabResult	file:
zErrMsg	vdbeInt.h	/^  char *zErrMsg;          \/* Error message written here *\/$/;"	m	struct:Vdbe
zErrMsg16	sqliteInt.h	/^  char *zErrMsg16;              \/* Most recent error message (UTF-16 encoded) *\/$/;"	m	struct:sqlite3
zFilename	pager.c	/^  char *zFilename;            \/* Name of the database file *\/$/;"	m	struct:Pager	file:
zFilename	test4.c	/^  char *zFilename;       \/* Name of database file *\/$/;"	m	struct:Thread	file:
zFilename	test7.c	/^  char *zFilename;         \/* Name of database file *\/$/;"	m	struct:Thread	file:
zHelp	shell.c	/^static char zHelp[] =$/;"	v	file:
zIn	test_server.c	/^  const char *zIn;             \/* Input filename or SQL statement *\/$/;"	m	struct:SqlMessage	file:
zJournal	journal.c	/^  const char *zJournal;           \/* Name of the journal file *\/$/;"	m	struct:JournalFile	file:
zJournal	pager.c	/^  char *zJournal;             \/* Name of the journal file *\/$/;"	m	struct:Pager	file:
zLogName	test8.c	/^  char *zLogName;         \/* Name of the log table *\/$/;"	m	struct:echo_vtab	file:
zMagicHeader	btree.c	/^static const char zMagicHeader[] = SQLITE_FILE_HEADER;$/;"	v	file:
zMainloop	tclsqlite.c	/^static char zMainloop[] = $/;"	v	file:
zMainloop	tclsqlite.c	/^static char zMainloop[] =$/;"	v	file:
zName	build.c	/^  const char *zName;   \/* Name of the table *\/$/;"	m	struct:TableLock	file:
zName	sqliteInt.h	/^    char *zName;           \/* Token associated with this expression *\/$/;"	m	struct:ExprList::ExprList_item
zName	sqliteInt.h	/^    char *zName;      \/* Name of the identifier *\/$/;"	m	struct:IdList::IdList_item
zName	sqliteInt.h	/^    char *zName;      \/* Name of the table *\/$/;"	m	struct:SrcList::SrcList_item
zName	sqliteInt.h	/^  char *zName;          \/* Name of the collating sequence, UTF-8 encoded *\/$/;"	m	struct:CollSeq
zName	sqliteInt.h	/^  char *zName;         \/* Name of this database *\/$/;"	m	struct:Db
zName	sqliteInt.h	/^  char *zName;     \/* Name of the table *\/$/;"	m	struct:Table
zName	sqliteInt.h	/^  char *zName;     \/* Name of this column *\/$/;"	m	struct:Column
zName	sqliteInt.h	/^  char *zName;     \/* Name of this index *\/$/;"	m	struct:Index
zName	sqliteInt.h	/^  char zName[1];       \/* SQL name of the function.  MUST BE LAST *\/$/;"	m	struct:FuncDef
zName	sqliteInt.h	/^  const char *zName;                   \/* Name passed to create_module() *\/$/;"	m	struct:Module
zName	tclsqlite.c	/^  char *zName;          \/* Name of this function *\/$/;"	m	struct:SqlFunc	file:
zName	test6.c	/^  char *zName;$/;"	m	struct:CrashFile	file:
zName	test_async.c	/^  char *zName;               \/* Underlying OS filename - used for debugging *\/$/;"	m	struct:AsyncFileData	file:
zName	test_onefile.c	/^  const char *zName;$/;"	m	struct:fs_real_file	file:
zNeededCollation	test1.c	/^static char zNeededCollation[200];$/;"	v	file:
zNull	tclsqlite.c	/^  char *zNull;               \/* Text to substitute for an SQL NULL value *\/$/;"	m	struct:SqliteDb	file:
zOptions	shell.c	/^static const char zOptions[] = $/;"	v	file:
zOut	test_server.c	/^  const char *zOut;            \/* Tail of the SQL statement *\/$/;"	m	struct:SqlMessage	file:
zProfile	tclsqlite.c	/^  char *zProfile;            \/* The profile callback routine *\/$/;"	m	struct:SqliteDb	file:
zProgress	tclsqlite.c	/^  char *zProgress;           \/* The progress callback routine *\/$/;"	m	struct:SqliteDb	file:
zScript	tclsqlite.c	/^  char *zScript;        \/* The script to be run *\/$/;"	m	struct:SqlCollate	file:
zScript	test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:EvalEvent	file:
zScript	test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:SqlThread	file:
zShellStatic	shell.c	/^static const char *zShellStatic = 0;$/;"	v	file:
zShort	vdbeInt.h	/^  char zShort[NBFS];  \/* Space for short strings *\/$/;"	m	struct:Mem
zSql	sqliteInt.h	/^  const char *zSql;    \/* All SQL text *\/$/;"	m	struct:Parse
zSql	tclsqlite.c	/^  const char *zSql;        \/* Text of the SQL statement *\/$/;"	m	struct:SqlPreparedStmt	file:
zSql	vdbeInt.h	/^  char *zSql;           \/* Text of the SQL statement that generated this *\/$/;"	m	struct:Vdbe
zStaticErr	test4.c	/^  char *zStaticErr;     \/* Static error message *\/$/;"	m	struct:Thread	file:
zStaticErr	test7.c	/^  char *zStaticErr;        \/* Static error message *\/$/;"	m	struct:Thread	file:
zStmtJrnl	pager.c	/^  char *zStmtJrnl;            \/* Name of the statement journal file *\/$/;"	m	struct:Pager	file:
zTableName	test8.c	/^  char *zTableName;       \/* Name of the real table *\/$/;"	m	struct:echo_vtab	file:
zTail	sqliteInt.h	/^  const char *zTail;   \/* All SQL text past the last semicolon parsed *\/$/;"	m	struct:Parse
zText	sqliteInt.h	/^  char *zText;     \/* The string collected so far *\/$/;"	m	struct:StrAccum
zThis	test8.c	/^  char *zThis;            \/* Name of the echo table *\/$/;"	m	struct:echo_vtab	file:
zTitle	mem2.c	/^  char zTitle[100];  \/* The title text *\/$/;"	m	struct:__anon5	file:
zTo	sqliteInt.h	/^  char *zTo;        \/* Name of table that the key points to *\/$/;"	m	struct:FKey
zTrace	tclsqlite.c	/^  char *zTrace;              \/* The trace callback routine *\/$/;"	m	struct:SqliteDb	file:
zType	sqliteInt.h	/^  char *zType;     \/* Data type for this column *\/$/;"	m	struct:Column
zType	sqliteInt.h	/^  const char *zType;  \/* Type of the container - used for error messages *\/$/;"	m	struct:DbFixer
zVarname	test_thread.c	/^  char *zVarname;          \/* Varname in parent script *\/$/;"	m	struct:SqlThread	file:
zeroData	btreeInt.h	/^  u8 zeroData;         \/* True if table stores keys only *\/$/;"	m	struct:MemPage
zeroPage	btree.c	/^static void zeroPage(MemPage *pPage, int flags){$/;"	f	file:
zeroblobFunc	func.c	/^static void zeroblobFunc($/;"	f	file:
zeroed	vdbeInt.h	/^  Bool zeroed;          \/* True if zeroed out and ready for reuse *\/$/;"	m	struct:Cursor
