#ifndef __SEC_FIFO_H
#define __SEC_FIFO_H

#define SEC_MAX_LEN (1024*1024)

typedef struct{
	char 	*buffer;			//指向缓冲区的指针
	int	in;				//准备写入的位置	
	int	out;				//准备读取的位置
	int	remain;				//未读取的字节数=准备写入的位置-准备读取的位置
	int	size;				//缓冲区可以使用的长度，应该小于sec_max_len
	int 	stop;				//停止读取数据标志，为1停止读取，为0继续读取
	pthread_mutex_t lock;			//读写锁,同一时间要么是读出，要么是写入
	pthread_mutex_t rlock;
	pthread_cond_t isvalid;         //条件变量
}sec_buffer_t;


#ifdef DEBUG
#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBG(...)
#endif


#define DEBUGR

#ifdef DEBUGR
#define DBGR(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBGR(...)
#endif
/*************************************************************
 * 函数名称:	sec_buff_write()
 * 功能:	向缓冲区写入数据
 * 输入参数:	*sec_buff,*buff,buff_len
 * 返回值:	正确返回正值，表示写入的长度，负值错误
 * 备注:	写缓冲区采用重复的覆盖写，当写完一轮后如果没有写
 * 		完那么就转到缓冲区的开头重新开始写，如果还是没有
 * 		完那么就重复转到缓冲区的开头再重新覆盖原来的数据
 * 		继续写，直到把全部数据写完位置
 * *************************************************************/
int sec_buff_write(sec_buffer_t *sec_buff,char *buff,int buff_len);




/***************************************************************
 *函数名称:	sec_buff_read()
 *功能:		从缓冲区中读指定长度数据
 *输入参数：	*sec_buff	指向缓冲区结构的指针
 *		*buff		指向输出的缓冲区指针
 *		len		读取的长度
 *返回值:	正值读到的字节数，负值表示失败
 *备注：	读取数据与写入数据不同，读取只执行一次，不会用while
 *		循环读，因为写入的数据是覆盖写入的，所以即使使用
 *		循环读则读出来的数据也是最新覆盖的数据。
 *		此接口从环形缓冲区中读取指定长度的数据:
 *		1.如果当前准备读取的位置在写入的位置之前时：
 *		(1.1)当前读取位置+读取长度<=准备写入的位置，则读取
 *		指定长度字节数；
 *		(1.2)当前读取位置+读取长度>准备写入的位置，则读取
 *		(准备写入位置-准备读取位置)的长度字节数；
 *		2.如果当前准备读取的位置在写入的位置之后时：
 *		(2.1)当前读取位置+读取长度<=size长度时，则读取指定
 *		长度的字节数；
 *		(2.2)当前读取位置+读取长度>size长度时，则先读取
 *		(size-当前读取位置)长度字节数，再读取剩下长度
 *		(读取长度-size+当前读取位置)长度字节数;
 * ************************************************************/
int sec_buff_read(sec_buffer_t *sec_buff,char *buff,int len);



/*************************************************************
 *函数名称:	sec_buff_init()
 *功能:		初始化缓冲区
 *输入参数：	无
 *返回值:	0正确，负值错误
 *备注:		分配缓冲区的时候将分配SEC_MAX_LEN长的缓冲区
 * ***********************************************************/
int sec_buff_init(sec_buffer_t *sec_buff);



/*************************************************************
 *函数名称:	sec_buff_exit()
 *功能:		释放缓冲区内存；
 *输入参数:	指向缓冲区结构的指针
 *返回值:	无
 * **********************************************************/
void sec_buff_exit(sec_buffer_t *sec_buff);



/************************************************************
 *函数名称:	sec_buff_remain()
 *功能:		获取当前缓冲区中尚未读取的数据的长度
 *输入参数:	*sec_buff	指向缓冲区结构的指针
 *返回值:	缓冲区中尚未读取的长度
 * **********************************************************/
int sec_buff_remain(sec_buffer_t *sec_buff);


/************************************************************
 *函数名称:	sec_buff_resize() 
 *功能:		改变缓冲区大小
 *输入参数:	resize	新指定的缓冲区大小，这个值应该小于
 *			sec_max_len
 *返回值:	无
 * **********************************************************/
void sec_buff_resize(sec_buffer_t *sec_buff,int resize);


/*************************************************************
*函数名称:  sec_buff_get_size()
*功能:              获取当前缓冲区大小
*输入参数:  *sec_buff   指向缓冲区结构的指针
*返回值:        当前缓冲区大小
*备注:              无
**************************************************************/
int sec_buff_get_size(sec_buffer_t *sec_buff);



#endif
